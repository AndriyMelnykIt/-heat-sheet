import generateUUID from './src/services/generateUUID';

export const modules = [
  {
    id: generateUUID(),
    name: 'Internet',
    questions: [
      {
        id: generateUUID(),
        question: 'What is DNS?',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Прогресивний рендеринг',
        descriptions: [
          {
            code: false,
            label: 'Що таке прогресивний рендеринг?',
            description:
              'Прогресивний рендеринг – це назва технологій, що використовуються для прискорення відтворення сторінок (зокрема, для зменшення часу завантаження), щоб показати користувачеві контент якнайшвидше. До того, як широкосмуговий інтернет поширився повсюдно, прогресивний рендеринг зустрічався досить часто.',
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке прогресивний SSR?',
        descriptions: [
          {
            code: false,
            label: 'Прогресивний SSR?',
            description: `SSR (Server-Side Rendering) генерує повний HTML для сторінки на сервері у відповідь на запит (перехід по посиланню). Це дозволяє уникнути додаткових запитів даних, наповнення шаблонів на стороні клієнта, оскільки вони обробляються до того, як браузер отримує відповідь.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке потік документа?',
        descriptions: [
          {
            code: false,
            label: 'Що таке потік документа?',
            description: `Документний потік - це сукупність розподілених у часі і просторі документів, які рухаються по комунікаційним каналам від створювачів та виробників до користувачів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Різниця між адаптивним (adaptive) та чуйним (responsive) дизайнами?',
        descriptions: [
          {
            code: false,
            label: 'Responsive design',
            description: `За найпростішим визначенням, гнучкий дизайн використовує лише один макет веб-сторінки і «гнучко» змінюється так, щоб краще відповідати екрану користувача, будь то настільний комп’ютер, ноутбук, планшет чи мобільний телефон.
Якщо дивитися з більш технічного боку, то гнучкі веб-сторінки використовують CSS медіазапити та маркери розмірів (breakpoints; далі брейкпоінт) для коригування масштабу зображень, переносу (а також масштабування) тексту та інших елементів.`,
          },
          {
            code: false,
            label: 'Adaptive design',
            description: `Загалом вважається, що адаптивний дизайн — це фіксовані макети, які адаптуються до певних розмірів екрану. Коротко кажучи, у вас є кілька версій веб-сторінки, які відповідають якомусь пристрою, на відміну від однієї, статичної сторінки, яка виглядає однаково і змінює порядок (чи змінює розмір вмісту) на всіх пристроях.В адаптивному дизайні прийнято розробляти UI-макети для 6 найпоширеніших ширин екрану: 320, 480, 760, 960, 1200 і 1600 пікселів`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Різниця між Progressive Enhancement та Graceful Degradation?',
        descriptions: [
          {
            code: false,
            label: 'Graceful Degradation || Поступова Деградація',
            description: `Поступова деградація—це стратегія розробки, при якій ваш веб-інтерфейс першочергово призначений для перегляду в сучасних браузерах, тоді як в старих браузерах він відображатиметься з обмеженим набором можливостей, але, як мінімум, з базовим функціоналом. Якщо ми говорим про JavaScript, то це означає, що не весь функціонал може бути доступним, в силу відсутності підтримки окремих JS можливостей. Або ж, сайт функціонуватиме і за умови виключеного JS, але лише у базовому режимі. Щодо CSS, за відсутності підтримки тієї чи іншої CSS властивості, сайт функціонуватиме і матиме зрозумілий вигляд, але не такий красивий як у сучасному броузері, що підтримує останні можливості CSS`,
          },
          {
            code: false,
            label: 'Progressive enhancement || Прогресивне покращення',
            description: `Прогресивне покращення дивиться на проблему підтримки старих браузерів з протилежної сторони — розробка веб-інтерфейсу відбувається поетапно, від простого до складного. На кожному з етапів ми отримуємо завершений веб-інтерфейс, що з кожним етапом стає ще кращим, ще зручнішим. В результаті виходить ресурс, що працює у всіх браузерах.`,
          },
          {
            code: false,
            label: 'Основна відміннсть',
            description: `Основна відмінність між цими двома принципами це те, звідки починається розробка. Якщо починати розробку, орієнтуючись на найстаріший браузер зі списку тих, що повинен підтрумувати ваш продукт, а опісля додавати специфічний функціонал для новіших версій, то це — прогресивне покращення. Якщо ж починати створення веб-інтерфейсу під найновіші браузери, а потім просто ховати чи спрощувати деякі функціональності для старіших — це поступова деградація.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке кросбраузерність?',
        descriptions: [
          {
            code: false,
            label: 'Кросбраузерність',
            description: `Кросбраузерність сайту — це властивість сайту однаково відображатися та функціонувати у відповідності до поставленого завдання в усіх браузерах. Простіше кажучи, таку характеристику дають сайтам, дизайн яких однаковий як в Internet Explorer, так і в Google Chrome.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Babel',
        descriptions: [
          {
            code: false,
            label: 'Що таке Babel? Навіщо він використовується?',
            description: `Babel — можливість писати код «нового стандарту» (з новим функціоналом) не хвилюючись, що цей новий функціонал може не підтримуватись браузерами.`,
          },
          {
            code: false,
            label: 'Що він робить?',
            description: `Babel бере написаний нами код з новим функціоналом та перетворює (транскомпілює) його в аналогічний код, але «старого зразка». Це робиться тому, що саме цей код, код «старого зразка», браузер розуміє без проблем.`,
          },
          {
            code: true,
            label: 'Put in next-gen JavaScript',
            description: `[1,2,3].map(n => n ** 2)`,
          },
          {
            code: true,
            label: 'Get Browser-compatible JavaScript out',
            description: `[1,2,3].map(function (n) {
  return Math.pow(n, 2);
}`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Різниця між feature detection, feature inference та аналізом рядка user-agent?',
        descriptions: [
          {
            code: false,
            label: 'Feature detection',
            description: `Feature detection - це визначення можливостей браузера чи пристрою, які можуть бути використані у веб-додатках за допомогою коду. Наприклад, перевірка на підтримку HTML5 або CSS3.`,
          },
          {
            code: false,
            label: 'Feature inference',
            description: `Feature inference - це визначення можливостей браузера чи пристрою, які не можуть бути прямо перевірені за допомогою коду. Наприклад, визначення підтримки WebGL на основі підтримки OpenGL.`,
          },
          {
            code: false,
            label: 'User-agent ',
            description: `User-agent string analysis - це аналіз інформації про браузер та операційну систему, яка передається в HTTP-запиті від браузера до веб-сайту. Це може допомогти веб-сайту визначити, як він повинен поводитися для даного користувача. Наприклад, відображення вмісту у форматі мобільного пристрою для мобільного браузера.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Що таке Веб-компоненти та які технології в них використовуються?',
        descriptions: [
          {
            code: false,
            label: 'Feature detection',
            description: `Веб-компоненти (Web Components) - це стандартизований набір технологій веб-розробки, що дозволяють створювати перевикористовувані елементи інтерфейсу користувача (UI) зі своїм функціоналом, які можуть використовуватись в різних веб-додатках без необхідності копіювання та вставки коду.
            Веб-компоненти складаються з трьох технологій:
            Custom Elements - дозволяє розробникам створювати свої власні HTML-елементи зі своїми властивостями та методами. За допомогою цієї технології можна створити зручні, перевикористовувані компоненти зі своїм функціоналом.

Shadow DOM - дозволяє розробникам ізолювати стилі та логіку свого компонента від зовнішнього середовища. За допомогою Shadow DOM можна побудувати структуру компонента, яка буде недоступна для змін з зовнішнього коду, тим самим підвищивши безпеку та знизивши імовірність конфліктів між стилями та скриптами.

HTML Templates - дозволяє створювати шаблони HTML-коду, які можуть бути використані для створення нових елементів. Ця технологія дозволяє розробникам використовувати та маніпулювати зі складовими частинами елемента, що збільшує його перевикористовуваність.

Всі ці технології включаються в HTML-сторінку та забезпечують можливість створення веб-компонентів з уніфікованою структурою та поведінкою, що значно полегшує розробку та підтримку веб-додатків.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Способи зменшення часу завантаження веб-сторінки?',
        descriptions: [
          {
            code: false,
            label: 'Способи зменшення часу завантаження веб-сторінки',
            description: `Компресія зображень: Зображення часто становлять більше половини завантаженого контенту на сторінці. Використовуючи інструменти для компресії зображень, наприклад, Adobe Photoshop, ImageOptim або TinyPNG, можна зменшити розмір файлу зображення без втрати якості.
Мінімізація коду: Використання засобів, таких як CSS минифікатори та JS компресори, дозволяє зменшити розмір коду сторінки, що зменшує час завантаження.
Кешування: Використання кешування для зберігання тимчасової копії веб-сторінки на стороні клієнта може зменшити кількість запитів на сервер та зменшити час завантаження сторінки для повторних відвідувань.
Комбінування та мінімізація запитів: За допомогою об'єднання декількох файлів CSS та JavaScript в один файл та їх минифікації можна зменшити кількість запитів на сервер та зменшити час завантаження.
Використання CDN: Використання CDN (Content Delivery Network) дозволяє розподілити завантаження ресурсів на кілька серверів, що знаходяться ближче до користувача, що допомагає зменшити час завантаження сторінки.
Видалення зайвого контенту: Видалення зайвого контенту, такого як сторонні скрипти та не використовуваний код, може допомогти зменшити розмір сторінки`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Особливості розробки мультимовних сайтів?',
        descriptions: [
          {
            code: false,
            label: 'Мультимовний сайт',
            description: `Мультимовний сайт – це вебресурс, адаптований для користувачів, що володіють різними мовами.
            Як реалізувати мультимовність на сайті?
            Різні домени
            Найочевидніший спосіб зробити мультимовність сайту – використовувати різні доменні імена. Наприклад, для України – .ua, для Польщі – .pl, для Чехії – .cz. І так далі.
            За допомогою категорій та папок
            В даному випадку на сайт встановлюється модуль мультимовності, створюються категорії та папки, куди копіюється контент. Подібним чином структура сайту реалізується в рамках одного піддомену, а отже, і вага теж зберігається.
            Параметри
Такий метод вважається спірним, і навіть Google його не рекомендує. Принцип у тому, що дані про мовну та регіональну приналежність вебресурсу передаються через параметр URL. Реалізація мультимовності здійснюється в рамках єдиного домену, але просувати сторінки з параметрами насправді безглуздо.
            `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Flash Of Unstyled Content (FOUC)? Як його уникнути?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Flash Of Unstyled Content (FOUC)?',
            description: `Flash Of Unstyled Content (FOUC) - це проблема, коли сторінка завантажується без зовнішніх CSS стилів або з частково завантаженими стилями, що призводить до тимчасового зображення сторінки без стилів, а потім до зображення з правильним виглядом. Це може зіпсувати візуальний досвід користувачів та порушити дизайн сторінки.`,
          },
          {
            code: false,
            label: 'Як його уникнути?',
            description: `Щоб уникнути FOUC, можна використовувати такі підходи, як inline CSS, deferred loading of CSS, або використання preloading CSS. Inline CSS дозволяє браузеру відображати сторінку зі стилями, навіть якщо зовнішні стилі ще не завантажилися. Deferred loading дозволяє браузеру завантажувати стилі пізніше, коли основний зміст сторінки вже завантажено. Preloading CSS дозволяє браузеру завантажувати стилі раніше, ніж вони потрібні для відображення сторінки.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між layout, painting та compositing?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між layout, painting та compositing?',
            description: `
Layout, painting та compositing - це три різні етапи процесу відображення веб-сторінки в браузері. Кожен з цих етапів відповідає за певні аспекти відображення сторінки, і вони відбуваються послідовно один за одним. Ось короткий опис кожного з цих етапів:`,
          },
          {
            code: false,
            label: 'Layout (розміщення)',
            description: `Layout (розміщення): це перший етап відображення сторінки, коли браузер обчислює розміри та позиції кожного елемента на сторінці, враховуючи стиль та структуру HTML. Наприклад, браузер визначає, де повинен бути розміщений блок тексту та якого розміру повинен бути зображення.`,
          },
          {
            code: false,
            label: 'Painting (фарбування)',
            description: `Painting (фарбування): це другий етап відображення, коли браузер використовує розраховану розмітку та стилі для заповнення кольорами та тексту елементів сторінки. Цей етап включає фарбування фонів, текстів, зображень та інших елементів сторінки.`,
          },
          {
            code: false,
            label: 'Compositing (композиція)',
            description: `Compositing (композиція): це останній етап відображення, коли браузер об'єднує зображення та елементи сторінки в один зображення, яке потім відображається на екрані. Цей етап включає об'єднання шарів зображень, що містяться в окремих блоках`,
          },
          {
            code: false,
            label: 'Узагальнення',
            description: `Загалом, layout відповідає за розміщення елементів на сторінці, painting - за їхнє фарбування, а compositing - за об'єднання різних елементів та зображень в одне зображення. Кожен з цих етапів має важливу роль у відображенні веб-сторінок, і збій в будь-якому з них може призвести до проблем з відображенням сторінки в браузері`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Progressive Web Application?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Progressive Web Application?',
            description: `Progressive Web Application (PWA) – це додаток, створений за допомогою веб-технологій і є гібридом звичайного веб-сайту, доступ до якого здійснюється через браузер (в тому числі і браузер мобільного додатка). Такі гібридні веб-додатки імітують досвід використання нативних додатків і мають максимально наближений до них зовнішній вигляд і юзабіліті.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке міжсайтовий скриптинг (XSS)?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Міжсайтовий скриптинг (Cross-Site Scripting або XSS) - це тип атаки на веб-додатки, який полягає в виконанні зловмисного скрипту в браузері користувача з метою отримання доступу до конфіденційної інформації або контролю над обліковим записом користувача. 

Атака XSS може бути виконана шляхом вставки зловмисного коду у веб-сторінку, яка відображається в браузері користувача. Наприклад, зловмисник може вставити скрипт у поле вводу на веб-сайті, який потім буде відображений іншим користувачам, які зайшли на цей сайт. Якщо користувачі введуть дані в це поле, то зловмисний скрипт може виконатися у їхньому браузері, що може призвести до витоку конфіденційної інформації або виконання дій від імені користувача без його дозволу. 

Для уникнення атак XSS веб-розробники можуть використовувати заходи безпеки, такі як валідація та екранування введених користувачем даних, використання безпечних HTTP кукі, використання Content Security Policy (CSP) та інших технологій. Крім того, користувачі повинні бути обережні при введенні своїх даних на невідомих веб-сайтах та уникати виконання незнайомих скриптів у своєму браузері.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке API?',
        descriptions: [
          {
            code: false,
            label: 'Що таке API?',
            description: `API — це посередник між програмами, який задає правила «спілкування». API (Application Programming Interface) — це набір готових класів, процедур, функцій, структур і констант, що надаються додатком (бібліотекою, сервісом) для використання в зовнішніх програмних продуктах (Вікіпедія). Своїми словами, API надає нам можливість використовувати чужі напрацювання в своїх цілях.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CDN?',
        descriptions: [
          {
            code: false,
            label: ' CDN - це ...',
            description: `Мережа доставки вмісту (Content Delivery Network, або CDN) — це сукупність серверів, які доставляють вміст користувачеві.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке REST?',
        descriptions: [
          {
            code: false,
            label: 'Що таке REST?',
            description: `REST (скор. англ. Representational State Transfer, «передача репрезентативного стану») — підхід до архітектури мережевих протоколів, які надають доступ до інформаційних ресурсів. Був описаний і популяризований 2000 року Роєм Філдінгом, одним із творців протоколу HTTP.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке ip-адреса?',
        descriptions: [
          {
            code: false,
            label: 'Що таке ip-адреса?',
            description: `IP-адреса, адреса Ай-Пі — це ідентифікатор мережевого рівня, який використовується для адресації комп'ютерів чи пристроїв у мережах, які побудовані з використанням стеку протоколів TCP/IP. `,
          },
          {
            code: false,
            label: 'Як виглядає IP-адреса?',
            description: `У версії протоколу IPv4 IP-адреса має довжину 4 байти. В 4-й версії IP-адреса являє собою 32-бітове число. Зручною формою запису IP-адреси (IPv4) є запис у вигляді чотирьох десяткових чисел значенням від 0 до 255, розділених крапками, наприклад: 192.168.0.1. `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між host і domain?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між host і domain?',
            description: `Хостинг — це місце, де зберігається сайт , Його файли і база даних. Домен — це ім'я сайту в інтернеті. Для повноцінної роботи сайту потрібен і хостинг, і домен.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке URL?',
        descriptions: [
          {
            code: false,
            label: 'Що таке URL?',
            description: `URL означає Уніфікований покажчик інформаційного ресурсу. Це рядок символів, що визначає адресу. Це найпоширеніший спосіб ідентифікації місця розташування ресурсу в World Wide Web (WWW).`,
          },
          {
            code: false,
            label: 'Що таке URI',
            description: `Визначає URI Уніфікований ідентифікатор ресурсу. Це рядок символів, що використовується для ідентифікації ресурсу в Інтернеті або за місцем розташування, або за ім'ям, або за обома.`,
          },
          {
            code: false,
            label: 'Основна відмінність',
            description: `Основна відмінність між URL і URI є те, що URL-адреса дозволяє ідентифікувати веб-ресурс тільки за його розташуванням, а URI дозволяє ідентифікувати веб-ресурс, використовуючи ім'я або місце розташування, або обидва.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Чому очищувати кеш важливо? Як це можна зробити?',
        descriptions: [
          {
            code: false,
            label: 'Чому очищувати кеш важливо?',
            description: `Кеш - це тимчасове сховище, де зберігаються дані, які використовуються повторно для швидшого доступу до них. Кеш може містити збережені сторінки веб-сайту, зображення, стилі, скрипти та інші ресурси.`,
          },
          {
            code: false,
            label: 'Як це можна зробити?',
            description: `Використання клавіш Ctrl + Shift + Delete, щоб відкрити вікно очищення кешу у браузері.
У веб-браузері можна вибрати опцію «Очистити кеш» або «Очистити історію» в меню налаштувань.
У деяких браузерах можна використовувати розширення для очищення кешу та інших тимчасових файлів.
У некоторых ОС можна вибрати опцію "Очистити кеш" в меню налаштувань.
Застосування програм для очищення кешу, таких як CCleaner.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Назвіть критичні етапи рендерингу?',
        descriptions: [
          {
            code: false,
            label: 'Назвіть критичні етапи рендерингу?',
            description: `Критичний рендеринговий шлях (Critical Rendering Path) - це процес відправки запиту до сервера за HTML, обчислення CSS стилів, обчислення та відображення DOM, обчислення та відображення CSSOM і злиття їх в один документ.
Layout - це процес обчислення положення та розмірів елементів на сторінці.
Painting - це процес перетворення обчисленого вигляду елементів на сторінці в пікселі.
Compositing - це процес складання відображення сторінки з оброблених шарів пікселів.
Усі ці етапи взаємодіють між собою, і якщо хоча б один з них займає дуже багато часу, це може призвести до затримок у відображенні сторінки, зниження продуктивності та погіршення користувацького досвіду. Тому оптимізація критичного рендерингового шляху та всіх цих етапів є важливою задачею для покращення продуктивності веб-сторінок.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Core Web Vitals? Які основні метрики входять туди?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Core Web Vitals? Які основні метрики входять туди?',
            description: `Core Web Vitals - це група основних метрик продуктивності веб-сторінок, які були визначені Google з метою покращення користувацького досвіду в Інтернеті. Ці метрики визначаються на основі того, як швидко сторінка завантажується, реагує на дії користувача та як зручно користуватися нею.

Основні метрики Core Web Vitals включають:

1. Largest Contentful Paint (LCP) - ця метрика вимірює час, який потрібно браузеру для відображення найбільшого контентного елементу на сторінці. Ідеальний час LCP - менше 2,5 секунд.

2. First Input Delay (FID) - ця метрика вимірює затримку між першим взаємодією користувача зі сторінкою (наприклад, кліком на кнопку) та відповіддю сторінки. Ідеальний час FID - менше 100 мс.

3. Cumulative Layout Shift (CLS) - ця метрика вимірює, наскільки динамічно змінюється макет сторінки під час її завантаження. Ідеальний показник CLS - менше 0,1.

Ці метрики вважаються основними, оскільки вони дозволяють оцінити швидкість завантаження сторінки, забезпечити реагування на дії користувача та уникнути змін макету сторінки під час завантаження. Оцінка Core Web Vitals є важливою для SEO, тому що Google використовує їх для розміщення веб-сторінок у пошукових результатах.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про метрики Core Web Vitals?',
        descriptions: [
          {
            code: false,
            label: 'Розкажіть про метрики Core Web Vitals?',
            description: `Core Web Vitals - це набір метрик, які вимірюють кількісні показники взаємодії користувача з веб-сторінками, зокрема швидкість, стабільність та якість візуального відображення. Ці метрики були розроблені Google з метою покращення користувацького досвіду та сприяння оптимізації веб-сторінок.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між preload, prefetch, preconnect та prerender?',
        descriptions: [
          {
            code: false,
            label: 'preload',
            description: `Цей метод використовується для попереднього завантаження важливих ресурсів сторінки, таких як шрифти, стилі, скрипти, зображення тощо. Використання цього методу дозволяє покращити швидкість завантаження сторінки, тому що браузер починає завантаження ресурсів ще до того, як вони будуть потрібні для відображення.`,
          },
          {
            code: false,
            label: 'prefetch',
            description: `Цей метод використовується для попереднього завантаження ресурсів, які будуть потрібні в майбутньому. Наприклад, якщо на сторінці є посилання на іншу сторінку, то можна використовувати prefetch, щоб попередньо завантажити цю сторінку та покращити її швидкість завантаження.`,
          },
          {
            code: false,
            label: 'preconnect',
            description: `Цей метод використовується для попередньої настройки з'єднання з сервером, який має надавати ресурси, щоб зменшити затримки. Наприклад, якщо на сторінці використовується сторонній шрифт або скрипт, можна використовувати preconnect, щоб підготувати з'єднання з сервером, який надаватиме ці ресурси, ще до того, як вони будуть потрібні.`,
          },
          {
            code: false,
            label: 'prerender',
            description: `Цей метод використовується для попереднього рендерингу сторінки, що дозволяє покращити її швидкість завантаження.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Навіщо потрібен патерн PRPL?',
        descriptions: [
          {
            code: false,
            label: 'Навіщо потрібен патерн PRPL?',
            description: `PRPL (Push, Render, Pre-cache, Lazy-load) - це паттерн проектування, який допомагає забезпечити швидке завантаження веб-сторінок на мобільних пристроях. Він може бути особливо корисним для веб-додатків з великою кількістю коду та ресурсів, які потрібно завантажувати.

Основна ідея PRPL полягає в тому, щоб завантажувати сторінки якомога швидше та ефективніше. Завдяки PRPL можна використовувати попереднє завантаження, передварительне кешування та ліниве завантаження, щоб зменшити час завантаження сторінки та зменшити кількість запитів до сервера.

Патерн PRPL може бути особливо корисним для веб-додатків на мобільних пристроях, оскільки швидкість та ефективність завантаження сторінок на цих пристроях може бути обмеженою. Принцип PRPL допомагає забезпечити оптимальне використання ресурсів та мінімізувати час завантаження сторінок, що поліпшує користувацький досвід та забезпечує більш високу конверсію.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Web API',
    questions: [
      {
        id: generateUUID(),
        question: 'Що таке HTTP?',
        descriptions: [
          {
            code: false,
            label: 'Що таке HTTP?',
            description: `HTTP означає "Протокол передачі гіпертексту" (англ. "Hypertext Transfer Protocol"). Це стандартний протокол, який використовується для передачі даних в Інтернеті. В основному він використовується для передачі веб-сторінок з веб-сервера на веб-браузер. HTTP використовується для запитів на отримання ресурсів (таких як HTML-сторінки, зображення, відео) з сервера та для передачі даних від користувача до сервера (наприклад, при заповненні форми на веб-сторінці).`,
          },
          {
            code: false,
            label: '',
            description: `HTTP є протоколом передачі даних в Інтернеті, що базується на клієнт-серверній архітектурі. Клієнт (наприклад, веб-браузер) надсилає запит на сервер, який потім відповідає на запит, передаючи необхідну інформацію клієнту.
              HTTP використовується для передачі різних типів даних, таких як HTML-сторінки, зображення, відео, аудіо, CSS-стилі, JavaScript-скрипти, тощо. Для передачі даних використовуються різні методи, зокрема GET, POST, PUT, DELETE, PATCH, які визначають тип запиту та дії, які необхідно виконати на сервері.
              HTTP має певну структуру запиту та відповіді, яка включає заголовки (headers) та тіло (body) повідомлення. У заголовках вказуються метадані про запит або відповідь, такі як тип даних, розмір, кодування тощо. Тіло повідомлення містить основну інформацію, яка передається в запиті або відповіді.
              У заголовках запиту також можуть бути вказані різні параметри, наприклад, заголовок "User-Agent" містить інформацію про веб-браузер або інший клієнтський програмний продукт, який здійснює запит. Це дозволяє серверу адаптувати відповідь до конкретного клієнта.
              Заголовки також можуть включати інформацію про авторизацію, кешування, кодування, мову тощо. Для забезпечення безпеки передачі даних можуть використовуватися різні методи шифрування, такі як TLS/SSL.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'З чого будується HTTP-запит?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `HTTP-запит будується з трьох основних частин: рядка запиту (request line), заголовків запиту (request headers) та тіла запиту (request body).`,
          },
          {
            code: false,
            label: '',
            description: `1. Рядок запиту містить метод запиту, шлях до ресурсу та версію протоколу, наприклад:`,
          },
          {
            code: true,
            label: '',
            description: `GET /index.html HTTP/1.1`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод запиту - GET, шлях до ресурсу - /index.html, а версія протоколу - HTTP/1.1.`,
          },
          {
            code: false,
            label: '',
            description: `2. Заголовки запиту містять додаткову інформацію про запит, таку як тип даних, кодування, мову, кешування, авторизацію тощо. Заголовки вказуються після рядка запиту та розділяються переносом рядка. Приклад заголовків запиту:`,
          },
          {
            code: true,
            label: '',
            description: `
            Host: www.example.com
            User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36
            Accept-Language: en-US,en;q=0.9
            `,
          },
          {
            code: false,
            label: '',
            description: `3. Тіло запиту містить додаткові дані, які надсилаються разом з запитом. Наприклад, у випадку відправлення форми на веб-сторінці, тіло запиту міститиме дані, які були введені користувачем. У деяких випадках запит може не містити тіла, тоді ця частина буде відсутня. Якщо тіло запиту присутнє, то воно повинно розділюватись від заголовків порожнім рядком.`,
          },
          {
            code: true,
            label: '',
            description: `
              POST /submit-form.php HTTP/1.1
              Host: www.example.com
              Content-Type: application/x-www-form-urlencoded
              Content-Length: 23
              
              username=johndoe&password=12345
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод запиту - POST, шлях до ресурсу - /submit-form.php, версія протоколу - HTTP/1.1. Заголовки запиту вказують тип даних (application/x-www-form-urlencoded) та розмір тіла запиту (23 байти). Тіло запиту містить дані, введені користувачем на формі (username=johndoe&password=12345).`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які методи може мати HTTP-запит?',
        descriptions: [
          {
            code: false,
            label: 'Які методи може мати HTTP-запит?',
            description: `HTTP-протокол має кілька методів запиту, які використовуються для взаємодії з сервером. Основні методи HTTP-запитів:`,
          },
          {
            code: false,
            label: '1. GET - запит на отримання ресурсу за вказаною адресою.',
            description: `Метод GET використовується для запиту ресурсу з сервера. Він не змінює стану сервера і повертає лише дані, які були запитані. Оскільки метод GET не змінює стану сервера, він може бути безпечно кешований.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використовувати метод GET, передавши його як параметр у другому об'єкті параметрів запиту. Як правило, метод GET не має тіла запиту, оскільки дані не надсилаються на сервер. Ось приклад використання методу GET:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource?id=12345', {
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json'
                }
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));            
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод GET для запиту ресурсу з сервера з ідентифікатором "12345". За допомогою параметрів запиту, ми передаємо ідентифікатор у URL-адресі. Заголовок "Content-Type" встановлений на "application/json", але це не є обов'язковим для методу GET, оскільки ми не надсилаємо дані на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `Після виконання запиту сервер повинен повернути відповідь з даними запитаного ресурсу. Інформацію про ресурс можна отримати з об'єкту Response, який повертається з fetch().`,
          },
          {
            code: false,
            label: '2. POST - відправлення даних на сервер для обробки.',
            description: `Метод POST використовується для створення нового ресурсу на сервері або відправки даних на сервер для обробки. У відміну від методу PUT, який оновлює існуючий ресурс, метод POST завжди створює новий ресурс на сервері.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використовувати метод POST, передавши його як параметр у другому об'єкті параметрів запиту. Дані, які необхідно відправити на сервер, повинні бути передані у тілі запиту. Ось приклад використання методу POST:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  name: 'New Resource Name',
                  description: 'New Resource Description'
                })
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод POST для створення нового ресурсу на сервері. Також ми встановлюємо заголовок "Content-Type" на "application/json", щоб вказати, що дані, які ми надсилаємо, є об'єктом JSON. Тіло запиту містить об'єкт з даними нового ресурсу.`,
          },
          {
            code: false,
            label: '',
            description: `Після того, як сервер успішно створить новий ресурс, він повинен повернути відповідь з інформацією про створений ресурс, наприклад, з його ідентифікатором або посиланням на ресурс. Відповідь може бути отримана з об'єкту Response, який повертається з fetch().`,
          },
          {
            code: false,
            label: '3. PUT - оновлення ресурсу на сервері за вказаною адресою.',
            description: `Метод PUT використовується для заміни або оновлення ресурсу на сервері. Він відрізняється від методу POST тим, що він не тільки додає новий ресурс, але також оновлює існуючий ресурс на сервері. Цей метод може бути корисним, коли потрібно змінити деякі дані, які вже є на сервері, але які було надіслано раніше.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використати метод PUT, передавши його як параметр у другому об'єкті параметрів запиту. Також потрібно передати дані, які потрібно замінити на сервері, у тілі запиту. Ось приклад використання методу PUT:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource/1', {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  name: 'New Resource Name',
                  description: 'New Resource Description'
                })
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод PUT для заміни даних ресурсу з ідентифікатором "1". Також ми встановлюємо заголовок "Content-Type" на "application/json", щоб вказати, що дані, які ми надсилаємо, є об'єктом JSON. Тіло запиту містить об'єкт з оновленими даними для ресурсу.`,
          },
          {
            code: false,
            label: '',
            description: `Як і в інших методах, сервер повинен повернути відповідь на запит методу PUT, щоб підтвердити, що дані були збережені на сервері.`,
          },
          {
            code: false,
            label:
              '4. DELETE - видалення ресурсу на сервері за вказаною адресою.',
            description: `Mетод DELETE використовується для видалення ресурсу на сервері. Використовуйте метод fetch() з параметром method: 'DELETE', щоб виконати DELETE-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts/1', {
                method: 'DELETE',
              })
              .then(response => {
                console.log('Resource deleted successfully');
              })
              .catch(error => console.error(error));                    
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод DELETE для видалення ресурсу на сервері, за адресою https://example.com/posts/1. У відповідь на запит сервер може повернути статусний код 204 No Content, що означає успішне видалення ресурсу. В нашому випадку ми виводимо повідомлення про успішне видалення ресурсу в консоль. Якщо виникне помилка, ми виводимо повідомлення про помилку в консоль, використовуючи метод console.error().`,
          },
          {
            code: false,
            label:
              '5. HEAD - запит на отримання заголовків відповіді, але без тіла відповіді.',
            description: `Метод HEAD використовується для отримання заголовків відповіді на запит без тіла відповіді. Він корисний, коли ви хочете отримати лише інформацію про ресурс, таку як тип MIME, без отримання всього вмісту ресурсу. Використовуйте метод fetch() з параметром method: 'HEAD', щоб виконати HEAD-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts/1', {
                method: 'HEAD',
              })
              .then(response => {
                console.log(response.headers.get('Content-Type'));
              })
              .catch(error => console.error(error));
                               
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми відправляємо HEAD-запит на URL https://example.com/posts/1. У відповідь на запит сервер поверне лише заголовки відповіді, але не тіло відповіді. Ми використовуємо метод headers.get('Content-Type') для отримання типу MIME відповіді і виводимо його у консолі. У випадку помилки ми виводимо повідомлення про помилку в консолі, використовуючи метод console.error().`,
          },
          {
            code: false,
            label:
              '6. OPTIONS - запит на отримання інформації про можливості сервера для обробки запитів.',
            description: `Метод OPTIONS використовується для отримання інформації про можливі методи HTTP, які підтримуються для конкретного ресурсу на сервері. Використовуйте метод fetch() з параметром method: 'OPTIONS', щоб виконати OPTIONS-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts', {
                method: 'OPTIONS',
              })
              .then(response => {
                console.log(response.headers.get('Allow'));
              })
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми відправляємо OPTIONS-запит на URL https://example.com/posts. У відповідь на запит сервер поверне заголовок Allow, який містить перелік методів HTTP, що підтримуються для даного ресурсу на сервері. Ми використовуємо метод headers.get('Allow') для отримання переліку методів і виводимо їх у консолі. У випадку помилки ми виводимо повідомлення про помилку в консолі, використовуючи метод console.error().`,
          },
          {
            code: false,
            label: `7. CONNECT - встановлення мережевого з'єднання з сервером.`,
            description: `Метод CONNECT використовується для встановлення мережевого з'єднання між клієнтом і сервером за допомогою протоколу TLS/SSL. Використовується в основному для забезпечення безпеки і шифрування даних, переданих між клієнтом і сервером. Зазвичай він використовується для з'єднання з проксі-серверами.`,
          },
          {
            code: false,
            label: '',
            description: `Оскільки цей метод використовується переважно для внутрішньої мережевої комунікації, він рідко використовується у клієнтських додатках. Використання методу CONNECT зазвичай приховане від користувача, а з'єднання установлюється автоматично через проксі-сервери.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, в більшості випадків ви не повинні використовувати метод CONNECT у своїх програмах, якщо ви не створюєте програми, пов'язані з безпекою мережі.
              Якщо ви все ж хочете спробувати виконати запит з методом CONNECT у fetch(), ви можете використати код, подібний до наступного:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com', {
                method: 'CONNECT',
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));            
            `,
          },
          {
            code: false,
            label: '',
            description: `Однак, ймовірно, у вас виникнуть проблеми з автентифікацією на сервері, тому я раджу використовувати цей метод тільки в тому випадку, якщо ви знаєте, що він дійсно необхідний у вашому конкретному випадку.`,
          },
          {
            code: false,
            label:
              '8. TRACE - запит на отримання поверхневої інформації про те, як сервер обробляє запит.',
            description: `Метод TRACE використовується для діагностики мережевих проблем. Він дозволяє клієнту отримати зворотню інформацію від сервера про кожен крок, що відбувається з запитом, відправленим до сервера.`,
          },
          {
            code: false,
            label: '',
            description: `Під час використання методу TRACE, клієнтський запит повторюється на сервері, а сервер відповідає з повідомленням, яке містить всю інформацію про запит. Це може бути корисним для діагностики проблем з мережевим з'єднанням, розуміння того, як сервер обробляє запити та відповідає на них, а також для перевірки того, чи змінювалися дані запиту під час пересилання по мережі.`,
          },
          {
            code: false,
            label: '',
            description: `Якщо ви хочете використати метод TRACE у fetch(), ви можете використати наступний код:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com', {
                method: 'TRACE',
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `Але, як і в разі методу CONNECT, я раджу використовувати цей метод тільки в діагностичних цілях та якщо ви знаєте, що він дійсно необхідний у вашому конкретному випадку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке HTTP cookie? Для чого їх використовують?',
        descriptions: [
          {
            code: false,
            label: 'Що таке HTTP cookie?',
            description: `HTTP cookie - це невеликий фрагмент даних, який веб-сайт зберігає на комп'ютері користувача. Вони зазвичай використовуються для зберігання інформації про користувача та його перевірці при наступних відвідуваннях веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Коли користувач відвідує веб-сайт, сервер може відправити HTTP-відповідь з заголовком Set-Cookie. Цей заголовок містить інформацію про кукі, який повинен зберігатися на комп'ютері користувача. Коли користувач повертається на веб-сайт, його браузер надсилає HTTP-запит зі всіма кукі, які зберігаються на його комп'ютері. Сервер може використовувати ці кукі для ідентифікації користувача та надання персоналізованого досвіду використання.`,
          },
          {
            code: false,
            label: 'Для чого їх використовують?',
            description: `Кукі використовуються для різних цілей, таких як зберігання налаштувань користувача, ідентифікації користувача, зберігання товарів у кошику покупок та відстеження діяльності користувача на веб-сайті. Наприклад, коли користувач здійснює покупку в інтернет-магазині, його кукі можуть зберігати інформацію про товари в кошику покупок, щоб зберегти вибір користувача після перезавантаження сторінки. Кукі також можуть використовуватися для зберігання інформації про вхід в систему користувача, щоб він не потребував вводити дані вхідної форми при кожному відвідуванні веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Хоча кукі зазвичай не є шкідливими, вони можуть становити ризик для приватності користувача, оскільки вони можуть містити особисту інформацію про користувача.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке WebSocket? У чому принцип його роботи?',
        descriptions: [
          {
            code: false,
            label: 'Що таке WebSocket?',
            description: `WebSocket - це технологія, що дозволяє встановлювати двостороннє з'єднання між клієнтом та сервером через один TCP-з'єднання. WebSocket було розроблено з метою зменшення затримок при обміні даними між клієнтом та сервером та для зменшення навантаження на сервер.`,
          },
          {
            code: false,
            label: 'У чому принцип його роботи?',
            description: `Принцип роботи WebSocket полягає в тому, що спочатку клієнт та сервер встановлюють зв'язок через стандартний HTTP-запит. Після цього сервер відповідає з заголовком "Upgrade: WebSocket", який означає, що зв'язок був успішно оновлений до WebSocket.`,
          },
          {
            code: false,
            label: '',
            description: `Після встановлення з'єднання WebSocket клієнт та сервер можуть відправляти додаткові повідомлення один одному без необхідності повторного встановлення з'єднання. Кожне повідомлення має заголовок, що дозволяє ідентифікувати його тип.`,
          },
          {
            code: false,
            label: '',
            description: `WebSocket може бути використаний для багатьох різних завдань, наприклад, для розробки онлайн-ігор, чатів, відео-стрімінгу тощо. В порівнянні з іншими технологіями, WebSocket забезпечує більш ефективний обмін даними між клієнтом та сервером, зменшує навантаження на сервер та забезпечує більш швидку реакцію на події.`,
          },
          {
            code: false,
            label: 'Як встановлюється звязок через HTTP-запит?',
            description: `Зв'язок між клієнтом та сервером зазвичай встановлюється за допомогою стандартного HTTP-запиту типу GET або POST. Клієнт ініціює зв'язок, надсилаючи запит на сервер за певним URL-адресом. Запит містить заголовки, які містять інформацію про запит та можуть включати додаткові параметри.`,
          },
          {
            code: false,
            label: '',
            description: `Сервер, отримавши запит, оброблює його та надсилає відповідь клієнту. Відповідь також містить заголовки, які містять інформацію про відповідь та можуть включати додаткові параметри, такі як кешування або інформація про тип даних, що повертаються.`,
          },
          {
            code: false,
            label: '',
            description: `Якщо під час обробки запиту клієнт та сервер погоджуються використовувати протокол WebSocket, то після відправлення сервером заголовку "Upgrade: WebSocket" з'єднання між клієнтом та сервером переходить у режим WebSocket. З цього моменту клієнт та сервер можуть відправляти повідомлення один одному без необхідності повторного встановлення з'єднання через HTTP-запит.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між HTTP та HTTPS?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між HTTP та HTTPS?',
            description: `Основна різниця між HTTP та HTTPS полягає в тому, що HTTP є протоколом передачі даних через Інтернет у відкритому вигляді, тоді як HTTPS - це захищений протокол передачі даних, який використовує шифрування для забезпечення безпеки даних.`,
          },
          {
            code: false,
            label: '',
            description: `HTTP передає дані відкрито, тому будь-яка інформація, надіслана через HTTP-запит, може бути перехоплена та переглянута ким завгодно. З цієї причини передача конфіденційних даних, таких як логіни та паролі, через HTTP є небезпечною.`,
          },
          {
            code: false,
            label: '',
            description: `HTTPS використовує протокол TLS (Transport Layer Security) або SSL (Secure Sockets Layer), щоб зашифрувати дані, надіслані через Інтернет, що забезпечує більш високий рівень безпеки. Коли веб-браузер отримує відповідь від сервера по HTTPS, то спочатку відбувається процес обміну сертифікатами для підтвердження автентичності сервера, після чого весь трафік між браузером та сервером шифрується.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Long-Polling, Websockets та Server-Sent Events',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Long-Polling, Websockets та Server-Sent Events (SSE) є різними підходами до реалізації двостороннього зв'язку між клієнтом та сервером у веб-додатках.`,
          },
          {
            code: false,
            label: 'Long-Polling',
            description: `Long-Polling використовує запити HTTP, але затримує відповідь сервера на певний час. Коли сервер готовий надіслати відповідь, він повертає її клієнту, після чого клієнт відправляє новий запит. Цей процес повторюється багато разів, щоб створити враження миттєвої взаємодії між клієнтом та сервером.`,
          },
          {
            code: false,
            label: 'Websockets',
            description: `Websockets, з іншого боку, створюють постійне двостороннє з'єднання між клієнтом та сервером через протокол WebSocket. Це дозволяє серверу відправляти повідомлення клієнту, коли вони готові, без очікування запитів від клієнта. Це забезпечує швидку і миттєву взаємодію між клієнтом та сервером, а також значно зменшує кількість запитів, необхідних для обміну даними.`,
          },
          {
            code: false,
            label: 'Server-Sent Events (SSE)',
            description: `Server-Sent Events (SSE) також дозволяють серверу відправляти повідомлення клієнту, але вони використовуються лише для відправки даних від сервера до клієнта. Клієнт може підписатися на потік повідомлень від сервера і приймати їх безпосередньо у своєму браузері. SSE часто використовуються для відображення живих оновлень даних, таких як новини, ігрові події, цінові зміни тощо.`,
          },
          {
            code: false,
            label: '',
            description: `Узагальнюючи, Long-Polling є більш простим, але менш ефективним підходом до забезпечення двостороннього зв'язку між клієнтом та сервером, тоді як Websockets та SSE надають більш ефективні та потужні засоби для цього`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між PUT- і POST-запитами?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між PUT- і POST-запитами?',
            description: `PUT і POST є двома типами HTTP-запитів, які використовуються для відправки даних на сервер. Основною різницею між ними є те, як вони взаємодіють з ресурсами на сервері.`,
          },
          {
            code: false,
            label: '',
            description: `PUT-запит використовується для зміни існуючих даних на сервері. Цей запит вимагає, щоб вказаний ресурс на сервері був замінений вказаними даними. Якщо ресурс відсутній, то він буде створений.`,
          },
          {
            code: false,
            label: '',
            description: `POST-запит, з іншого боку, використовується для відправки нових даних на сервер. Він використовується, коли потрібно створити новий ресурс на сервері або відправити дані на сервер для подальшої обробки. Крім того, POST-запит може використовуватись для оновлення даних на сервері, якщо це потрібно.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, основна різниця між PUT- і POST-запитами полягає в тому, що PUT-запит використовується для зміни існуючих даних, тоді як POST-запит використовується для відправки нових даних на сервер.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке безпечні (Secure) та HttpOnly cookies?',
        descriptions: [
          {
            code: false,
            label: 'Що таке безпечні (Secure) та HttpOnly cookies?',
            description: `Безпечні (Secure) та HttpOnly cookies - це два різні атрибути, які можна встановлювати для HTTP cookies для забезпечення додаткової безпеки.`,
          },
          {
            code: false,
            label: '',
            description: `Атрибут "Secure" вказує на те, що cookie можна використовувати тільки в тому випадку, якщо використовується безпечний протокол зв'язку HTTPS. Якщо веб-сайт використовує HTTPS, то при встановленні cookie встановлюється атрибут "Secure", що дозволяє браузеру передавати cookie тільки через зашифрований канал, а не через незахищені HTTP-запити.`,
          },
          {
            code: false,
            label: '',
            description: `Атрибут "HttpOnly" вказує на те, що cookie не може бути доступний з JavaScript. Це дозволяє захистити cookie від Cross-Site Scripting (XSS) атак, де зловмисник може використовувати JavaScript для отримання доступу до cookie та отримання конфіденційної інформації. Якщо встановлений атрибут "HttpOnly", то веб-програмісти не можуть отримувати доступ до cookie через JavaScript, що дозволяє зменшити ризик XSS-атак.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, використання атрибутів "Secure" та "HttpOnly" є додатковими заходами безпеки для HTTP cookies, які допомагають захистити конфіденційну інформацію користувачів від атак зловмисників.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Content Security Policy (CSP)?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Content Security Policy (CSP)?',
            description: `Content Security Policy (CSP) - це механізм безпеки, що дозволяє зменшити ризик атак на веб-додатки, зокрема на XSS (Cross-Site Scripting) атаки. CSP дає можливість вказати браузеру, які джерела контенту дозволені для завантаження на сторінці, що зменшує можливість виконання зловмисного коду на сторінці в разі, якщо він завантажується з небезпечного джерела.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою CSP можна вказати джерела контенту для різних видів ресурсів, таких як скрипти, стилі, медіа-файли, шрифти, фрейми, AJAX-запити та інші. Також можна налаштувати відправку звіту про спробу завантаження контенту з небезпечних джерел, що дозволяє виявляти та усувати можливі проблеми безпеки.`,
          },
          {
            code: false,
            label: '',
            description: `Приклад вказання CSP на веб-сторінці може виглядати так:`,
          },
          {
            code: true,
            label: '',
            description: `Content-Security-Policy: default-src 'self' https://trusted.com; script-src 'self' 'unsafe-inline' https://trusted.com https://ajax.googleapis.com; style-src 'self' 'unsafe-inline' https://trusted.com; img-src 'self' data: https://trusted.com; font-src 'self' https://fonts.gstatic.com; object-src 'none'; frame-ancestors 'none'; base-uri 'self'; report-uri /csp-report`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми вказуємо, що контент може завантажуватись з поточного джерела ('self'), з довірених джерел (https://trusted.com) для всіх типів контенту, окрім object-src, де ми вказуємо none, щоб заборонити завантаження об'єктів. Крім того, ми вказуємо джерела для кожного типу контенту окремо: для скриптів (script-src) - 'self', 'unsafe-inline', https://trusted.com, https://ajax.googleapis.com; для стилів (style-src) - 'self', 'unsafe-inline', https://trusted.com; для зображень (img-src) - 'self', data:, https://trusted.com. `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'XML',
        descriptions: [
          {
            code: false,
            label: 'XML',
            description: `XML (Extensible Markup Language) - це розширюваний мовний формат, який використовується для зберігання та обміну даними між різними системами. XML є текстовим форматом, що описує дані за допомогою тегів та атрибутів, подібно до HTML. Однак, на відміну від HTML, XML не визначає передбачуваний набір тегів, що дає можливість використовувати його для будь-яких типів даних.`,
          },
          {
            code: false,
            label: '',
            description: `в XML немає заздалегідь визначеного списку тегів, як у HTML. В HTML ви знаєте, що теги, такі як <div>, <p>, <img> і т.д., мають визначене призначення та семантику, і їх застосовують у відповідних випадках. Однак, в XML ви можете створювати власні теги з будь-яким ім'ям і використовувати їх для опису будь-якого типу даних, що дає більшу гнучкість та можливість створення власних мов опису даних. Таким чином, XML набагато більш гнучкий та універсальний, ніж HTML.`,
          },
          {
            code: false,
            label: '',
            description: `XML є стандартом, який можна використовувати у багатьох галузях, включаючи веб-розробку, обробку даних, наукові дослідження, фінанси та багато іншого. XML дозволяє описувати будь-який тип структурованих даних, що робить його потужним інструментом для обміну даними між різними системами та застосунками.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'AJAX',
        descriptions: [
          {
            code: false,
            label: 'AJAX',
            description: `AJAX (Asynchronous JavaScript and XML) - це технологія, яка дозволяє веб-сторінкам взаємодіяти з сервером без перезавантаження сторінки. Завдяки AJAX можна отримувати та відправляти дані на сервер без необхідності в повній перезагрузці сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `AJAX забезпечує асинхронну взаємодію між веб-сторінкою та сервером за допомогою JavaScript-запитів, що виконуються під час роботи сторінки. Це дозволяє завантажувати частини веб-сторінки без повної перезагрузки, що підвищує її продуктивність та зручність використання.`,
          },
          {
            code: false,
            label: '',
            description: `У сучасних веб-додатках AJAX зазвичай використовується для побудови динамічного інтерфейсу, отримання та відображення даних у режимі реального часу, валідації форм, перевірки доступності служб та багатьох інших сценаріїв.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CORS?',
        descriptions: [
          {
            code: false,
            label: 'CORS',
            description: `CORS (Cross-Origin Resource Sharing) - це механізм безпеки браузера, який дозволяє веб-сторінкам запитувати ресурси з інших доменів і серверів. При цьому, браузер перевіряє, чи дозволяє сервер, з якого запитується ресурс, отримувати запити з домену, з якого робиться запит.`,
          },
          {
            code: false,
            label: '',
            description: `Це зроблено для запобігання зловживанням з боку зловмисників, які можуть використовувати код на стороні клієнта для здійснення атак на інші сайти. За допомогою CORS можна дозволити або заборонити запити з конкретних доменів до веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Для налаштування CORS на сервері зазвичай використовують заголовки HTTP, наприклад, Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers тощо.`,
          },
          {
            code: true,
            label:
              'Ось приклад коду, який додає заголовки CORS до відповіді сервера:',
            description: `
              const express = require('express');
              const app = express();
              
              // Додавання заголовків CORS до відповіді сервера
              app.use(function(req, res, next) {
                res.header('Access-Control-Allow-Origin', '*');
                res.header('Access-Control-Allow-Methods', 'GET, PUT, POST, DELETE');
                res.header('Access-Control-Allow-Headers', 'Content-Type');
                next();
              });
              
              // Маршрутизація запитів
              app.get('/', function(req, res) {
                res.send('Привіт з сервера!');
              });
              
              // Запуск сервера
              app.listen(3000, function() {
                console.log('Сервер запущено на порту 3000!');
              });
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому коді ми використовуємо Express.js для створення сервера і додаємо функцію middleware для додавання заголовків CORS до відповіді сервера. Конкретно, ми додаємо заголовок Access-Control-Allow-Origin зі значенням * (дозволяє запити з будь-якого джерела), заголовок Access-Control-Allow-Methods зі значенням дозволених методів (GET, PUT, POST, DELETE) та заголовок Access-Control-Allow-Headers зі значенням дозволених заголовків запиту. Це дозволяє браузеру клієнта виконувати запити до нашого сервера з будь-якого джерела.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між протоколами TCP і UDP?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між протоколами TCP і UDP?',
            description: `TCP (Transmission Control Protocol) і UDP (User Datagram Protocol) - це два основних протоколи мережевого рівня, які використовуються для передачі даних між пристроями в мережі.`,
          },
          {
            code: false,
            label: '',
            description: `Основна різниця між цими протоколами полягає в тому, як вони гарантують доставку даних.`,
          },
          {
            code: false,
            label: '',
            description: `TCP забезпечує забезпечує точну передачу даних, які надходять у вигляді послідовних пакетів. Він використовує механізми підтвердження прийому даних та повторної передачі в разі втрати даних. TCP також контролює потік даних, щоб уникнути перевантаження мережі.`,
          },
          {
            code: false,
            label: '',
            description: `UDP надає меншу гарантію щодо доставки даних, він не передбачає підтвердження прийому даних та повторної передачі в разі втрати даних. Він просто відправляє пакети даних і не контролює їх потік.`,
          },
          {
            code: false,
            label: '',
            description: `Це робить UDP більш швидким за TCP, але менш надійним у тих випадках, коли надійність передачі даних є критично важливою, наприклад, при передачі відео або голосових даних.`,
          },
          {
            code: false,
            label: '',
            description: `Узагалі, TCP використовується для передачі великих обсягів даних, коли точність та надійність передачі даних є важливими, тоді як UDP використовується для швидкої передачі невеликих обсягів даних.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Service Workers?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Service Workers?',
            description: `Service Workers - це скрипти JavaScript, які запускаються в окремому фоновому процесі в браузері і дають можливість розробникам керувати кешуванням, мережевим запитом і поведінкою вашої веб-сторінки під час офлайн взаємодії з користувачем.`,
          },
          {
            code: false,
            label: '',
            description: `Service Workers можуть працювати на задньому плані, незалежно від вашого веб-застосунку, і мають доступ до певного API браузера, який дозволяє їм керувати кешуванням, мережевим запитом і поведінкою вашої веб-сторінки. Вони також можуть використовуватись для реалізації пуш-повідомлень і для покращення швидкості роботи веб-застосунку.`,
          },
          {
            code: false,
            label: '',
            description: `Service Workers працюють в контексті домену, з якого вони були зареєстровані, і вони можуть працювати тільки з HTTPS-з'єднаннями, щоб забезпечити безпеку користувачів. Це означає, що Service Workers можуть бути використані лише на живих веб-сайтах, а не на локальному комп'ютері.`,
          },
          {
            code: false,
            label: '',
            description: `Нижче наведено приклад налаштування Service Worker у ReactJS.`,
          },
          {
            code: true,
            label:
              '1. Створіть файл serviceWorker.js в корені вашого проекту. У цьому файлі ви можете зареєструвати Service Worker, визначити, які ресурси повинні бути кешовані, і які події повинні бути перехоплені.',
            description: `
            // serviceWorker.js

            const CACHE_NAME = 'my-cache';
            
            self.addEventListener('install', (event) => {
              console.log('Service Worker: Installing....');
              event.waitUntil(
                caches.open(CACHE_NAME)
                  .then((cache) => {
                    console.log('Service Worker: Caching app shell');
                    return cache.addAll([
                      '/',
                      '/index.html',
                      '/static/js/bundle.js',
                      '/static/css/main.css'
                    ]);
                  })
              );
            });
            
            self.addEventListener('fetch', (event) => {
              console.log('Service Worker: Fetching....');
              event.respondWith(
                caches.match(event.request)
                  .then((response) => {
                    if (response) {
                      console.log('Service Worker: Serving from cache');
                      return response;
                    }
                    console.log('Service Worker: Fetching from server');
                    return fetch(event.request);
                  })
              );
            });
            `,
          },
          {
            code: true,
            label: '2. Імпортуйте Service Worker у вашому компоненті index.js.',
            description: `
            // index.js

            import React from 'react';
            import ReactDOM from 'react-dom';
            import App from './App';
            import * as serviceWorker from './serviceWorker';
            
            ReactDOM.render(<App />, document.getElementById('root'));
            
            serviceWorker.register();
            
            `,
          },
          {
            code: true,
            label:
              '3. Додайте файл manifest.json у корінь вашого проекту. У цьому файлі ви можете визначити метадані про ваше додаток, такі як іконка, назва та короткий опис.',
            description: `
            // manifest.json

            {
              "name": "My App",
              "short_name": "My App",
              "icons": [
                {
                  "src": "icon.png",
                  "sizes": "192x192",
                  "type": "image/png"
                },
                {
                  "src": "icon-512.png",
                  "sizes": "512x512",
                  "type": "image/png"
                }
              ],
              "start_url": ".",
              "display": "standalone",
              "theme_color": "#000000",
              "background_color": "#ffffff"
            }

            `,
          },
          {
            code: true,
            label:
              '4. Додайте посилання на ваш файл маніфесту у вашому HTML-файлі.',
            description: `
            <!-- index.html -->

            <head>
              <meta charset="utf-8" />
              <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
              <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
              <title>My App</title>
            </head>

            <body>
              <div id="root"></div>
            </body>

            `,
          },
          {
            code: false,
            label: '',
            description: `Тепер ваш React додаток буде мати можливість працювати офлайн завдяки Service Workers.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Web Worklet?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Web Worklet?',
            description: `Web Worklet - це механізм браузера, що дозволяє виконувати скрипти на ізольованому потоці виконання. Це дозволяє відокремити код від основного потоку виконання і запобігти блокуванню інтерфейсу користувача під час виконання важких обчислень.`,
          },
          {
            code: false,
            label: '',
            description: `Web Worklet був запропонований як альтернатива Web Workers, що відкриває шлях для більш широкого спектру використання. Web Worklet може виконувати код, який взаємодіє зі сторонніми сервісами, відображає візуальні компоненти та інші задачі, які не можна виконувати в Web Workers.`,
          },
          {
            code: false,
            label: '',
            description: `Web Worklet використовує технологію WebAssembly, яка дозволяє виконувати код на мовах програмування, які не підтримуються браузером напряму. Це робить Web Worklet більш гнучким і можливою альтернативою Web Workers для виконання важких завдань в браузері.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке History API в браузері?',
        descriptions: [
          {
            code: false,
            label: 'Що таке History API в браузері?',
            description: `History API - це частина JavaScript-інтерфейсу браузера, яка дозволяє змінювати URL в адресній стрічці без перезавантаження сторінки та зберігати записи про історію переходів на сторінках в браузері. За допомогою History API можна змінювати URL без перезавантаження сторінки, отримувати інформацію про поточний URL та історію переходів на сторінках.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, для того, щоб додати запис в історію переходів на сторінках, можна використати метод pushState і передати йому об'єкт з потрібними даними, як показано у прикладі:`,
          },
          {
            code: true,
            label: '',
            description: `history.pushState({page: 2}, "Назва сторінки", "/сторінка-2");`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод pushState додає запис про новий URL "/сторінка-2" з назвою "Назва сторінки" та об'єктом даних {page: 2} до історії переходів на сторінках в браузері. При цьому сторінка не перезавантажується, а URL змінюється на новий. Для зчитування поточного URL можна використати властивість location.href, а для отримання даних про запис в історії переходів на сторінках - методи history.back() та history.forward().`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'що таке веб-сховище (web storage)?',
        descriptions: [
          {
            code: false,
            label: 'що таке веб-сховище (web storage)?',
            description: `Веб-сховище (web storage) - це механізм зберігання даних на стороні клієнта веб-додатків. Цей механізм дозволяє зберігати дані в локальному сховищі браузера без потреби взаємодії з сервером. Збережені дані доступні для веб-додатків, які вони створені для, і можуть бути використані для різних цілей, таких як збереження налаштувань користувачів, запам'ятовування даних форми, аутентифікації користувача та інших задач.`,
          },
          {
            code: false,
            label: '',
            description: `У веб-сховищі два типи об'єктів для зберігання даних: localStorage та sessionStorage. localStorage зберігає дані, які будуть доступні після закриття браузера, а sessionStorage зберігає дані, які будуть доступні лише в рамках одного сеансу браузера (тобто, поки користувач не закриє вкладку з веб-сайтом). Доступ до даних можна отримати за допомогою JavaScript API. Наприклад, для збереження даних у localStorage використовується такий синтаксис:`,
          },
          {
            code: true,
            label: '',
            description: `localStorage.setItem('ключ', 'значення');`,
          },
          {
            code: false,
            label: '',
            description: `А для отримання значення з localStorage:`,
          },
          {
            code: true,
            label: '',
            description: `const value = localStorage.getItem('ключ');`,
          },
          {
            code: false,
            label: '',
            description: `Дані можна видалити з localStorage за допомогою методу removeItem():`,
          },
          {
            code: true,
            label: '',
            description: `localStorage.removeItem('ключ');`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке sessionStorage?',
        descriptions: [
          {
            code: false,
            label: 'Що таке sessionStorage?',
            description: `sessionStorage - це інтерфейс Web Storage, який зберігає дані в браузері на протязі однієї сесії, яка зберігається між сторінками. Коли користувач закриває вкладку браузера або перезавантажує сторінку, дані знищуються.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою sessionStorage можна зберігати прості рядкові значення, що використовуються в додатку для зберігання даних в проміжку між сторінками. Значення можна отримати за ключем або встановити нове значення за ключем, який буде збережено в поточній сесії.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, можна зберігати обраний елемент у формі, щоб він залишався вибраним при оновленні сторінки. Нижче наведено приклад встановлення і отримання значення за допомогою sessionStorage в JavaScript:`,
          },
          {
            code: true,
            label: '',
            description: `
              // встановлюємо значення для ключа "username"
              sessionStorage.setItem("username", "John");

              // отримуємо значення для ключа "username"
              const username = sessionStorage.getItem("username");
              console.log(username); // виведе "John"
            `,
          },
          {
            code: false,
            label: '',
            description: `Значення, збережені у sessionStorage, будуть доступні на всіх сторінках в поточній сесії, але не будуть доступні на інших вкладках або після закриття браузера.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке BOM?',
        descriptions: [
          {
            code: false,
            label: 'Що таке BOM?',
            description: `BOM означає «Browser Object Model» (Об'єктна модель браузера) і є частиною API браузера. Це колекція об'єктів, що відображають властивості та функції браузера, які можуть використовуватися для маніпулювання вмістом веб-сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `До BOM належать такі об'єкти, як window, navigator, location, history, screen та інші. Ці об'єкти надають розробникам можливість отримувати доступ до різних функціональних можливостей браузера, таких як взаємодія з користувачем, навігація, робота з документами та інше. Наприклад, властивість window.location надає доступ до поточної адреси URL сторінки, а window.alert() викликає діалогове вікно з повідомленням для користувача.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою BOM можна маніпулювати не тільки веб-сторінками, а й самим браузером, таким чином, щоб змінювати розміри та положення вікна браузера, відкривати та закривати нові вкладки тощо. Однак, слід пам'ятати, що використання BOM може стати причиною проблем з кросбраузерною сумісністю, тому розробники повинні звертати на це увагу.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між cookie, sessionStorage та localStorage?',
        descriptions: [
          {
            code: false,
            label: 'cookie, sessionStorage та localStorage',
            description: `У веб-розробці є декілька способів зберігання даних в браузері, серед яких cookie, sessionStorage та localStorage. Ось їхні основні відмінності:`,
          },
          {
            code: false,
            label: '',
            description: `1. Cookie - це невеликі текстові файли, які зберігаються в браузері користувача. Вони зазвичай використовуються для зберігання інформації про користувача або його налаштування, які можуть бути використані на інших сторінках сайту. Куки можуть бути встановлені з сервера або з JavaScript на стороні клієнта.`,
          },
          {
            code: false,
            label: '',
            description: `2. sessionStorage - це механізм зберігання даних в браузері, який дозволяє зберігати дані протягом одного сеансу роботи з сайтом. Дані, збережені у sessionStorage, зникають після закриття вкладки або браузера.`,
          },
          {
            code: false,
            label: '',
            description: `3. localStorage - це механізм зберігання даних в браузері, який дозволяє зберігати дані назавжди або до тих пір, поки користувач не видалить їх вручну або не очистить кеш браузера.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, основна відмінність між цими трьома механізмами зберігання даних полягає в тривалості збереження. Cookie - це найменш потужний з них, оскільки він зберігається тільки на короткий проміжок часу. sessionStorage дозволяє зберігати дані протягом одного сеансу роботи з сайтом, тоді як localStorage дозволяє зберігати дані на невизначений термін.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке REST та RESTful api?',
        descriptions: [
          {
            code: false,
            label: 'REST та RESTful api',
            description: `REST (Representational State Transfer) - це архітектурний стиль для створення мережевих протоколів. RESTful API - це API, яке дотримується принципів REST.`,
          },
          {
            code: false,
            label: '',
            description: `REST побудований на основі HTTP і складається з наступних принципів:`,
          },
          {
            code: false,
            label: '',
            description: `• Кожен ресурс (наприклад, користувач, коментар, замовлення) ідентифікується унікальним URI (Uniform Resource Identifier).`,
          },
          {
            code: false,
            label: '',
            description: `• Клієнт взаємодіє з сервером за допомогою стандартних HTTP-запитів, таких як GET, POST, PUT і DELETE, що відповідають CRUD-операціям (створення, читання, оновлення та видалення).`,
          },
          {
            code: false,
            label: '',
            description: `• Кожен запит містить всю необхідну інформацію для обробки запиту (stateless). Сервер не зберігає стан клієнта між запитами.`,
          },
          {
            code: false,
            label: '',
            description: `• Відповідь сервера повинна бути чіткою і включати в себе достатню інформацію про ресурс, який запитується.`,
          },
          {
            code: false,
            label: '',
            description: `RESTful API повинен дотримуватися цих принципів, а також надати легку для розуміння документацію та демонстраційні приклади взаємодії з API. Взаємодія з RESTful API повинна бути безпечною, ефективною і масштабованою.`,
          },
          {
            code: false,
            label: '',
            description: `Основним способом використання RESTful API в React є використання функцій fetch() або бібліотеки, як от Axios чи jQuery AJAX. Ось приклад використання fetch():`,
          },
          {
            code: true,
            label: '',
            description: `
            import React, { useState, useEffect } from 'react';

            function Example() {
              const [data, setData] = useState(null);
            
              useEffect(() => {
                async function fetchData() {
                  const response = await fetch('/api/data');
                  const jsonData = await response.json();
                  setData(jsonData);
                }
            
                fetchData();
              }, []);
            
              if (!data) {
                return <div>Loading...</div>;
              }
            
              return (
                <div>
                  <h1>{data.title}</h1>
                  <p>{data.description}</p>
                </div>
              );
            }            
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо функцію fetch() для отримання даних з нашого RESTful API, яке відповідає на запит на /api/data. Після того, як ми отримаємо відповідь, ми перетворюємо її на об'єкт JSON і встановлюємо його як стан компонента за допомогою setData(). Якщо дані ще не завантажилися, ми виводимо повідомлення "Loading...". Якщо ж дані вже отримано, ми відображаємо їх у відповідних елементах.`,
          },
          {
            code: false,
            label: '',
            description: `Це дуже простий приклад, але можна використовувати різні методи HTTP-запитів (GET, POST, PUT, DELETE) для виконання операцій з базою даних. Також можна використовувати параметри запиту, щоб фільтрувати або сортувати дані перед їхнім отриманням.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Triple handshake?',
        descriptions: [
          {
            code: false,
            label: 'Triple handshake',
            description: `Triple handshake - це процес установки з'єднання в протоколі TCP, який передбачає взаємодію клієнта і сервера у трьох етапах.`,
          },
          {
            code: false,
            label: '',
            description: `При встановленні з'єднання клієнт надсилає запит на підключення до сервера, відправляючи пакет з установлюючим флагом (SYN). Сервер отримує запит і відповідає на нього пакетом з флагами SYN та ACK. Клієнт в свою чергу надсилає підтвердження ACK.`,
          },
          {
            code: false,
            label: '',
            description: `Triple handshake відрізняється від двостороннього handshake, де після відправлення запиту на підключення клієнт чекає відповіді від сервера і надсилає підтвердження ACK разом з першими даними, що надсилає на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `riple handshake використовується для забезпечення стабільності з'єднання, оскільки перед відправкою даних клієнт та сервер перевіряють, чи є з'єднання доступним для передачі даних.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Git',
    questions: [
      {
        id: generateUUID(),
        question:
          'Як можна скасувати коміт у Git, якщо він уже був опублікований?',
        descriptions: [
          {
            code: false,
            label:
              'Як можна скасувати коміт у Git, якщо він уже був опублікований?',
            description: `Як варіант, зробивши обернений коміт за допомогою команди git revert [commit SHA]. Це створить коміт, що скасовує зміни зазначеного комміту. Після цього необхідно відправити зміни у віддалений репозиторій за допомогою команди git push [repository]/branch-name. Якщо коміт зроблено на особистій гілці, яка не використовується ніким крім автора, помилковий коміт можна відзначити прапором drop в інтерактивному режимі ребейза (git rebase -i), що повністю видалить зазначений коміт з історії. Після цього необхідно відправити зміни у віддалений репозиторій за допомогою команди git push [repository]/branch-name з прапором force.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'У чому полягає різниця між git pull і git fetch?',
        descriptions: [
          {
            code: false,
            label: 'У чому полягає різниця між git pull і git fetch?',
            description: `Git pull витягує (fetch) дані з сервера і автоматично робить злиття (merge) їх із кодом поточної гілки. Git fetch — зв'язується з віддаленим репозиторієм та отримує дані, які відсутні у локальному. Під час виконання цієї команди злиття не відбувається.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке "staging area" або "index" в Git?',
        descriptions: [
          {
            code: false,
            label: 'Що таке "staging area" або "index" в Git?',
            description: `Staging area (область підготовлених файлів) — файл, який зазвичай розташовується в Git-директорії і містить інформацію про зміни, які потраплять до наступного коміту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'За що відповідає команда Git stash?',
        descriptions: [
          {
            code: false,
            label: 'За що відповідає команда Git stash?',
            description: `Git stash - команда, що зберігає змінений стан робочої директорії або окремого файлу в сховищі незавершених змін. Це дає можливість будь-якої миті застосувати їх назад. Наприклад, якщо потрібно перейти між гілками без фіксації змін, можна застосувати команду git stash, робоча директорія залишиться без змін, дані будуть збережені в спеціальному сховищі. Щоб переглянути заховані зміни, потрібно викликати команду git stash list, а для застосування — git stash apply.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як знайти список файлів, які змінилися у певному коміті?',
        descriptions: [
          {
            code: false,
            label: 'Як знайти список файлів, які змінилися у певному коміті?',
            description: `Це досягається переглядом історії коммітів за допомогою команди git log із застосуванням певних прапорів:`,
          },
          {
            code: false,
            label: '',
            description: `stat - під кожним із коммітів з'явиться список та кількість змінених файлів, кількість рядків, доданих та віддалених у кожному з файлів. Насамкінець, під списком, буде виведено сумарну статистику.`,
          },
          {
            code: false,
            label: '',
            description: `name-status — показує список змінених файлів, видалених.`,
          },
          {
            code: false,
            label: '',
            description: `Для пошуку списку файлів у конкретному коміті можна виконати команду git show і вказати хеш комміта.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'За що відповідає команда "git config"?',
        descriptions: [
          {
            code: false,
            label: 'За що відповідає команда "git config"?',
            description: `Git config — команда, яка дозволяє переглядати та настроювати конфігурацію git репозиторію.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'З чого складається коміт у Git?',
        descriptions: [
          {
            code: false,
            label: 'З чого складається коміт у Git?',
            description: `Коміт — це список, який складається з об'єктів із зміненими файлами та посилання на попередній коміт. Також вказуються імена автора, мітки часу та повідомлення комміту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Как створити Git-репозиторий ?',
        descriptions: [
          {
            code: false,
            label: 'Как створити Git-репозиторий ?',
            description: `Створити Git-репозиторій можна двома шляхами. Перший – версіонування існуючого проекту. Для цього потрібно перейти в папку з проектом та виконати команду git init, що задасть структуру Git-репозиторію. Після базової конфігурації (git config), репозиторія можна буде версіонувати проект.
Другий: клонування віддаленого репозиторію. Для цього потрібно виконати команду git clone [url],
            Де [url] - адреса репозиторію.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як об`єднати кілька окремих коммітів в один цілісний коміт?',
        descriptions: [
          {
            code: false,
            label:
              'Як об`єднати кілька окремих коммітів в один цілісний коміт?',
            description: `Це можна зробити за допомогою перебазування в інтерактивному режимі (rebase). Наприклад, щоб об'єднати, 3 останніх коммита в один, необхідно виконати команду git rebase -i HEAD~3 (3 відповідає числу коммітів, які потрібно об'єднати, відлік від HEAD). Відкриється вікно редактора, в якому перші 3 рядки відповідають останнім трьом комітам:`,
          },
          {
            code: true,
            label: '',
            description: `pick ab37583 Added feature 1.
pick 3ab2b83 Added feature 2.
pick 3ab5683 Added feature 3`,
          },
          {
            code: false,
            label: '',
            description: `На початку кожного рядка стоїть слово "pick". Потрібно змінити його на squash або s, зберегти зміни, закрити редактор, після чого git попросить задати повідомлення нового комміта, що містить зміни трьох вихідних.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'За що відповідає команда Git Bisect? Як її можна використовувати визначення джерела бага (регресії) ?',
        descriptions: [
          {
            code: false,
            label: 'Команда Git Bisect',
            description: `Команда Git bisect виконує бінарний пошук з історії комітів. Якщо невідомо, де знаходиться проблема і було зроблено багато коммітів, можна скористатися командою git bisect, щоб визначити комміт, який викликав проблему. Для цього потрібно виконати команду: git bisect start, потім git bisect bad це вкаже Git комміт, в якому була виявлена проблема. Коміт git bisect good [хеш комміта] вкаже Git комміт у якому проблема не виявляється. Далі Git з'ясує кількість проміжних коммітів та за допомогою бінарного пошуку, пересуваючи покажчик на деякі з проміжних коммітів, допоможе знайти проблемний.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як налаштувати Git-репозиторій',
        descriptions: [
          {
            code: false,
            label:
              'Як налаштувати Git-репозиторій для запуску інструментів перевірки працездатності коду безпосередньо перед виконанням коммітів та запобігання їх у разі збою тесту?',
            description: `За допомогою хука pre-commit. Для цього потрібно визначити конфігураційний файл pre-commit (у папці .git/hooks), код перевірки працездатності внесених змін. Після цього, Git запускатиме вказану перевірку перед кожним коммітом. Якщо перевірка поверне код відмінний від нуля, коміт не буде застосований.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які ви знаєте моделі розгалуження у Git? Опишіть їх.',
        descriptions: [
          {
            code: false,
            label: 'Які ви знаєте моделі розгалуження у Git? Опишіть їх.',
            description: `Однією з найпопулярніших моделей розгалуження Git є git flow. Коротко кажучи, працюючи за цією моделлю в репозиторії повинні бути дві постійні гілки (master, develop) і будь-яка кількість тимчасових гілок (feature-, release-, hotfix-) які вливаються в основні. Порядок підготовки релізів від початку розробки та безпосередньо до здійснення релізу чітко диктується моделлю. Докладніше можна почитати за посиланням.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Яким чином можна встановити чи було злиття гілки в master?',
        descriptions: [
          {
            code: false,
            label: 'Яким чином можна встановити чи було злиття гілки в master?',
            description: `Команда git branch -merged відфільтровує гілки, які були злиті`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке git-rebase і для чого він потрібний?',
        descriptions: [
          {
            code: false,
            label: 'Що таке git-rebase і для чого він потрібний?',
            description: `Команда git rebase (перебазирование) — применяет коммиты текущей ветки после коммитов ветки (base tip), указанной в команде rebase. С помощью rebase можно выполнять целый ряд задач: слияние веток, перемотку (fast forwarding), изменение коммитов текущей ветки (редактирование, именование, удаление, слияние, перетасовка коммитов), пересадку текущей ветки (с помощью опции —onto) и др.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке cherry pick?',
        descriptions: [
          {
            code: false,
            label: 'Що таке cherry pick?',
            description: `git cherry-pick - це корисна команда, за допомогою якої можна вибірково застосувати коміти Git до поточної робочої гілки HEAD. З її допомогою можна вибрати коміт із однієї гілки та застосувати його до іншої. Команда git cherry-pick – це зручний спосіб скасувати зміни.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке git amend?',
        descriptions: [
          {
            code: false,
            label: 'Що таке git amend?',
            description: `Команда git amend використовується для зміни останнього коміту в гілці.`,
          }, {
            code: false,
            label: 'Що таке git amend?',
            description: `Наприклад, якщо ви зробили коміт з помилковим повідомленням, ви можете використовувати команду git commit --amend для зміни повідомлення без створення нового коміту. Для внесення змін до змісту коміту ви можете спочатку внести зміни в файли, а потім виконати команду git add для додавання змінених файлів до стейджування, а потім використовувати git commit --amend для зміни коміту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке git merge --squash?',
        descriptions: [
          {
            code: false,
            label: 'Що таке git merge --squash?',
            description: `Команда git merge --squash дозволяє злити зміни з однієї гілки в іншу, але при цьому не створює злитого коміту з повною історією злиття. Замість цього, команда злиття створює новий коміт зі змінами, які були злиті, але не включає історію злиття або деталі про походження змін.`,
          }, {
            code: false,
            label: '',
            description: `Отже, коли ви використовуєте команду git merge --squash, Git злиття збирає всі зміни з цільової гілки і копіює їх у вашу поточну гілку, але не створює злитого коміту. Потім вам потрібно створити новий коміт за допомогою git commit, в який включаєте всі зміни зі злиття.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'HTML',
    questions: [
      {
        id: generateUUID(),
        question: 'Що таке HTML та для чого його використовують?',
        descriptions: [
          {
            code: false,
            label: `Що таке HTML та для чого його використовують?`,
            description: `HTML (Hypertext Markup Language) - це мова розмітки, що використовується для створення веб-сторінок. За допомогою HTML можна описати структуру сторінки, вказати заголовки, абзаци, зображення, посилання та інші елементи контенту.`,
          },
          {
            code: false,
            label: ``,
            description: `HTML складається з різних тегів, які вказують браузеру, як відображати контент. Наприклад, тег <p> вказує на абзац тексту, тег <img> вказує на зображення, а тег <a> вказує на посилання.`,
          },
          {
            code: false,
            label: ``,
            description: `HTML є основним компонентом веб-сторінок, оскільки він використовується для створення контенту на сторінках, що відображається в браузері. За допомогою HTML можна створювати сайти, бізнес-сторінки, веб-додатки, блоги та інші веб-ресурси.`,
          },
          {
            code: false,
            label: ``,
            description: `Крім того, HTML часто використовується в поєднанні з CSS (Cascading Style Sheets) і JavaScript, щоб створювати інтерактивні та динамічні веб-сторінки з красивим дизайном і відмінними функціональними можливостями.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які глобальні атрибути є у HTML?',
        descriptions: [
          {
            code: false,
            label: `Які глобальні атрибути є у HTML?`,
            description: `У HTML існує декілька глобальних атрибутів, які можуть бути використані з будь-яким елементом:`,
          },
          {
            code: false,
            label: ``,
            description: `1. class - визначає ім'я класу елемента, що дозволяє створювати CSS-стилі для цього елемента.`,
          },
          {
            code: false,
            label: ``,
            description: `2. id - визначає унікальний ідентифікатор елемента.`,
          },
          {
            code: false,
            label: ``,
            description: `3. style - дозволяє встановлювати стилі для елемента без використання CSS-файлу.`,
          },
          {
            code: false,
            label: ``,
            description: `4. title - встановлює заголовок для елемента, який може використовуватися для відображення віджетів допомоги або призначення для скрінрідера.`,
          },
          {
            code: false,
            label: ``,
            description: `5. lang - вказує мову, яка використовується в елементі.`,
          },
          {
            code: false,
            label: ``,
            description: `6. data-* - дозволяє вставляти в елемент додаткові дані, які можуть бути використані для JavaScript і CSS.`,
          },
          {
            code: false,
            label: ``,
            description: `7. dir - вказує напрямок тексту для елемента.`,
          },
          {
            code: false,
            label: ``,
            description: `8. tabindex - вказує порядковий номер елемента в послідовності переходу фокусу.`,
          },
          {
            code: false,
            label: ``,
            description: `Ці глобальні атрибути можуть бути використані з будь-яким елементом в HTML, щоб визначити їхню поведінку та відображення на сторінці. Використання цих атрибутів може полегшити розробку веб-сторінок і підвищити їх доступність для користувачів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке категорії контенту в HTML5?',
        descriptions: [
          {
            code: false,
            label: `Що таке категорії контенту в HTML5?`,
            description: `В HTML5 визначено декілька категорій контенту, які дозволяють відображати різноманітний контент на веб-сторінках. Кожна категорія має свій власний семантичний сенс та дозволяє встановлювати різні атрибути для елементів.`,
          },
          {
            code: false,
            label: ``,
            description: `Основні категорії контенту в HTML5:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Структурні елементи: ці елементи використовуються для визначення структури веб-сторінки, такої як заголовки, меню, футер та інші. До цієї категорії відносяться елементи header, nav, section, article, aside та footer.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Групуючі елементи: ці елементи використовуються для групування контенту в межах веб-сторінки. До цієї категорії відносяться елементи div та span.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Вбудовування контенту: ці елементи використовуються для вбудовування зовнішнього контенту, такого як зображення, відео, аудіо та інші. До цієї категорії відносяться елементи img, video, audio та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Форми та інтерактивні елементи: ці елементи використовуються для створення форм та інших елементів, які дозволяють користувачам взаємодіяти з веб-сторінкою. До цієї категорії відносяться елементи form, input, button, select та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `5. Текстові елементи: ці елементи використовуються для відображення текстового контенту на веб-сторінках. До цієї категорії відносяться елементи p, h1, h2, ul, ol, li та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `6. Мета-інформація: ці елементи використовуються для надання мета-інформації про веб-сторінку, такої як заголовок, мета-теги та інші. До цієї категорії відносяться елементи head, meta,`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які категорії вважаються основними категоріями контенту?',
        descriptions: [
          {
            code: false,
            label: `Які категорії вважаються основними категоріями контенту?`,
            description: `У HTML5 існує сім основних категорій контенту:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Metadata content (метадані) - інформація про сторінку, така як заголовок, опис, автор, ключові слова та інше. Приклади: <title>, <meta>, <link>.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Flow content (потоковий контент) - це найбільш загальна категорія, яка містить звичайний текст, зображення, відео та інші елементи контенту, які можна розміщувати в тілі сторінки. Приклади: <p>, <img>, <video>, <audio>, <a>, <div>, <span>, <h1>, <h2>, <h3>, <h4>, <h5>, <h6>.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Sectioning content (контент секціонування) - це контент, який допомагає організувати сторінку на розділи, що допомагає у покращенні доступності та SEO. Приклади: <section>, <article>, <nav>, <aside>, <header>, <footer>, <main>.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Heading content (заголовки) - це контент, що використовується для позначення заголовків сторінки або розділів сторінки. Приклади: <h1>, <h2>, <h3>, <h4>, <h5>, <h6>.`,
          },
          {
            code: false,
            label: ``,
            description: `5. Phrasing content (фразовий контент) - це контент, який розміщується в межах Flow content та використовується для надання змісту Flow content. Приклади: <strong>, <em>, <mark>, <small>, <big>, <code>, <pre>, <cite>, <abbr>, <br>, <wbr>.`,
          },
          {
            code: false,
            label: ``,
            description: `6. Embedded content (вбудований контент) - це контент, який вбудовується в інший контент, такий як зображення, відео, аудіо, документи та інше. Приклади: <img>, <video>, <audio>, <iframe>, <embed>, <object>.`,
          },
          {
            code: false,
            label: ``,
            description: `7. Interactive content (інтерактивний контент) - це контент, який може бути взаємодійний з користувачем, такий як форми, кнопки, посилання та інше. Приклади: <a>, <button>, <input>, <label>, <select>`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке doctype? І для чого він використовується?',
        descriptions: [
          {
            code: false,
            label: `Що таке doctype? І для чого він використовується?`,
            description: `Doctype (Document Type Declaration) - це інструкція, яка розміщується на початку HTML-документа і вказує на версію HTML, яку слід використовувати для відображення сторінки. Він також допомагає браузеру коректно інтерпретувати HTML-код.`,
          },
          {
            code: false,
            label: ``,
            description: `Doctype дуже важливий, оскільки він допомагає браузеру коректно інтерпретувати HTML-код, а також забезпечує правильне відображення сторінки. Якщо doctype не вказаний або вказаний неправильно, браузер може відображати сторінку неправильно або взагалі не відображати її. Окрім того, doctype дозволяє використовувати сучасні стандарти HTML і CSS для розробки сторінок.`,
          },
          {
            code: true,
            label: ``,
            description: `<!DOCTYPE html>`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Опишіть базову структуру HTML-сторінки?',
        descriptions: [
          {
            code: false,
            label: `Опишіть базову структуру HTML-сторінки?`,
            description: `Основна структура HTML-сторінки містить наступні елементи:`,
          },
          {
            code: false,
            label: ``,
            description: `1. <!DOCTYPE> - тип документу, який використовується на сторінці.`,
          },
          {
            code: false,
            label: ``,
            description: `2. <html> - кореневий елемент сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `3. <head> - контейнер для метаданих сторінки, таких як заголовок, посилання на зовнішні ресурси, мета-теги і т.д.`,
          },
          {
            code: false,
            label: ``,
            description: `4. <meta> - елемент для визначення метаданих сторінки, наприклад, мови, кодування і т.д.`,
          },
          {
            code: false,
            label: ``,
            description: `5. <title> - заголовок сторінки, який відображається в рядку заголовка браузера.`,
          },
          {
            code: false,
            label: ``,
            description: `6. <body> - тіло сторінки, включає в себе контент сторінки, який відображається на веб-сторінці.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, проста HTML-сторінка може мати наступну структуру:`,
          },
          {
            code: true,
            label: ``,
            description: `
            <!DOCTYPE html>
            <html>
              <head>
                <meta charset="UTF-8">
                <title>Моя перша HTML-сторінка</title>
              </head>
              <body>
                <h1>Ласкаво просимо на мою першу HTML-сторінку</h1>
                <p>Це моя перша сторінка, написана на HTML.</p>
              </body>
            </html>            
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі <!DOCTYPE html> визначає тип документу як HTML, <html> є кореневим елементом сторінки, <head> містить метадані, а <body> містить основний контент сторінки, такий як заголовок (<h1>) і абзац (<p>).`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Що таке валідація? І які типи перевірок HTML документа ви знаєте?',
        descriptions: [
          {
            code: false,
            label: `Що таке валідація? І які типи перевірок HTML документа ви знаєте?`,
            description: `Валідація - це процес перевірки правильності форматування даних у веб-формі або на веб-сторінці перед їх відправкою на сервер. Основна мета валідації - запобігти надходження некоректних даних на сервер, що може призвести до помилок в обробці даних та зниження якості роботи веб-сайту.`,
          },
          {
            code: false,
            label: ``,
            description: `Типи перевірок HTML документа:`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка формату введення даних: перевірка правильності введення текстових даних, чисел, дат, електронних адрес, телефонних номерів та інших типів даних.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка обов'язкових полів: перевірка на заповненість обов'язкових полів форми перед відправкою її на сервер.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка розміру даних: перевірка на максимальний та мінімальний розмір даних, що можуть бути введені в поля форми.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на унікальність даних: перевірка на унікальність введених даних, наприклад, перевірка на унікальність електронної адреси користувача або логіну.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на допустимі символи: перевірка на наявність допустимих символів введення даних.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на відповідність шаблону: перевірка на відповідність введених даних визначеному шаблону, наприклад, шаблону для номера кредитної картки.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на права доступу: перевірка на наявність необхідних прав доступу до ресурсів на сервері.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на наявність вірусів: перевірка на наявність вірусів у завантажених на сервер файлах або сторінках.`,
          },
          {
            code: false,
            label: ``,
            description: `Ці перевірки можуть бути виконані як на стороні клієнта, так і на стороні сервера.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Основні етапи перевірок валідності HTML-документа',
        descriptions: [
          {
            label: 'Стадія 1: Парсинг',
            description: `
              Першим етапом перевірки є парсинг HTML-документа, коли браузер аналізує HTML-код і створює з нього структуру DOM-дерева.
              Під час парсингу, браузер може виявити синтаксичні помилки, такі як незакриті теги, неправильно вкладені теги тощо.
            `,
            code: false,
          },
          {
            label: 'Стадія 2: Валідація',
            description: `
              Другим етапом є валідація HTML-коду, що означає перевірку, чи відповідає HTML-документ стандартам W3C.
              Якщо в HTML-документі є помилки, то браузер може відображати його неправильно або навіть ігнорувати деякі елементи.
            `,
            code: false,
          },
          {
            label: 'Приклад коду:',
            description: `
              <!DOCTYPE html>
              <html>
                <head>
                  <meta charset="utf-8">
                  <title>Мій HTML-документ</title>
                </head>
                <body>
                  <h1>Привіт світ!</h1>
                  <p>Це мій перший HTML-документ.</p>
                </body>
              </html>
            `,
            code: true,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Якщо уявити HTML5 як відкриту веб-платформу, з яких блоків він складається?',
        descriptions: [
          {
            code: false,
            label:
              'Якщо уявити HTML5 як відкриту веб-платформу, з яких блоків він складається?',
            description: `HTML5 як веб-платформа складається з наступних блоків:`,
          },
          {
            code: false,
            label: '',
            description: `• Семантичні теги - це теги, які використовуються для надання значення контенту і опису його структури на веб-сторінці. Такі теги, як <header>, <nav>, <article>, <section>, <footer> і <aside>, допомагають організувати контент і зробити його більш доступним для користувачів і пошукових систем.`,
          },
          {
            code: false,
            label: '',
            description: `• Форми - це елементи, які дозволяють користувачам взаємодіяти з веб-сторінкою, вводячи дані, виконуючи пошук або відправляючи дані на сервер. HTML5 надає багато нових типів полів вводу, таких як дата, електронна пошта, номер телефону і т.д.`,
          },
          {
            code: false,
            label: '',
            description: `• Мультимедіа - це елементи, які дозволяють вставляти мультимедійний контент на веб-сторінку. HTML5 підтримує відео, аудіо і зображення.`,
          },
          {
            code: false,
            label: '',
            description: `• Графіка і візуалізація - це блок, який містить нові теги, які дозволяють створювати складні візуалізації і графіки на веб-сторінках без необхідності використовувати додаткові плагіни або скрипти.`,
          },
          {
            code: false,
            label: '',
            description: `• Хмарні технології - це блок, який містить нові теги, які дозволяють взаємодіяти з хмарними сервісами, такими як Google Maps і YouTube.`,
          },
          {
            code: false,
            label: '',
            description: `• Нові API - це блок, який містить нові API, які дозволяють взаємодіяти з пристроями, такими як камера і мікрофон, а також зберігати інформацію локально на пристрої користувача.`,
          },
          {
            code: false,
            label: '',
            description: `Ці блоки дозволяють розробникам створювати більш складні та інтерактивні веб-додатки з більшими можливостями та більшим рівнем доступності для користувачів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке інлайновий стиль? Чи можна його перевизначити?',
        descriptions: [
          {
            code: false,
            label: 'Що таке інлайновий стиль? Чи можна його перевизначити?',
            description: `Інлайновий стиль - це метод задання стилів безпосередньо всередині HTML-елементу з використанням атрибуту "style". За допомогою інлайнових стилів можна задавати конкретні стилі для окремих елементів, такі як колір тексту, розмір шрифту, фоновий колір тощо.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, для того, щоб задати червоний колір тексту у певному елементі, можна використати наступний код з інлайновим стилем:`,
          },
          {
            code: true,
            label: '',
            description: `<p style="color: red;">Це червоний текст</p>`,
          },
          {
            code: false,
            label: '',
            description: `Інлайновий стиль можна перевизначати, але це може бути складним, особливо якщо на сторінці є багато елементів з інлайновими стилями. Кращим підходом є використання зовнішніх стилів CSS, що дозволяють централізовано керувати стилями на всій сторінці та уникнути дублювання коду.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Чи є у HTML елементів свої дефолтні специфічні стилі?',
        descriptions: [
          {
            code: false,
            label: 'Чи є у HTML елементів свої дефолтні специфічні стилі?',
            description: `Так, у більшості елементів HTML є дефолтні специфічні стилі, які браузери застосовують до цих елементів, якщо вони не мають власного CSS стилю. Наприклад, для тега <p> браузер застосовує маргіни, шрифт, кольори і інші стилі за замовчуванням.`,
          },
          {
            code: false,
            label: '',
            description: `Ці дефолтні стилі можуть відрізнятися від браузера до браузера, тому рекомендується використовувати reset CSS, щоб забезпечити єдиний вигляд вашого веб-сайту на різних браузерах.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке семантика? Які семантичні теги ви знаєте?',
        descriptions: [
          {
            code: false,
            label: 'Що таке семантика? Які семантичні теги ви знаєте?',
            description: `Семантика - це поняття, яке використовується в програмуванні та розробці веб-сайтів, щоб описати значення контенту на сторінці, зокрема, який контент представляється на сторінці та яку роль він відіграє в структурі сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `У HTML є багато семантичних тегів, які допомагають описати зміст сторінки. Ось деякі з найбільш поширених семантичних тегів:`,
          },
          {
            code: false,
            label: '',
            description: `1. <header> - використовується для визначення верхньої частини сторінки або блоку контенту.`,
          },
          {
            code: false,
            label: '',
            description: `2. <nav> - використовується для визначення навігаційного блоку сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `3. <main> - використовується для визначення головного контенту сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `4. <section> - використовується для групування пов'язаного контенту на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `5. <article> - використовується для визначення самостійних статей або блоків контенту на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `6. <aside> - використовується для визначення бічної панелі, яка може містити додатковий контент, що не пов'язаний з головним контентом сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `7. <footer> - використовується для визначення нижньої частини сторінки або блоку контенту.`,
          },
          {
            code: false,
            label: '',
            description: `8. <time> - використовується для визначення дати та часу.`,
          },
          {
            code: false,
            label: '',
            description: `9. <address> - використовується для визначення контактної інформації.`,
          },
          {
            code: false,
            label: '',
            description: `10. <form> - використовується для створення форми для введення даних користувачем.`,
          },
          {
            code: false,
            label: '',
            description: `Ці семантичні теги допомагають встановити правильну структуру та семантику сторінки, що покращує якість і оптимізує роботу з нею.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як семантично правильно зверстати картинку з підписом?',
        descriptions: [
          {
            code: false,
            label: 'Як семантично правильно зверстати картинку з підписом?',
            description: `Для семантично правильного верстування картинки з підписом, ми можемо використовувати тег <figure> для обгортання картинки і тег <figcaption> для підпису.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, ось такий код може бути використаний для відображення картинки з підписом:`,
          },
          {
            code: true,
            label: '',
            description: `
            <figure>
              <img src="image.jpg" alt="Короткий опис зображення">
              <figcaption>Підпис до зображення</figcaption>
            </figure>`,
          },
          {
            code: false,
            label: '',
            description: `Тут тег <figure> використовується для групування картинки і підпису, а тег <figcaption> використовується для відображення підпису до картинки. Використання таких семантичних тегів дозволяє браузерам та іншим інструментам для обробки вмісту краще розуміти структуру документа і поліпшує доступність та індексацію контенту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Типи списків у HTML?',
        descriptions: [
          {
            code: false,
            label: 'Типи списків у HTML?',
            description: `У HTML є три типи списків:`,
          },
          {
            code: false,
            label: '',
            description: `1. Нумерований список (<ol>) - список, в якому кожен елемент має порядковий номер у вигляді цифри або літери.`,
          },
          {
            code: false,
            label: '',
            description: `2. Маркований список (<ul>) - список, в якому кожен елемент має маркувальний символ, зазвичай це крапка або інший символ.`,
          },
          {
            code: false,
            label: '',
            description: `3. Список описів (<dl>) - список, в якому кожен елемент містить термін та його визначення. Термін відображається з використанням тега <dt>, а його визначення з тегом <dd>.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, так можна створити нумерований список у HTML:`,
          },
          {
            code: true,
            label: '',
            description: `
            <ol>
              <li>Перший елемент</li>
              <li>Другий елемент</li>
              <li>Третій елемент</li>
            </ol>
            `,
          },
          {
            code: false,
            label: '',
            description: `А от так виглядатиме маркований список:`,
          },
          {
            code: true,
            label: '',
            description: `
            <ul>
              <li>Перший елемент</li>
              <li>Другий елемент</li>
              <li>Третій елемент</li>
            </ul>          
            `,
          },
          {
            code: false,
            label: '',
            description: `А список описів можна створити за допомогою наступного коду:`,
          },
          {
            code: true,
            label: '',
            description: `
            <dl>
              <dt>Термін 1</dt>
              <dd>Визначення терміну 1</dd>
              <dt>Термін 2</dt>
              <dd>Визначення терміну 2</dd>
              <dt>Термін 3</dt>
              <dd>Визначення терміну 3</dd>
            </dl>
           `,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Для якого тега використовується атрибут alt і навіщо він потрібен?',
        descriptions: [
          {
            code: false,
            label:
              'Для якого тега використовується атрибут alt і навіщо він потрібен?',
            description: `Атрибут alt використовується для тега <img> в HTML. Він описує текстову альтернативу для зображення, якщо з якихось причин воно не може бути відображене на сторінці. Наприклад, якщо користувач має вимкнені зображення у своєму браузері, він побачить текст замість зображення, що дозволить зрозуміти, що малюнок тут мав бути.`,
          },
          {
            code: false,
            label: '',
            description: `Також, атрибут alt є важливим для доступності веб-сайту, оскільки екранні читачі використовують його для озвучення зображення людям з відповідними потребами. Тому варто завжди додавати атрибут alt до зображень на веб-сторінках.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Яка різниця між тегами <strong><em> і <b><i>?',
        descriptions: [
          {
            code: false,
            label: 'Яка різниця між тегами <strong><em> і <b><i>?',
            description: `Теги <strong> і <em> мають семантичне значення і призначені для визначення вагомості і емоційної інтонації тексту відповідно. Тег <strong> позначає текст, який має велику вагу, тобто текст, який є основним і важливим в контексті документа. Тег <em>, з іншого боку, вказує на текст, який має бути виділений з причин емоційної забарвленості, наприклад, для виокремлення акцентів, інтонації або емоційної виразності.`,
          },
          {
            code: false,
            label: '',
            description: `Теги <b> і <i>, з іншого боку, не мають семантичного значення і призначені для визначення стилістичних або графічних характеристик тексту. Тег <b> вказує на текст, який має бути виділений жирним шрифтом, а тег <i> - на текст, який має бути виділений курсивним шрифтом.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, для правильної семантики тексту в HTML рекомендується використовувати теги <strong> і <em>, а для стилістичного оформлення - теги <b> і <i>.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Типи <input> елементів у HTML?',
        descriptions: [
          {
            code: false,
            label: 'Типи <input> елементів у HTML?',
            description: `Тег <input> у HTML має декілька типів елементів, які можуть бути використані для отримання різного типу введення від користувача. Деякі з найпоширеніших типів input включають:`,
          },
          {
            code: false,
            label: '',
            description: `1. text: дозволяє користувачам вводити текст в однорядкове поле.`,
          },
          {
            code: false,
            label: '',
            description: `2. password: аналогічно полю введення тексту, але символи, введені користувачем, замінюються зірочками або крапками для безпеки.`,
          },
          {
            code: false,
            label: '',
            description: `3. checkbox: дозволяє користувачам вибирати один або декілька варіантів з відомим набором значень.`,
          },
          {
            code: false,
            label: '',
            description: `4. radio: дозволяє користувачам вибирати один з декількох варіантів, пропонованих відомим набором значень.`,
          },
          {
            code: false,
            label: '',
            description: `5. submit: використовується для відправки форми на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `6. reset: дозволяє користувачам скинути всі поля форми до їх початкових значень.`,
          },
          {
            code: false,
            label: '',
            description: `7. file: дозволяє користувачам вибирати файл для завантаження на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `8. hidden: створює приховане поле, яке можна використовувати для передачі додаткової інформації на сервер без відображення його на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `Це далеко не повний список можливих типів елементів <input>, але він охоплює більшість з найбільш поширених випадків використання.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Чому гарною практикою вважається розташовувати <link> для під'єднання CSS стилів усередині тега <head>, а <script> для під'єднання JS ставити перед тегом </body>, що закривається?`,
        descriptions: [
          {
            code: false,
            label: `Чому гарною практикою вважається розташовувати <link> для під'єднання CSS стилів усередині тега <head>, а <script> для під'єднання JS ставити перед тегом </body>, що закривається?`,
            description: `Розташування тегів <link> і <script> в HTML-документі має певне значення для оптимізації завантаження сторінки і для забезпечення правильної роботи скриптів.`,
          },
          {
            code: false,
            label: ``,
            description: `Тег <link> використовується для підключення зовнішніх ресурсів, таких як CSS-файли. Розміщення тегу <link> у тезі <head> дозволяє браузеру завантажувати CSS-файли до того, як він розпочне рендеринг сторінки. Це дозволяє браузеру правильно відображати контент з першого разу, а не затримувати відображення до завершення завантаження CSS-файлу.`,
          },
          {
            code: false,
            label: ``,
            description: `З іншого боку, тег <script> використовується для включення скриптів на сторінці. Якщо скрипти розміщені у тезі <head>, вони будуть завантажуватись перед відображенням контенту сторінки, що може затримати її відображення. Розміщення тегу <script> перед закриваючим тегом </body> дозволяє браузеру завантажувати скрипти після того, як контент сторінки буде повністю завантажено і відображено користувачеві. Це поліпшує швидкість завантаження сторінки та дозволяє уникнути можливих проблем з відображенням сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, розміщення тегів <link> та <script> відповідно в тезі <head> і перед закриваючим тегом </body> дозволяє забезпечити правильне завантаження і рендеринг сторінки, що є важливим для користувачів та для пошукових систем.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке мета-теги?`,
        descriptions: [
          {
            code: false,
            label: `Що таке мета-теги?`,
            description: `Мета-теги (англ. meta tags) - це елементи HTML, що надають додаткову інформацію про сторінку веб-сайту для пошукових систем та браузерів.`,
          },
          {
            code: false,
            label: ``,
            description: `Зазвичай, мета-теги розміщуються в секції <head> HTML документа і не відображаються на сторінці веб-сайту. Їх головна роль - забезпечити додаткову інформацію про сторінку для пошукових систем та інших програм, які обробляють веб-сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, мета-теги можуть містити інформацію про ключові слова сторінки, опис її змісту, автора, дату оновлення, мову та інші дані. Ця інформація використовується для покращення різноманітних процесів, наприклад, для підвищення рейтингу сторінки в пошукових системах, поліпшення відображення у соціальних мережах, та ін.`,
          },
          {
            code: false,
            label: ``,
            description: `Приклад мета-тегу, який містить опис сторінки:`,
          },
          {
            code: true,
            label: ``,
            description: `<meta name="description" content="Опис сторінки">`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що описується в тезі <head>?`,
        descriptions: [
          {
            code: false,
            label: `Що описується в тезі <head>?`,
            description: `Тег <head> у HTML документі використовується для зберігання метаданих, тобто інформації про сам документ, яка не відображається безпосередньо на сторінці, а використовується для її опрацювання браузером та пошуковими системами.`,
          },
          {
            code: false,
            label: ``,
            description: `У тезі <head> можна включати різноманітні метатеги, які задають метадані сторінки, такі як заголовок документа, опис, ключові слова, автор, кодування сторінки та інші. Також у тезі <head> можна включати посилання на зовнішні ресурси, такі як CSS стилі, JavaScript файли, шрифти та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `В заголовку сторінки можуть бути також включені інші теги, наприклад, <title>, <base>, <link>, <script>, <meta>, які виконують різні функції в HTML документі. Також у тезі <head> можуть бути включені різні скрипти, які використовуються для аналізу та відстеження поведінки користувачів на сторінці, а також для підключення різних інструментів аналізу та оптимізації веб-сторінок.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Для чого використовуються теги <tr>, <th>, <td>?`,
        descriptions: [
          {
            code: false,
            label: `Для чого використовуються теги <tr>, <th>, <td>?`,
            description: `Теги <tr>, <th>, та <td> використовуються для створення таблиць у HTML.`,
          },
          {
            code: false,
            label: ``,
            description: `• <tr> (Table Row) - тег, який вказує на рядок таблиці. Рядок може містити один або більше <td> або <th> елементів.`,
          },
          {
            code: false,
            label: ``,
            description: `• <th> (Table Header) - тег, який використовується для створення заголовку стовпця або рядка таблиці. Він зазвичай містить текст з пропозицією або описом змісту стовпця.`,
          },
          {
            code: false,
            label: ``,
            description: `• <td> (Table Data) - тег, який використовується для визначення комірки в таблиці. Він містить фактичний зміст даного рядка та стовпця таблиці.`,
          },
          {
            code: false,
            label: ``,
            description: `Кожен рядок таблиці (<tr>) містить один або більше стовпців (<th> або <td>). Стовпці у свою чергу розташовані в межах рядка. Використання цих тегів дозволяє створити таблиці з різним форматуванням, які можуть відображати дані в чіткому та логічному порядку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Розкажіть про meta-тег з name="viewport"?`,
        descriptions: [
          {
            code: false,
            label: `Розкажіть про meta-тег з name="viewport"?`,
            description: `Мета-тег з атрибутом name="viewport" використовується для налаштування масштабування та відображення вмісту веб-сторінки на мобільних пристроях.`,
          },
          {
            code: false,
            label: ``,
            description: `Атрибут content містить наступні властивості:`,
          },
          {
            code: false,
            label: ``,
            description: `• width=device-width: задає ширину вікна перегляду відповідно до ширини пристрою;`,
          },
          {
            code: false,
            label: ``,
            description: `• initial-scale: визначає початковий розмір масштабування сторінки;`,
          },
          {
            code: false,
            label: ``,
            description: `• minimum-scale та maximum-scale: визначають мінімальний та максимальний розмір масштабування відповідно;`,
          },
          {
            code: false,
            label: ``,
            description: `• user-scalable: дозволяє або забороняє масштабування відвідувачами сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `За допомогою цього мета-тега можна забезпечити коректне відображення вмісту сторінки на різних пристроях з різною шириною екрану. Він є важливим для респонсивного дизайну та підтримки мобільних пристроїв.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке елемент <canvas>? І для чого він використовується?`,
        descriptions: [
          {
            code: false,
            label: `Що таке елемент <canvas>? І для чого він використовується?`,
            description: `Елемент <canvas> є одним з новітніх елементів HTML5 і використовується для створення графіки та анімації на веб-сторінках. Він створює прямокутне поле, на якому можна малювати за допомогою JavaScript.`,
          },
          {
            code: false,
            label: ``,
            description: `Для того щоб на елементі <canvas> була зображена графіка, потрібно використовувати API для малювання Canvas. З допомогою методів і властивостей цього API можна малювати лінії, фігури, текст, застосовувати ефекти та інші графічні елементи.`,
          },
          {
            code: false,
            label: ``,
            description: `Основна перевага використання елементу <canvas> полягає в тому, що він дозволяє створювати складні анімації та візуалізації, які не можна досягти звичайними засобами HTML та CSS. Наприклад, можна створювати графіки, діаграми, ігри, анімаційні візуалізації та інші ефекти.`,
          },
          {
            code: false,
            label: ``,
            description: `Приклад використання елементу <canvas>:`,
          },
          {
            code: true,
            label: ``,
            description: `
              <canvas id="myCanvas" width="300" height="200"></canvas>

              <script>
                // отримуємо контекст малювання
                var canvas = document.getElementById("myCanvas");
                var ctx = canvas.getContext("2d");
              
                // малюємо коло
                ctx.beginPath();
                ctx.arc(150, 100, 50, 0, 2*Math.PI);
                ctx.stroke();
              </script>
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі ми створюємо елемент <canvas> з id="myCanvas" та розмірами 300x200 пікселів. Потім за допомогою JavaScript ми отримуємо контекст малювання за допомогою getContext("2d") і малюємо коло на елементі <canvas> за допомогою методів API.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке <svg> і <canvas>?`,
        descriptions: [
          {
            code: false,
            label: `Що таке <svg> і <canvas>?`,
            description: `<svg> та <canvas> - це дві різні технології для візуального представлення графіки у веб-додатках.`,
          },
          {
            code: false,
            label: ``,
            description: `<svg> (Scalable Vector Graphics) - це формат графіки, який використовує векторні об'єкти для зображення різних елементів, таких як лінії, криві, прямокутники, кола, текстові блоки тощо. SVG є вбудованим в HTML5 і дозволяє створювати векторні зображення, які можна масштабувати без втрати якості і розмірів. Цей формат зображення зазвичай використовується для створення іконок, діаграм, карт і різних візуальних ефектів.`,
          },
          {
            code: false,
            label: ``,
            description: `<canvas> - це елемент HTML5, який дозволяє використовувати JavaScript для малювання растрових зображень та графіки на веб-сторінці. Канвас створює зображення з пікселів, які можна маніпулювати з використанням JavaScript. Цей елемент зазвичай використовується для створення складних візуальних ефектів, анімацій, ігор та інших реактивних елементів на сторінці.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, основна відмінність між <svg> та <canvas> полягає в тому, що <svg> використовує векторні об'єкти, тоді як <canvas> створює зображення з пікселів. Обидва елементи можуть використовуватись для створення візуальних ефектів на сторінці, проте в залежності від потреби і типу зображення, можна вибирати той, який найбільше підходить для вашого проекту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Різниця між <canvas> і <svg>?`,
        descriptions: [
          {
            code: false,
            label: `Різниця між <canvas> і <svg>?`,
            description: `Якщо говорити про графічну рендерингову технологію, то основна різниця між <canvas> та <svg> полягає в тому, що <canvas> базується на растровій графіці, тоді як <svg> заснований на векторній графіці.`,
          },
          {
            code: false,
            label: ``,
            description: `Коли ми малюємо на <canvas>, ми створюємо растрове зображення шляхом малювання на піксельному "холсті" з заданою широтою та висотою. Ми малюємо прості форми, заливаємо їх кольорами та робимо різні операції зображення, використовуючи API для роботи з контекстом.`,
          },
          {
            code: false,
            label: ``,
            description: `З іншого боку, коли ми малюємо на <svg>, ми створюємо векторну графіку, визначаючи геометричні фігури, лінії та криві, що будують зображення. <svg> можна описати як XML-документ, який містить інформацію про фігури, їх розташування, розмір та інші параметри. Оскільки векторні зображення засновані на математичних формулах, вони можуть бути збільшені чи зменшені без втрати якості зображення.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, коли вам потрібно створити анімацію, графіку чи ілюстрацію з деталізованими ефектами, використовуйте <canvas>. А коли вам потрібно створити інтерактивну графіку з векторними формами та текстом, який можна масштабувати, використовуйте <svg>.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Плюси і мінуси <canvas> і <svg>?`,
        descriptions: [
          {
            code: false,
            label: `Плюси і мінуси <canvas> і <svg>?`,
            description: `Якщо порівнювати <canvas> та <svg>, то їх використовують для досягнення різних метою веб-розробки, і кожен з них має свої переваги та недоліки.`,
          },
          {
            code: false,
            label: `Основні переваги <canvas>:`,
            description: `• Для рендерингу зображень на <canvas> використовується JavaScript, що дозволяє створювати більш динамічні та інтерактивні ефекти.`,
          },
          {
            code: false,
            label: ``,
            description: `• <canvas> є кращим вибором, якщо вам потрібно відтворити велику кількість елементів, особливо якщо ці елементи постійно міняються. Він показує відмінну продуктивність при малюванні графіки та анімації.`,
          },
          {
            code: false,
            label: ``,
            description: `• Якщо у вас є потреба малювати багато простих форм, а також робити графічні ефекти, такі як розмиття, масштабування та обрізання, то <canvas> є кращим варіантом.`,
          },
          {
            code: false,
            label: `Основні переваги <svg>:`,
            description: `• Оскільки <svg> є векторним форматом, він ідеально підходить для малювання різних геометричних фігур та іконок, які повинні відображатися на екранах з різними розмірами та роздільною здатністю. Якщо вам потрібно відображати графіку, яка повинна бути розміром від 100% і більше, то <svg> є кращим варіантом.`,
          },
          {
            code: false,
            label: ``,
            description: `• Якщо вам потрібно відтворювати складну векторну графіку або ілюстрації, то <svg> є кращим вибором.`,
          },
          {
            code: false,
            label: ``,
            description: `• Використання <svg> полегшує створення доступної та SEO-оптимізованої графіки.`,
          },
          {
            code: false,
            label: ``,
            description: `Також є деякі недоліки, які можуть бути пов'язані з використанням <canvas> та <svg>. Наприклад, <canvas> не підтримує доступність, тому він не є найкращим варіантом для ств`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Для чого потрібен атрибут autocomplete?`,
        descriptions: [
          {
            code: false,
            label: `Для чого потрібен атрибут autocomplete?`,
            description: `Атрибут autocomplete використовується для вказівки браузеру на автоматичне заповнення полів вводу форми зі збережених користувачем даних. Це може бути корисно для поліпшення зручності введення даних користувачем.`,
          },
          {
            code: false,
            label: ``,
            description: `Значення атрибуту autocomplete може бути on або off. Якщо вказано on, браузер може заповнити поле автоматично, якщо він має збережені дані для цього поля. Якщо значення off, браузер повинен ігнорувати будь-які збережені дані та не заповнювати поле автоматично.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, якщо користувач раніше вводив своє ім'я в полі для вводу з іменем name, браузер може запропонувати це ім'я, коли користувач повертається до цієї сторінки та починає вводити своє ім'я знову. Це зменшує час та зусилля, потрібні для повторного введення даних. Однак, це також може представляти ризик для безпеки даних, тому розглядайте використання цього атрибуту з обережністю.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке елемент <output> у HTML5?`,
        descriptions: [
          {
            code: false,
            label: `Що таке елемент <output> у HTML5?`,
            description: `Елемент <output> є одним з нових елементів HTML5 і призначений для відображення результатів обчислень або інших даних, що генеруються за допомогою JavaScript. Зазвичай його використовують у формах для показу результатів введення користувача.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, якщо користувач заповнив форму з введенням чисел, відобразивши їх у елементі <input>, за допомогою скрипта можна розрахувати суму цих чисел і вивести результат у елементі <output>. Таким чином, елемент <output> дозволяє зручно відображати результати розрахунків без необхідності використовувати додатковий HTML-код.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <output> підтримує атрибут for, який забезпечує зв'язок з іншим елементом форми. Він також підтримує атрибут name, який дозволяє відправляти значення елемента разом з формою.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке властивість valueAsNumber?`,
        descriptions: [
          {
            code: false,
            label: `Що таке властивість valueAsNumber?`,
            description: `Властивість valueAsNumber є однією з властивостей об'єкта <input>. Вона повертає числове значення, введене в поле <input>, якщо тип поля number. Якщо введене значення не може бути перетворено на число, повертається значення NaN.`,
          },
          {
            code: false,
            label: ``,
            description: `Ця властивість особливо корисна, коли потрібно отримати числове значення з поля <input> без необхідності виконувати додаткове перетворення типів даних.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, якщо є поле введення з ID "myNumberInput", можна отримати числове значення, використовуючи наступний код JavaScript:`,
          },
          {
            code: true,
            label: ``,
            description: `
              const myInput = document.getElementById("myNumberInput");
              const numberValue = myInput.valueAsNumber;
            `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке атрибут target? Які значення він приймає?`,
        descriptions: [
          {
            code: false,
            label: `Що таке атрибут target? Які значення він приймає?`,
            description: `Атрибут target використовується для вказівки контексту, в якому повинна бути відкрита цільова сторінка або документ при кліку на посилання. Його можна використовувати для відкриття сторінки в новому вікні браузера, в тому ж вікні, в якому знаходиться посилання, або в іншому фреймі чи iframe.`,
          },
          {
            code: false,
            label: `Атрибут target може приймати такі значення:`,
            description: `• _blank: відкриття сторінки в новому вікні браузера.`,
          },
          {
            code: false,
            label: ``,
            description: `• _self: відкриття сторінки в тому ж вікні, в якому знаходиться посилання (за замовчуванням).`,
          },
          {
            code: false,
            label: ``,
            description: `• _parent: відкриття сторінки в батьківському фреймі або вікні, якщо фрейми використовуються.`,
          },
          {
            code: false,
            label: ``,
            description: `• _top: відкриття сторінки в повному вікні браузера, замінюючи будь-які фрейми, якщо вони використовуються.`,
          },
          {
            code: false,
            label: ``,
            description: `• ім'я фрейму або iframe: відкриття сторінки в вказаному фреймі або iframe.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, <a href="http://example.com" target="_blank">Посилання</a> відкриє сторінку посилання в новому вікні браузера.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Для чого використовується елемент <picture>?`,
        descriptions: [
          {
            code: false,
            label: `Для чого використовується елемент <picture>?`,
            description: `Елемент <picture> використовується для відображення різних зображень в залежності від характеристик екрана та розмірів відображення. Він дозволяє веб-розробникам пропонувати оптимальні зображення для різних пристроїв та розмірів екранів, зменшуючи таким чином завантаження сторінки та збільшуючи швидкість її завантаження.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <picture> містить кілька дочірніх елементів <source> з атрибутами srcset та media, які вказують браузеру наявність декількох варіантів зображення з різними розмірами або різною якістю для вибору найкращого варіанту. Останнім елементом є елемент <img>, що містить адресу зображення, яка буде відображена, якщо жоден з попередніх елементів не вказує на підходяще зображення.`,
          },
          {
            code: false,
            label: ``,
            description: `Для коректної роботи елемента <picture> необхідно додатково використовувати атрибут sizes, що вказує на ширину контейнера, в якому буде відображатися зображення. Також варто дбати про встановлення альтернативного тексту зображення за допомогою атрибута alt в елементі <img>.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Як семантично правильно зверстати навігаційне меню?`,
        descriptions: [
          {
            code: false,
            label: `Як семантично правильно зверстати навігаційне меню?`,
            description: `Навігаційне меню на веб-сайті повинно бути зверстано з використанням семантичних тегів, які відповідають за різні його елементи. Ось декілька рекомендацій щодо семантичного верстування навігаційного меню:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Використовуйте тег <nav> для контейнера навігаційного меню, який зазвичай розміщується у верхній частині сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Використовуйте тег <ul> для створення списку пунктів меню. Кожен пункт меню має бути вкладений у тег <li>. Для підпунктів можна використовувати вкладені списки <ul> і <li>.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Для кожного пункту меню створіть посилання з використанням тега <a>. В атрибуті href зазначте URL-адресу сторінки, на яку потрібно перейти при кліку на пункт меню.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Якщо на сторінці є більше одного навігаційного меню, використовуйте атрибут aria-label для надання унікальної мітки кожному з них.`,
          },
          {
            code: false,
            label: ``,
            description: `5. Застосовуйте стилі до елементів навігаційного меню, використовуючи CSS. Використання класів або ідентифікаторів для кожного пункту меню допоможе зробити CSS-код більш організованим і легким для редагування.`,
          },
          {
            code: false,
            label: ``,
            description: `6. Якщо навігаційне меню повинно бути адаптивним, використовуйте медіа-запити CSS, щоб змінювати розташування і вигляд меню на різних розмірах екрану.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, семантично правильне навігаційне меню повинно бути зверстане з використанням тегів <nav>, <ul>, <li> і <a>, і містити атрибути та мітки, щоб зробити його доступним для користувачів з обмеженими можливостями.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке <iframe>?`,
        descriptions: [
          {
            code: false,
            label: `Що таке <iframe>?`,
            description: `Елемент <iframe> (inline frame) в HTML є контейнером, що дозволяє вбудовувати інший документ HTML в поточний документ. Це означає, що вміст, що відображається в <iframe>, може бути зовнішнім документом, іншою сторінкою в тому ж домені або іншою сторінкою в іншому домені.`,
          },
          {
            code: false,
            label: ``,
            description: `Іншими словами, <iframe> дозволяє вставляти веб-сторінки або вміст, що походить з інших джерел, в поточний документ. Це може бути корисно в таких випадках, як вбудовування карт або відео з інших джерел, відображення інших веб-сторінок в межах поточного документу або вбудовування інтерактивних додатків, таких як вікна чату або калькулятори.`,
          },
          {
            code: false,
            label: ``,
            description: `Для створення <iframe> потрібно вказати посилання на джерело, з якого взяти вміст, за допомогою атрибута src. Також можна налаштувати розміри та інші параметри за допомогою інших атрибутів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Як можна приховати елемент розмітки не використовуючи CSS і JS?`,
        descriptions: [
          {
            code: false,
            label: `Як можна приховати елемент розмітки не використовуючи CSS і JS?`,
            description: `Можна приховати елемент розмітки, встановивши для нього атрибут hidden. Цей атрибут вказує браузеру, що елемент повинен бути прихованим і не повинен відображатися на сторінці. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
              <p>Цей абзац буде відображений</p>
              <p hidden>Цей абзац буде прихований</p>
            `,
          },
          {
            code: false,
            label: ``,
            description: `Елемент з атрибутом hidden буде забезпечувати контекст для браузера, що допоможе зрозуміти, який контент має бути прихований. Однак, він все ще буде доступний для програмного забезпечення, такого як скрейпери та індексатори пошукових систем.`,
          },
          {
            code: false,
            label: ``,
            description: `Зазвичай кращим підходом є використання CSS або JS для приховання елементів, оскільки це забезпечує більш гнучкий та ефективний спосіб контролювання відображення контенту на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Різниця між <meter> і <progress>?`,
        descriptions: [
          {
            code: false,
            label: `Різниця між <meter> і <progress>?`,
            description: `Елементи <meter> і <progress> використовуються для відображення показників прогресу, але мають дещо різні функції.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <meter> використовується для відображення вимірювань, які мають значення в межах заданого діапазону. Він містить два обов'язкові атрибути: min (мінімальне значення) та max (максимальне значення), а також необов'язковий атрибут value (поточне значення). Також можна використовувати атрибути low, high та optimum для визначення нижньої, верхньої та оптимальної межі значень.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <progress> використовується для відображення поточного стану завантаження чи виконання задачі, яка не має фіксованого діапазону. Він містить обов'язковий атрибут value (поточне значення), а також необов'язковий атрибут max (максимальне значення), який можна використовувати, якщо заздалегідь відомо максимальне можливе значення.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, різниця між <meter> та <progress> полягає у тому, що <meter> використовується для відображення вимірювань з фіксованим діапазоном, тоді як <progress> використовується для відображення поточного стану завантаження чи виконання задачі, яка не має фіксованого діапазону.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Розкажіть про особливості стилізації <svg>?`,
        descriptions: [
          {
            code: false,
            label: `Розкажіть про особливості стилізації <svg>?`,
            description: `Елемент <svg> - це векторна графіка, яку можна масштабувати без втрати якості. Стилізація <svg> може здійснюватись як за допомогою CSS, так і вбудованими атрибутами SVG.`,
          },
          {
            code: false,
            label: ``,
            description: `Особливості стилізації <svg> залежать від того, як він вбудовується в HTML документ. Якщо <svg> вбудовується як зовнішній файл, то його можна стилізувати за допомогою CSS, використовуючи селектори, аналогічні селекторам HTML. Якщо ж <svg> вбудовується безпосередньо в HTML документ, то його можна стилізувати за допомогою атрибутів SVG.`,
          },
          {
            code: false,
            label: `Основні атрибути SVG для стилізації елементів:`,
            description: `• fill - встановлює фоновий колір елемента;`,
          },
          {
            code: false,
            label: ``,
            description: `• stroke - встановлює колір обводки елемента;`,
          },
          {
            code: false,
            label: ``,
            description: `• stroke-width - встановлює товщину обводки елемента;`,
          },
          {
            code: false,
            label: ``,
            description: `• opacity - встановлює прозорість елемента.`,
          },
          {
            code: false,
            label: ``,
            description: `Крім того, для стилізації <svg> можна використовувати CSS властивості, які не залежать від розмірів екрану, такі як color, background-color, font-size тощо. Також можна використовувати псевдоелементи (::before, ::after) для створення декоративних ефектів.`,
          },
          {
            code: false,
            label: ``,
            description: `У <svg> є декілька особливостей, пов'язаних зі стилізацією тексту. Наприклад, для задання шрифту використовується атрибут font-family, а для задання розміру шрифту - font-size. Також є спеціальний атрибут text-anchor, який визначає точку, до якої буде прив'язано текстовий елемент.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Різниця між кнопкою та посиланням у HTML?`,
        descriptions: [
          {
            code: false,
            label: `Різниця між кнопкою та посиланням у HTML?`,
            description: `У HTML кнопка та посилання - це два різних елементи, які мають різні призначення та можливості.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <a> (посилання) використовується для створення гіперпосилань на інші веб-сторінки або на окремі елементи в межах тієї ж сторінки. При кліку на посилання користувач переходить на іншу сторінку або переміщується на інший елемент на поточній сторінці. Щоб зробити посилання на кнопку, можна використовувати CSS для задання вигляду посилання (наприклад, задати колір, фон, рамку тощо).`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <button> (кнопка) використовується для створення кнопок, які використовуються для виконання дій на веб-сторінці, наприклад, відправки форми, виклику функції JavaScript або переходу на іншу сторінку. Кнопки можуть мати текст або іконку, та можуть бути стилізовані за допомогою CSS.`,
          },
          {
            code: false,
            label: ``,
            description: `Основна різниця між кнопкою та посиланням полягає в їх функціональності та призначенні. Посилання використовується для переходу на іншу сторінку або для переміщення на інший елемент на поточній сторінці, тоді як кнопка використовується для виконання дій на веб-сторінці, таких як відправка форми або виклик функції JavaScript.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Чому варто використовувати семантичні теги у верстці?`,
        descriptions: [
          {
            code: false,
            label: `Чому варто використовувати семантичні теги у верстці?`,
            description: `Використання семантичних тегів у верстці допомагає встановити правильну структуру документу і покращує його доступність для користувачів і пошукових систем. Основні причини використання семантичних тегів наступні:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Семантичність. Семантичні теги описують зміст елементів, тобто надають зрозумілу для пошукових систем і людей інформацію про те, що відображено на сторінці.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Краща доступність. Користувачі з обмеженнями можуть використовувати програми, які читають вміст сторінки. Використання семантичних тегів дозволяє створювати документи, які будуть легко зрозумілі для таких програм.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Покращення SEO. Використання семантичних тегів допомагає пошуковим системам краще зрозуміти структуру сторінки і, як наслідок, покращує її позиції в пошукових результатів.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Спрощення розробки. Використання семантичних тегів дозволяє розробникам швидше розуміти структуру документу і спрощує його розробку та обслуговування.`,
          },
          {
            code: false,
            label: ``,
            description: `До семантичних тегів HTML5 належать, наприклад, <header>, <footer>, <nav>, <article>, <section>, <aside>, <main>, <figure>, <figcaption>, <time>, <mark>, <details>, <summary> і багато інших.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Для чого використовується тег <label>?`,
        descriptions: [
          {
            code: false,
            label: `Для чого використовується тег <label>?`,
            description: `Тег <label> використовується для зв'язування текстової мітки з елементом форми, наприклад, з елементом <input>, <textarea> або <select>. Це дозволяє користувачам натискати на текст мітки, щоб активувати пов'язаний елемент форми, а не шукати його за допомогою миші чи клавіатури.`,
          },
          {
            code: false,
            label: ``,
            description: `Також використання тегу <label> допомагає збільшити доступність веб-сторінок для користувачів з обмеженими можливостями, такими як використання скрінрідера. Крім того, використання тегу <label> може покращити SEO-оптимізацію веб-сторінок, оскільки пошукові роботи можуть використовувати текст міток для кращого розуміння змісту сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `Приклад використання тегу <label> для зв'язування мітки з елементом форми:`,
          },
          {
            code: true,
            label: ``,
            description: `
            <label for="username">Ім'я користувача:</label>
            <input type="text" id="username" name="username">            
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі мітка "Ім'я користувача:" пов'язана з елементом форми <input> за допомогою атрибута for, який вказує на ідентифікатор елемента <input>. При натисканні на мітку користувач переходить до поля введення, щоб заповнити його.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'CSS',
    questions: [
      {
        id: generateUUID(),
        question: 'Що таке CSS? І навіщо він використовується?',
        descriptions: [
          {
            code: false,
            label: 'CSS',
            description: `CSS (Cascading Style Sheets) - це мова опису стилів, яка використовується для оформлення веб-сторінок.`,
          },
          {
            code: false,
            label: '',
            description: `CSS дозволяє відокремлювати опис зовнішнього вигляду веб-сторінки від її HTML-структури та логіки. За допомогою CSS можна задавати кольори, шрифти, розміри, межі, відступи, вирівнювання та інші властивості елементів на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CSS-правило?',
        descriptions: [
          {
            code: false,
            label: 'CSS-правило',
            description: `
CSS-правило (іноді його називають CSS-декларацією) - це основна одиниця стилю в CSS, яка визначає зовнішній вигляд певного елемента на веб-сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `Кожне CSS-правило складається з двох основних частин: селектора та оголошення стилів. Селектор вказує на те, які елементи HTML на сторінці повинні бути стилізовані, а оголошення стилів містить властивості та їх значення, які задають зовнішній вигляд цих елементів.`,
          },
          {
            code: true,
            label: 'Ось приклад CSS-правила:',
            description: `p {
  color: red;
  font-size: 16px;
  font-weight: bold;
}`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Варіанти додавання CSS стилів на сторінку?',
        descriptions: [
          {
            code: false,
            label:
              'Є кілька способів додавання CSS стилів на сторінку веб-сайту:',
            description: `1.Внутрішній CSS: можна включити CSS-стилі безпосередньо в тег head HTML-документу за допомогою тегу style`,
          },
          {
            code: true,
            label: '',
            description: `
<head>
  <style>
    body {
      background-color: #f2f2f2;
    }
  </style>
</head>`,
          },
          {
            code: false,
            label: '',
            description: `2. Зовнішній CSS: CSS можна зберігати у відокремленому файлі з розширенням .css, який повинен бути підключений до HTML-документу за допомогою тегу link`,
          },
          {
            code: true,
            label: '',
            description: `
<head>
  <link rel="stylesheet" type="text/css" href="">
</head>`,
          },
          {
            code: false,
            label: '',
            description: `3. Inline CSS: можна додавати стилі безпосередньо до HTML-елементів за допомогою атрибуту   `,
          },
          {
            code: true,
            label: '',
            description: `
<h1 style="color: blue;">Це заголовок сторінки</h1>
`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Типи позиціонування у CSS?',
        descriptions: [
          {
            code: false,
            label: 'Static',
            description: `Static: це тип позиціонування за замовчуванням для кожного HTML-елемента. Елементи з позиціонуванням Static розміщуються в документі так, як вони повинні бути відображені без будь-якої додаткової обробки.`,
          },
          {
            code: false,
            label: 'Relative',
            description: `Relative: це тип позиціонування, в якому елемент зсувається відносно своєї початкової позиції в залежності від заданого значення властивості top, bottom, left або right. З іншого боку, навіть якщо елемент зсунутий, його місце залишається зарезервованим у потоці документу, тому сусідні елементи не зміщуються.`,
          },
          {
            code: false,
            label: 'Absolute',
            description: `Absolute: це тип позиціонування, в якому елемент відноситься до свого найближчого "пріоритетного" елемента з непорожнім значенням властивості position (може бути родичем або предком). Елемент з позиціонуванням Absolute встановлюється в конкретну позицію на сторінці відносно своїх пріоритетних елементів або відносно вікна браузера, якщо він не має пріоритетних елементів. Це зазвичай використовується для розміщення елементів у плаваючому вікні.`,
          },
          {
            code: false,
            label: 'Fixed',
            description: `Крім цих трьох типів позиціонування, у CSS є ще четвертий тип - Fixed, який працює подібно до Absolute, але елемент розміщується відносно вікна браузера, а не відносно інших елементів. Це корисно для створення елементів, які завжди залишаються на одному місці на сторінці, незалежно від того, як користувач прокручує сторінку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Блокова модель CSS?',
        descriptions: [
          {
            code: false,
            label: 'Блокова модель CSS',
            description: `Блокова модель CSS - це спосіб визначення та обробки розмірів та просторів HTML-елементів в CSS. Вона описує, як браузер визначає розміри та простори елемента на сторінці, включаючи вміст, відступи, рамки та поля.`,
          },
          {
            code: false,
            label: '',
            description: `Загальний принцип блокової моделі полягає у тому, що кожен HTML-елемент може бути представлений як прямокутник, який складається з чотирьох складових:`,
          },
          {
            code: false,
            label: '',
            description: `Контент (content): це вміст елемента, який міститься в середині рамки.
Відступ (padding): це простір між контентом та рамкою.
Рамка (border): це лінія, яка оточує контент та відступ.
Поле (margin): це простір між рамкою та сусідніми елементами.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке селектор? І які селектори є?',
        descriptions: [
          {
            code: false,
            label: 'CSS селектор',
            description: `У CSS, селектор - це патерн, який вказує, які HTML-елементи мають бути вибрані та стилізовані. Селектори дозволяють вибирати один або більше HTML-елементів на сторінці та застосовувати до них один або більше стилів.`,
          },
          {
            code: false,
            label: 'CSS селектор бувають:',
            description: `Селектор елемента: вибирає всі елементи певного типу, наприклад, всі <p> або всі <div>.

Селектор класу: вибирає всі елементи, які мають певний клас, визначений у HTML-коді за допомогою атрибуту class. Селектор класу починається з крапки (.), а за нею слідує назва класу.

Селектор ID: вибирає елемент з певним ID, визначеним у HTML-коді за допомогою атрибуту id. Селектор ID починається з хеш-символу (#), а за ним слідує назва ID.

Селектор дочірнього елемента: вибирає елемент, який є нащадком певного елемента, наприклад, всі <li> елементи, які знаходяться всередині <ul> елемента.

Селектор взаємодії (hover): використовується для визначення стилю, який має бути застосований до елемента, коли на нього наведено курсор.

Селектор атрибута: вибирає всі елементи з певним значенням атрибуту, наприклад, всі елементи з атрибутом href.

Селектор комбінатора: поєднує два або більше селектори, щоб вибрати елементи, які відповідають обом умовам. Наприклад, селектор div p вибирає всі <p> елементи, які знаходяться всередині <div> елемента.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке специфіка селектора? Як рахувати вагу селектора?',
        descriptions: [
          {
            code: false,
            label: 'Що таке специфіка селектора?',
            description: `Специфіка селектора в CSS - це показник того, як сильно впливає селектор на елементи, які він вибирає. Специфіка селектора визначає, який з однакових стилів застосується до елемента, якщо було вказано декілька селекторів, які відповідають йому. Селектор з більшою специфікою має вищий пріоритет.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між Reset.css та Normalize.css?',
        descriptions: [
          {
            code: false,
            label: 'Reset.css',
            description: `Reset.css - це файл стилів, який зазвичай включається в початок CSS файлу і має на меті повністю скинути всі початкові значення CSS стилів для HTML елементів на сторінці. Це дозволяє вам почати з чистого стану, створюючи зовнішній вигляд з нуля. Однак, такі скидання можуть бути дуже радикальними і виникнуть проблеми з сумісністю між браузерами. Зазвичай, при використанні Reset.css потрібно вручну налаштувати всі елементи.`,
          },
          {
            code: false,
            label: 'Normalize.css',
            description: `Normalize.css - це інший файл стилів, який зазвичай включається в початок CSS файлу. Основна ідея Normalize.css полягає в тому, щоб стандартизувати вигляд HTML елементів в різних браузерах, зберігаючи при цьому їх звичайний вигляд. Normalize.css не скидає початкові значення CSS стилів, а замінює їх на більш стандартні значення, які будуть однаковими у всіх браузерах. Це допомагає зменшити проблеми з сумісністю між браузерами та спрощує налаштування стилів.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, відмінність між Reset.css та Normalize.css полягає у тому, що Reset.css скидає всі початкові значення CSS стилів для HTML елементів на сторінці, тоді як Normalize.css стандартизує їх вигляд.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між margin та padding?',
        descriptions: [
          {
            code: false,
            label: 'Margin',
            description: `Margin - це відстань між зовнішнім краєм елемента та іншими елементами на сторінці. Якщо розмір маргіну позитивний, то він збільшить відстань між елементами, якщо від'ємний - то зменшить. Маргін не включається в розмір елемента, тому коли ми встановлюємо маргін, то це впливає тільки на відстань між елементами, а не на їх розмір.`,
          },
          {
            code: false,
            label: 'Padding',
            description: `Padding - це відстань між внутрішнім краєм елемента та його вмістом. Якщо розмір padding позитивний, то він збільшить відстань між вмістом елемента та його рамкою, якщо від'ємний - то зменшить. Padding включається в розмір елемента, тому коли ми встановлюємо padding, то це впливає на розмір елемента.`,
          },
          {
            code: false,
            label: 'Різниця між margin та padding',
            description: `Отже, різниця між margin та padding полягає у тому, що margin визначає відстань між зовнішнім краєм елемента та іншими елементами, тоді як padding визначає відстань між внутрішнім краєм елемента та його вмістом. Також важливо зазначити, що margin не включається в розмір елемента, тоді як padding включається.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між display: none та visibility: hidden?',
        descriptions: [
          {
            code: false,
            label: 'display: none',
            description: `Коли ми встановлюємо display: none, елемент повністю видаляється з потоку документа і стає недоступним для користувача. Це означає, що елемент не займає місце на сторінці, не має висоти та ширини, і не можна взаємодіяти з його вмістом. Якщо елемент має дочірні елементи, вони також будуть приховані.`,
          },
          {
            code: false,
            label: 'visibility: hidden',
            description: `У випадку з visibility: hidden, елемент залишається в потоці документа, і займає той самий обсяг місця, що й до того. Але елемент і його вміст стає невидимим для користувача. Таким чином, хоча елемент не взаємодіє з користувачем, місце на сторінці, яке він займає, все ще резервується.`,
          },
          {
            code: false,
            label: 'Різниця між display: none та visibility: hidden?',
            description: `Отже, головна різниця між display: none та visibility: hidden полягає у тому, що display: none повністю видаляє елемент з потоку документа, в той час як visibility: hidden зберігає місце на сторінці, яке займе елемент.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між блоковим та малим (інлайновим) елементами?',
        descriptions: [
          {
            code: false,
            label: 'Блокові елементи',
            description: `Блокові елементи - це елементи, які займають всю доступну ширину батьківського контейнера, і завжди починаються з нового рядка. Тобто, якщо ми маємо декілька блокових елементів в одному рядку, кожен з них почне новий рядок. За замовчуванням, блокові елементи мають ширину 100%, і можуть мати встановлену висоту, поля (margin) та відступи (padding).`,
          },
          {
            code: false,
            label: 'Інлайнові елементи',
            description: `Інлайнові елементи (малі) - це елементи, які займають тільки той простір, який потрібний для їх вмісту. Вони не починають новий рядок, і можуть знаходитись поруч з іншими елементами в одному рядку. Інлайнові елементи мають ширину та висоту, що відповідає їх вмісту, і не можуть мати встановлені відступи з усіх сторін.`,
          },
          {
            code: false,
            label: 'Різниця між блоковим та малим (інлайновим) елементами',
            description: `Основна різниця між блоковими та інлайновими елементами полягає в тому, як вони взаємодіють з іншими елементами в рядку. Блокові елементи завжди починаються з нового рядка, тоді як інлайнові можуть знаходитись поруч з іншими елементами. Також вони мають різні значення за замовчуванням для ширини, висоти, полів та відступів. Однак, CSS дозволяє змінювати ці значення, тому блокові та інлайнові елементи можуть мати схожий вигляд, якщо вони правильно стилізовані.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між класом та ідентифікатором у CSS?',
        descriptions: [
          {
            code: false,
            label: 'Ідентифікатор',
            description: `Ідентифікатор (id) - це унікальний ідентифікатор, який призначається для конкретного елемента на сторінці. Він зазвичай використовується для стилізації одного конкретного елемента. Ідентифікатор визначається з символу хеша (#) перед ним. Наприклад, якщо ви хочете стилізувати елемент з id "header", то ви можете використовувати селектор "#header" в CSS.`,
          },
          {
            code: false,
            label: 'Клас (class)',
            description: `Клас (class) - це набір елементів зі спільною характеристикою, який можна застосовувати до багатьох елементів на сторінці. Клас визначається з символу крапки (.) перед ним. Наприклад, якщо ви хочете стилізувати всі елементи з класом "menu-item", то ви можете використовувати селектор ".menu-item" в CSS.`,
          },
          {
            code: false,
            label: 'Різниця між класом та ідентифікатором у CSS',
            description: `Основна різниця між ідентифікатором та класом полягає в тому, що ідентифікатор може бути застосований лише до одного елемента, тоді як клас можна застосовувати до декількох елементів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CSS спрайт? І навіщо він використовується?',
        descriptions: [
          {
            code: false,
            label: 'CSS спрайт',
            description: `CSS спрайт (CSS sprite) - це техніка оптимізації веб-сторінок, яка полягає в об'єднанні кількох маленьких зображень в один великий файл зображень і використанні CSS для відображення тільки необхідної частини файлу зображень на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `Використання CSS спрайтів дозволяє зменшити час завантаження сторінки та зменшити кількість запитів до сервера, що покращує швидкість завантаження веб-сторінки та її продуктивність.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке вендорні префікси? І навіщо вони використовуються?',
        descriptions: [
          {
            code: false,
            label:
              'Вендорні префікси (vendor prefixes), також відомі як префікси постачальників, це частини CSS-кода, які додаються до властивостей CSS для підтримки відповідних функцій та властивостей у різних браузерах. Кожен браузер може підтримувати різні CSS-функції та властивості на різні способи. Вендорні префікси дозволяють розробникам веб-сайтів використовувати нові функції та властивості CSS, навіть якщо вони не підтримуються всіма браузерами.',
            description: ``,
          },
          {
            code: false,
            label: '',
            description: `Кожен постачальник браузера має свій вендорний префікс, який додається до назви властивості CSS. Наприклад, для Safari префікс -webkit-, для Firefox -moz-, для Chrome та Opera -webkit- та -o- відповідно. Наприклад, якщо ви хочете використовувати свійтчер (font-feature-settings) у своєму CSS-коді, ви повинні додати наступний код:`,
          },
          {
            code: true,
            label: 'Приклад коду',
            description: `.selector {
  -webkit-font-feature-settings: "liga";
  -moz-font-feature-settings: "liga";
  font-feature-settings: "liga";
}`,
          },
          {
            code: false,
            label: '',
            description: `Вендорні префікси дозволяють розробникам веб-сайтів використовувати нові функції та властивості CSS, що не є стандартними і не підтримуються всіма браузерами. Однак, використання вендорних префіксів може призвести до того, що код CSS стає більш складним та збільшує його розмір, що може призвести до погіршення продуктивності та швидкості завантаження веб-сторінки. Тому важливо правильно використовувати вендорні префікси, щоб забезпечити підтримку функцій CSS на різних браузерах та зберегти продуктивність веб-сторінки.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке псевдоелементи? І навіщо вони використовуються?',
        descriptions: [
          {
            code: false,
            label: 'Псевдоелементи ',
            description: `Псевдоелементи (pseudo-elements) - це ключові слова в CSS, які додаються до селекторів для створення ефектів, які не можуть бути створені звичайними селекторами. Вони дозволяють створювати додаткові елементи на сторінці, які можуть бути використані для оформлення контенту.`,
          },
          {
            code: false,
            label: '',
            description: `Псевдоелементи в CSS позначаються знаком двокрапки (:), за яким слідує ключове слово, яке описує тип псевдоелементу. Наприклад, псевдоелемент ::before використовується для створення додаткового елемента перед вмістом вибраного елемента, а псевдоелемент ::after - для створення додаткового елемента після вмісту вибраного елемента.`,
          },
          {
            code: false,
            label: '',
            description: `Основна мета використання псевдоелементів - це створення додаткових елементів на сторінці, щоб оформити контент. `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке схлопування меж (margin collapsing)?',
        descriptions: [
          {
            code: false,
            label: 'margin collapsing',
            description: `Схлопування меж (margin collapsing) - це особливість веб-рендерингу, при якій зовнішні верхні та нижні межі (margin) двох блоків можуть зливатись в одну межу. Таке зливання відбувається, якщо один блок знаходиться внутрішньо в іншому блоку і не має власної межі відступу.`,
          },
          {
            code: false,
            label: 'margin collapsing',
            description: `Для уникнення проблем зі схлопуванням меж, можна використовувати різні техніки, наприклад, встановлювати внутрішні відступи (padding) замість зовнішніх меж, використовувати спеціальні CSS властивості для контролювання схлопування меж, або використовувати фіксовані розміри для блоків, щоб уникнути зливання меж.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CSS препроцесор?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `CSS-препроцесор - це інструмент, який дозволяє розробникам писати CSS-код більш ефективно та з більшою організацією. Це різновид мови програмування, який дозволяє додавати до CSS нові функціональність та зручні синтаксис.`,
          },
          {
            code: false,
            label: '',
            description: `Популярні CSS-препроцесори включають Sass, Less, Stylus та інші.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке z-index? Як формується контекст накладання?',
        descriptions: [
          {
            code: false,
            label: 'z-index',
            description: `z-index - це CSS-властивість, що визначає порядок накладання елементів один на одного в 2D просторі веб-сторінки. Значення z-index може бути додатнім, від'ємним або нульовим.`,
          },
          {
            code: false,
            label: 'Як формується контекст накладання?',
            description: `Кожен елемент може мати свій власний контекст накладання, який визначається за наступними критеріями:`,
          },
          {
            code: false,
            label: '',
            description: `• Значення z-index. Елемент з більшим значенням z-index з'являється на вершині.`,
          },
          {
            code: false,
            label: '',
            description: `• Порядок HTML-розмітки. Останній елемент, що додається до HTML-розмітки, з'являється на вершині.`,
          },
          {
            code: false,
            label: '',
            description: `• Позиціонування. Елементи, що позиціонуються (наприклад, за допомогою властивості position: absolute), з'являються на вершині над не позиціонованими елементами.`,
          },
          {
            code: false,
            label: '',
            description: `• Прозорість. Прозорі елементи з'являються під непрозорими елементами.`,
          },
          {
            code: false,
            label: '',
            description: `• Наслідування. Батьківський контекст накладання наслідується дочірніми елементами.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Порядок накладання елементів у CSS (Stacking Order)?',
        descriptions: [
          {
            code: false,
            label:
              'Основні фактори, що визначають порядок накладання елементів, такі:',
            description: ``,
          },
          {
            code: false,
            label: '',
            description: `• HTML порядок: елементи, які з'являються в HTML коді пізніше, відображаються поверх тих, які з'являються раніше.`,
          },
          {
            code: false,
            label: '',
            description: `• Позиціонування: елементи, які позиціонуються з використанням властивостей position: relative, position: absolute або position: fixed, відображаються поверх тих, які не позиціонуються. `,
          },
          {
            code: false,
            label: '',
            description: `• z-index: це властивість, що визначає, на якому рівні накладання буде розташований елемент. Значення z-index може бути цілим числом або словом, таким як auto, inherit або initial.`,
          },
          {
            code: false,
            label: '',
            description: `• Контекст накладання: кожен елемент на сторінці має свій власний контекст накладання. Елементи, що мають більш високий контекст накладання, з'являються поверх тих, що мають менший контекст накладання.`,
          },
          {
            code: false,
            label: '',
            description: `• Прозорість: прозорі елементи з'являються під непрозорими елементами.`,
          },
          {
            code: false,
            label: '',
            description: `• mix-blend-mode: властивість, яка визначає спосіб змішування кольорів двох елементів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Як за допомогою CSS визначити, чи підтримується властивість у браузері?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Використання префіксів браузера. Префікси браузера - це додаткові префікси, які додаються до властивостей, які ще не стали стандартними. Наприклад, якщо ви хочете використовувати властивість "flexbox", яка не підтримується в старіших версіях браузерів, ви можете використовувати наступний код: `,
          },
          {
            code: true,
            label: '',
            description: `display: -webkit-flex; /* Safari */
             display: flex; /* стандарт */`,
          },
          {
            code: false,
            label: '',
            description: `Використання @supports. @supports - це CSS-правило, яке дозволяє вам перевірити, чи підтримує браузер певну властивість. Наприклад, якщо ви хочете перевірити, чи підтримує браузер властивість "display: flex", ви можете використовувати наступний код:`,
          },
          {
            code: true,
            label: '',
            description: `@supports (display: flex) {
  /* CSS-правила, які виконуються, якщо браузер підтримує властивість flex */}`,
          },
          {
            code: false,
            label: '',
            description: `Використання Modernizr. Modernizr - це JavaScript-бібліотека, яка дозволяє перевірити, чи підтримує браузер певні CSS-властивості. Щоб використовувати Modernizr, ви повинні включити бібліотеку на своїй сторінці і додати класи до елементів залежно від того, чи підтримує браузер певну властивість. Наприклад:`,
          },
          {
            code: true,
            label: '',
            description: `if (Modernizr.flexbox) {
  // Якщо браузер підтримує властивість flexbox
} else {
  // Якщо браузер не підтримує властивість flexbox}`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Як підтримувати сторінки в браузерах з обмеженими функціями?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Прогресивне поліпшення (Progressive Enhancement): цей підхід передбачає розробку веб-сторінки, що спочатку працює без JavaScript та інших розширень, а потім поступово додаються додаткові функції, які поліпшують досвід користувача в тих браузерах, які їх підтримують. Наприклад, для форм входу на сайт можна використовувати HTML5, а для додаткових ефектів інші технології, які не обов'язкові для коректної роботи сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `Перевірка браузера та перенаправлення користувача: якщо веб-сторінка використовується в обмеженому браузері, то можна перенаправити користувача на іншу сторінку, яка буде спеціально підготовлена для того, щоб працювати на цьому браузері. Наприклад, якщо користувач використовує Internet Explorer версії 8 або старшої, то можна перенаправити його на сторінку з інформацією про те, як оновити браузер, або на спеціальну версію сайту, яка працює на цьому браузері.`,
          },
          {
            code: false,
            label: '',
            description: `Використання альтернативних технологій: для тих браузерів, які не підтримують певні технології, можна використовувати альтернативні технології. Наприклад, для відео, які не підтримуються старішими версіями браузерів, можна використовувати GIF-анімації або Flash.`,
          },
          {
            code: false,
            label: '',
            description: `Розумна оптимізація: для того, щоб сайт працював на обмежених браузерах, можна провести розумну оптимізацію, яка зменшить кількість`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Як виправляти специфічні проблеми із стилями для різних браузерів?',
        descriptions: [
          {
            code: false,
            label:
              'Існує декілька способів вирішення специфічних проблем із стилями для різних браузерів:',
            description: `Використання префіксів вендора: деякі CSS властивості можуть мати різне синтаксис чи ім'я в різних браузерах. Наприклад, для CSS3-властивостей, таких як border-radius, можна використовувати префікси вендорів (-webkit-, -moz-, -ms-, -o-) для підтримки цих властивостей в різних браузерах.`,
          },
          {
            code: false,
            label: '',
            description: `Використання поліфілів: поліфіли - це JavaScript скрипти, які додають функціональність, яка не підтримується старішими браузерами. Наприклад, для HTML5-властивостей, таких як <canvas> чи <video>, можна використовувати поліфіли, які надають аналогічну функціональність для старіших браузерів.`,
          },
          {
            code: false,
            label: '',
            description: `Використання reset-стилів: різні браузери можуть мати різні стилі за замовчуванням, що може призвести до різних відображень на різних браузерах. Використання reset-стилів, таких як Normalize.css, може забезпечити єдиний базовий стиль для всіх елементів і допомогти уникнути проблем із відображенням.`,
          },
          {
            code: false,
            label: '',
            description: `Тестування на різних браузерах: перед запуском веб-сторінки варто провести тестування на різних браузерах та вирішити проблеми з відображенням та функціоналом на кожному браузері окремо`,
          },
          {
            code: false,
            label: '',
            description: `Використання альтернативних технологій: у деяких випадках можливо використовувати альтернативні технології, які підтримуються у більшості браузерів. Наприклад, замість використання Flash для відтворення відео можна використовувати HTML5 <video> елементи.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Глобальні ключові слова у CSS?',
        descriptions: [
          {
            code: false,
            label:
              'У CSS є декілька глобальних ключових слів, які застосовуються для зміни стилю на рівні сторінки чи на рівні елементів. Ось декілька прикладів:',
            description: `body: стиль, застосований до тіла документа.`,
          },
          {
            code: false,
            label: '',
            description: `html: стиль, застосований до кореневого елемента сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `:root: стиль, застосований до кореневого елемента сторінки, який може бути використаний для зміни значень змінних CSS на рівні сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `*: стиль, застосований до всіх елементів на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `:link: стиль, застосований до незвіданих посилань на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `:visited: стиль, застосований до відвіданих посилань на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `:hover: стиль, застосований до елементів, коли курсор миші наведений на них.`,
          },
          {
            code: false,
            label: '',
            description: `:active: стиль, застосований до елементів, коли вони активовані, наприклад, коли кнопку натиснено.`,
          },
          {
            code: false,
            label: '',
            description: `:focus: стиль, застосований до елементів, коли вони отримують фокус від користувача.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке атрибут CSS (attr)?',
        descriptions: [
          {
            code: false,
            label: 'Що таке атрибут CSS (attr)?',
            description: `attr() - це функція CSS, яка дозволяє отримувати значення HTML-атрибутів і використовувати їх для стилізації елементів на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `Зазвичай, використовують attr() для динамічного встановлення значень стилів на основі атрибутів елемента, наприклад, коліру фону, ширини, висоти, URL-адреси зображення тощо.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, замість того, щоб жорстко встановлювати значення властивості в CSS, можна використовувати значення HTML-атрибута.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, якщо ми маємо HTML-елемент <a> з атрибутом data-color:`,
          },
          {
            code: true,
            label: '',
            description: `<a href="#" data-color="#ff0000">Link</a>`,
          },
          {
            code: false,
            label: '',
            description: `Тоді ми можемо використовувати attr() в CSS для встановлення кольору фону цього елемента на основі значення атрибута data-color:`,
          },
          {
            code: true,
            label: '',
            description: `a {
  background-color: attr(data-color);
}
`,
          },
          {
            code: false,
            label: '',
            description: `Після цього елемент <a> буде мати фоновий колір #ff0000, який був взятий з атрибута data-color.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке перерахування селекторів?',
        descriptions: [
          {
            code: false,
            label: 'Перерахування селекторів',
            description: `Перерахування селекторів - це механізм в CSS, який дозволяє вибирати елементи на основі комбінації декількох селекторів. Це означає, що можна використовувати кілька селекторів разом, щоб змінювати стиль для конкретних елементів на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `Перерахування селекторів використовуються для визначення елементів, які мають одну чи більше спільних властивостей, і дозволяють уникнути повторення коду в CSS. Наприклад, ви можете використовувати перерахування селекторів, щоб вибрати всі елементи <p> з червоним текстом і жирним шрифтом, за допомогою такого CSS-коду:`,
          },
          {
            code: true,
            label: '',
            description: `p.red {
  color: red;
  font-weight: bold;
}
`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі, p - це селектор елементів, який вибирає всі елементи <p>, а .red - це клас, який вибирає елементи з класом "red". Разом ці селектори визначають всі елементи <p> з класом "red" і змінюють їх стиль.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Для чого використовується ключове слово currentColor у CSS?',
        descriptions: [
          {
            code: false,
            label: 'currentColor',
            description: `Ключове слово currentColor у CSS використовується для визначення колірної властивості елемента як поточного кольору тексту.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, якщо ви маєте текст з червоним кольором і хочете встановити колір рамки для елементу div таким же, як у тексті, то можна використовувати currentColor. Для цього потрібно встановити кольорову властивість рамки як border-color: currentColor;.`,
          },
          {
            code: false,
            label: 'Нижче показано приклад використання currentColor:',
            description: ``,
          },
          {
            code: true,
            label: '',
            description: `p {
  color: red;
  border: 1px solid currentColor;
}
`,
          },
          {
            code: true,
            label: '',
            description: `У цьому прикладі, колір тексту для елементу <p> встановлений на червоний, і колір рамки для цього елементу буде також червоний.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які псевдокласи були додані до CSS3?',
        descriptions: [
          {
            code: false,
            label:
              'CSS3 додав багато нових псевдокласів, які розширюють можливості стилізації HTML-документів. Нижче перераховані деякі з них:',
            description: ``,
          },
          {
            code: false,
            label: '',
            description: `:nth-child(n) - вибирає елементи, які є n-тими дочірніми елементами свого батьківського елемента.`,
          },
          {
            code: false,
            label: '',
            description: `:nth-of-type(n) - вибирає елементи, які є n-тим елементом свого типу (тобто, якщо в HTML документі є кілька елементів <p>, то :nth-of-type(2) вибере другий елемент <p>).`,
          },
          {
            code: false,
            label: '',
            description: `:not(selector) - вибирає елементи, які не відповідають заданому селектору.`,
          },
          {
            code: false,
            label: '',
            description: `:checked - вибирає відмічені елементи (наприклад, радіо-кнопки або прапорці).`,
          },
          {
            code: false,
            label: '',
            description: `:hover - вибирає елементи, коли на них наведений курсор миші.`,
          },
          {
            code: false,
            label: '',
            description: `:focus - вибирає елементи, які знаходяться в фокусі.`,
          },
          {
            code: false,
            label: '',
            description: `:first-child - вибирає перший дочірній елемент батьківського елемента.`,
          },
          {
            code: false,
            label: '',
            description: `:last-child - вибирає останній дочірній елемент батьківського елемента.`,
          },
          {
            code: false,
            label: '',
            description: `:nth-last-child(n) - вибирає елементи, які є n-тими дочірніми елементами свого батьківського елемента, рахуючи від кінця.`,
          },
          {
            code: false,
            label: '',
            description: `:empty - вибирає елементи, які не містять жодного дочірнього елемента або тексту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які фільтри є у CSS?',
        descriptions: [
          {
            code: false,
            label: 'CSS фільтри',
            description: ``,
          },
          {
            code: false,
            label: '',
            description: `
CSS має низку фільтрів, які можуть бути застосовані до елементів, щоб змінити їх зовнішній вигляд. Ось декілька прикладів фільтрів, які є доступними в CSS:`,
          },
          {
            code: false,
            label: '',
            description: `brightness() - змінює яскравість зображення.`,
          },
          {
            code: false,
            label: '',
            description: `contrast() - змінює контрастність зображення.`,
          },
          {
            code: false,
            label: '',
            description: `grayscale() - перетворює зображення в чорно-біле.`,
          },
          {
            code: false,
            label: '',
            description: `hue-rotate() - змінює колір зображення, обертаючи його по колу кольорів.`,
          },
          {
            code: false,
            label: '',
            description: `invert() - інвертує кольори зображення.`,
          },
          {
            code: false,
            label: '',
            description: `opacity() - змінює прозорість зображення.`,
          },
          {
            code: false,
            label: '',
            description: `saturate() - змінює насиченість кольорів зображення.`,
          },
          {
            code: false,
            label: '',
            description: `sepia() - перетворює зображення в сепію.`,
          },
          {
            code: false,
            label: '',
            description: `Ці фільтри дозволяють змінювати зовнішній вигляд елементів з CSS. Фільтри можна комбінувати, щоб отримати більш складні ефекти. Використання фільтрів може бути корисним для створення більш привабливих та динамічних веб-дизайнів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Навіщо використовується псевдоклас :invalid?',
        descriptions: [
          {
            code: false,
            label: 'Псевдоклас :invalid',
            description: `Псевдоклас :invalid в CSS використовується для стилізації елементів форм, які не пройшли перевірку на коректність введених даних. Наприклад, якщо користувач ввів неправильний формат електронної адреси в полі введення, елемент буде позначено як :invalid.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою псевдокласу :invalid можна встановити стилі для таких елементів, які не пройшли валідацію. Наприклад, можна встановити кольорову підсвітку для цих елементів, щоб користувач міг з легкістю знайти та виправити помилки.`,
          },
          {
            code: false,
            label: '',
            description: `Основне використання :invalid полягає в тому, щоб зробити форми більш дружелюбними та доступними для користувачів, допомагаючи їм зрозуміти, які поля містять помилки, та вказуючи, як їх можна виправити.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про якість display в CSS?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Властивість display в CSS визначає, як елемент повинен бути відображений на сторінці. Вона впливає на візуальне представлення елементів і на їх розташування на сторінці.`,
          },
          {
            code: false,
            label: 'Основні значення display:',
            description: `block - елемент відображається як блок і займає всю доступну ширину сторінки, починається з нового рядка.`,
          },
          {
            code: false,
            label: '',
            description: `inline - елемент відображається в тексті і не змінює поточного рядка.`,
          },
          {
            code: false,
            label: '',
            description: `inline-block - елемент відображається як блок, але залишається в поточному рядку, якщо це можливо.`,
          },
          {
            code: false,
            label: '',
            description: `flex - елемент відображається як гнучкий контейнер, що дозволяє легко міняти розташування елементів всередині нього.`,
          },
          {
            code: false,
            label: '',
            description: `grid - елемент відображається як контейнер для роботи з CSS-сіткою, яка дозволяє розміщувати елементи у зручний спосіб.`,
          },
          {
            code: false,
            label: '',
            description: `table - елемент відображається як HTML-таблиця.`,
          },
          {
            code: false,
            label: '',
            description: `list-item - елемент відображається як елемент списку.`,
          },
          {
            code: false,
            label: '',
            description: `inline-table - елемент відображається як HTML-таблиця, але залишається в поточному рядку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'У якому разі краще використовувати translate() замість абсолютного позиціонування?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `
Використання функції translate() у CSS дозволяє зміщувати елемент на задану відстань від його поточної позиції без зміни потоку документа. Одним із важливих переваг використання translate() є те, що воно не впливає на місцезнаходження і розміри інших елементів на сторінці, тобто воно не зміщує їх.`,
          },
          {
            code: false,
            label: '',
            description: `З іншого боку, абсолютне позиціонування зміщує елемент відносно його батьківського елемента або відносно вікна браузера. Це може вплинути на позицію і розміри інших елементів на сторінці, оскільки відносини між елементами змінюються.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, використання translate() краще за абсолютне позиціонування у випадках, коли потрібно змістити елемент на задану відстань без зміни розміщення інших елементів на сторінці. Крім того, translate() може бути корисним для анімації, оскільки воно дозволяє зміщувати елементи в заданому напрямку з різною швидкістю. Однак, у випадках, коли потрібно точно розташувати елемент на сторінці і враховувати його відношення до інших елементів, може бути краще використовувати абсолютне позиціонування.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке плаваючі елементи (floats)? Як вони працюють?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Плаваючі елементи (floats) в CSS - це механізм розміщення блоків на веб-сторінці, який дозволяє розмістити блоки один поруч з іншим, при цьому зміщуючи їх відносно стандартного потоку документа.`,
          },
          {
            code: false,
            label: '',
            description: `Проте використання плаваючих елементів може мати певні проблеми, особливо з розмірами і місцем розміщення інших елементів. Наприклад, плаваючі елементи можуть зміщуватися, якщо розмір контенту в них змінюється. Також, якщо всі елементи на сторінці будуть плаваючими, це може призвести до непередбачуваних результатів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про властивість text-rendering?',
        descriptions: [
          {
            code: false,
            label: 'text-rendering',
            description: `Властивість text-rendering в CSS визначає, як браузер рендерить текст на екрані. Зазвичай ця властивість використовується для поліпшення зображення тексту на екрані і для досягнення кращої зручності читання.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, використання властивості text-rendering може бути корисним для покращення якості відображення тексту на екрані і для забезпечення більшої зручності читання.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про властивість text-decoration-skip-ink?',
        descriptions: [
          {
            code: false,
            label: 'text-decoration-skip-ink',
            description: `Задає, як виводити лінію під або над текстом, коли лінія перетинає виносні елементи букв, на кшталт «у», «р», «ц» та ін. Лінія може бути суцільною або перериватися, щоб пропустити «хвостики `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про властивість pointer-events?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Властивість pointer-events в CSS використовується для визначення, як браузер повинен реагувати на події миші та тачпаду для елементів на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про якість outline?',
        descriptions: [
          {
            code: false,
            label: 'outline',
            description: `У CSS властивість outline використовується для встановлення стилю лінії-контурів (англ. outline) для елементів, які визначаються за допомогою CSS. Це може бути корисно для позначення активного елементу, а також для додавання візуального розділення між елементами на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про властивість scrollbar-gutter?',
        descriptions: [
          {
            code: false,
            label: 'scrollbar-gutter',
            description: `Властивість scrollbar-gutter визначає, чи має відображатись прогалина між блоком вмісту та підлоговою панеллю прокрутки (scrollbar). Вона приймає одне з трьох значень:`,
          },
          {
            code: false,
            label: '',
            description: `auto: це значення за замовчуванням. Прогалина буде відображатись, якщо підлогова панель прокрутки з'являється. Якщо панель прокрутки не з'являється, то прогалина не буде відображатись.`,
          },
          {
            code: false,
            label: '',
            description: `none: прогалина не буде відображатись ніколи, навіть якщо панель прокрутки з'являється.`,
          },
          {
            code: false,
            label: '',
            description: `stable: прогалина завжди буде відображатись, незалежно від того, чи з'являється панель прокрутки.`,
          },
          {
            code: false,
            label: '',
            description: `Ця властивість застосовується до контейнера, який містить підлогову панель прокрутки.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Чому не варто використовувати короткий запис властивостей CSS?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Короткий запис властивостей CSS дозволяє встановлювати значення для кількох властивостей одночасно, що може зменшити кількість коду. Однак, існує кілька причин, чому не варто зловживати цим підходом:`,
          },
          {
            code: false,
            label: '',
            description: `Збільшення розміру коду: хоча короткий запис зменшує кількість коду для окремих властивостей, він може збільшити загальний розмір CSS-файлу, оскільки він містить всі властивості в одному місці.`,
          },
          {
            code: false,
            label: '',
            description: `Складність налагодження: коли використовується короткий запис, важче відстежувати властивості і знайти помилки. Також, коли потрібно змінити лише одну властивість, необхідно знайти та відредагувати весь запис.`,
          },
          {
            code: false,
            label: '',
            description: `Зрозумілість коду: коли короткий запис використовується надмірно, код може стати складним для розуміння, особливо для новачків. Велика кількість скорочень може зробити код менш зрозумілим та менш придатним для підтримки.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Назвіть псевдоелементи для підсвічування тексту?',
        descriptions: [
          {
            code: false,
            label: 'Псевдоелементи для підсвічування тексту',
            description: `::selection - застосовує стилі до тексту, який було виділено користувачем на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `::placeholder - застосовує стилі до текстового вмісту плейсхолдера в полях вводу, наприклад, в <input> або <textarea>.`,
          },
          {
            code: false,
            label: '',
            description: `Обидва псевдоелементи дозволяють змінювати кольори, фон, шрифт тощо для виділеного тексту або тексту в плейсхолдері, що може допомогти зробити сторінку більш естетично привабливою та зручною для користувачів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Способи завдання кольору CSS?',
        descriptions: [
          {
            code: false,
            label: 'У CSS існує кілька способів завдання кольору:',
            description: `Назви кольорів: CSS містить список іменованих кольорів, таких як red, blue, green тощо.`,
          },
          {
            code: false,
            label: '',
            description: `HEX код: HEX-код - це шістнадцяткове число, яке представляє колір. Кожен HEX-код складається з # та 6 цифр, які представляють червоний, зелений та синій кольори (наприклад, #000000 означає чорний колір).`,
          },
          {
            code: false,
            label: '',
            description: `RGB: RGB - це скорочення від "Red Green Blue". Кожен колір можна описати червоною, зеленою та синьою складовими, де значення можуть бути від 0 до 255 (наприклад, rgb(255, 0, 0) означає червоний колір).`,
          },
          {
            code: false,
            label: '',
            description: `RGBA: RGBA - це версія RGB, яка дозволяє додавати прозорість до колірів. RGBA має 4 складові, де альфа (opacity) задається числом від 0 до 1 (наприклад, rgba(255, 0, 0, 0.5) означає напівпрозорий червоний колір).`,
          },
          {
            code: false,
            label: '',
            description: `RGBA: RGBA - це версія RGB, яка дозволяє додавати прозорість до колірів. RGBA має 4 складові, де альфа (opacity) задається числом від 0 до 1 (наприклад, rgba(255, 0, 0, 0.5) означає напівпрозорий червоний колір).`,
          },
          {
            code: false,
            label: '',
            description: `HSLA: HSLA - це версія HSL, яка дозволяє додавати прозорість до колірів. HSLA має 4 складові, де альфа (opacity) задається числом від 0 до 1 (наприклад, hsla(0, 100%, 50%, 0.5) означає напівпрозорий чистий червоний колір).`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Технологія BEM',
        descriptions: [
          {
            code: false,
            label: 'Технологія BEM',
            description: `Основна ідея BEM полягає в тому, що кожен елемент сторінки повинен мати свій власний ідентифікатор класу, який повинен відображати його призначення та структуру. У BEM використовуються наступні три типи ідентифікаторів класів: `,
          }, {
            code: false,
            label: '',
            description: `Block (Блок) - це найвищий рівень ієрархії, який відображає основний контейнер елемента. Блок може містити один або декілька елементів. Наприклад, блок "menu" може містити елементи "menu__item" і "menu__link".`,
          }, {
            code: false,
            label: '',
            description: `Element (Елемент) - це другий рівень ієрархії, який відображає конкретний елемент в межах блоку. Елемент повинен бути пов'язаний зі своїм блоком. Наприклад, елемент "menu__item" може містити елементи "menu__item-title" і "menu__item-icon".`,
          }, {
            code: false,
            label: '',
            description: `Modifier (Модифікатор) - це ідентифікатор, який дозволяє змінювати вигляд блоку або елемента. Модифікатори можуть бути застосовані до блоків або елементів. Наприклад, модифікатор "menu__item--active" може вказувати на активний пункт меню.`,
          }, {
            code: true,
            label: 'Для прикладу розглянемо структуру блоку "menu" з використанням BEM:',
            description: `<nav class="menu">
  <ul class="menu__list">
    <li class="menu__item menu__item--active">
      <a href="#" class="menu__link">Головна</a>
    </li>
    <li class="menu__item">
      <a href="#" class="menu__link">Про нас</a>
    </li>
    <li class="menu__item">
      <a href="#" class="menu__link">Контакти</a>
    </li>
  </ul>
</nav>`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі блок "menu" має клас "menu", що вказує на те, що це блок. Крім того, блок має елемент "menu__list", який відображає список елементів меню. Елементи списку "menu__item" містять посилання "menu__link". Перший пункт меню "menu__item--active" використовує модифікатор, що вказує на його активний стан.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Styled Components ',
        descriptions: [
          {
            code: false,
            label: 'Styled Components',
            description: `Styled Components - це бібліотека для React та React Native, яка дозволяє створювати компоненти з вбудованими стилями, які можуть бути перевикористані та підтримувані легше за традиційний CSS.`,
          }, {
            code: false,
            label: '',
            description: `За допомогою Styled Components можна описувати стилі для компонентів, використовуючи техніку CSS-in-JS. Це означає, що стилі компонентів пишуться за допомогою спеціальної синтаксичної нотації, яка дозволяє вбудовувати змінні, обчислення та інші функції в стилі.`,
          }, {
            code: true,
            label: 'Наприклад, опис стилів для кнопки з використанням Styled Components може виглядати наступним чином:',
            description: `import styled from 'styled-components';

const Button = styled.button\`
  background-color: $ {props => props.primary ? 'blue' : 'white'};
  color: $ {props => props.primary ? 'white' : 'blue'};
  border: 2px solid blue;
  border-radius: 4px;
  font-size: 16px;
  padding: 10px 20px;
  cursor: pointer;
\`;

export default Button;`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі ми створюємо компонент "Button", який описується за допомогою функції "styled.button". Використовуючи рядок-шаблон (\`\`), ми задаємо стилі для кнопки. При цьому використовуються змінні зі спеціальним синтаксисом $ {...}, які дозволяють вбудовувати значення пропсів та інші змінні в стилі.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Princeples',
    questions: [
      {
        id: generateUUID(),
        question: 'OOП',
        descriptions: [
          {
            code: false,
            label: 'OOП',
            description: `Коли йдеться про об'єктно-орієнтоване програмування - мається на увазі моделювання реальних об'єктів і відносин.`,
          },
          {
            code: false,
            label: ``,
            description: `В ООП об'єкт є блоком, що містить інформацію (стан / атрибути) та операції (методи).`,
          },
          {
            code: false,
            label: `Ключове слово this`,
            description: `• this- Це об'єкт, властивістю якого є функція;`,
          },
          {
            code: false,
            label: ``,
            description: `• this- дає функцій доступ до свого об'єкту та його властивостей;`,
          },
          {
            code: false,
            label: ``,
            description: `• this- допомагає виконати той самий код для кількох об'єктів;`,
          },
          {
            code: false,
            label: ``,
            description: `• this- Чи можна розглядати як хто мене викликав? ; тобто. те, що знаходиться ліворуч від точки. Наприклад, window.a();`,
          },
          {
            code: false,
            label: ``,
            description: `• this- має динамічну область , тобто не важливо, де він був написаний, важливо, де він був викликаний.`,
          },
          {
            code: true,
            label: ``,
            description: `
            const obj = {
              name: 'Alex',
              sing() {
                console.log('a this ', this);
                var anotherFunc = function() {
                  console.log('b this ', this);
                }
                anotherFunc();
              }
            };
            
            obj.sing();
            
            // a this  {name: "Alex", sing: ƒ}
            // b this  Window {parent: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}
            `,
          },
          {
            code: true,
            label: ``,
            description: `
            var b = {
              name: 'jay',
              say() {
                console.log('this is ', this);
              }
            }
            b.say()
            // this is  {name: "jay", say: ƒ}
            
            var c = {
              name: 'jay',
              say() {
                return function () {
                  console.log('this is ', this);
                }
              }
            }
            c.say()()
            // this is  Window {parent: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}
            
            var d = {
              name: 'jay',
              say() {
                // стрілочна функція не мають власного контексту виконання.
                return () => console.log('this is ', this);
              }
            }
            d.say()()
            // this is  {name: "jay", say: ƒ}
            `,
          },
          {
            code: false,
            label: ``,
            description: `Стрілецькі функції пов'язують this з лексичною областю дії .`,
          },
          {
            code: true,
            label: ``,
            description: `
            const obj = {
              name: 'Alex',
              sing() {
                console.log('a this ', this);
                var anotherFunc = () => {
                  console.log('b this ', this);
                }
                anotherFunc();
              }
            };
            
            obj.sing();
            
            // a this  {name: "Alex", sing: ƒ}
            // b this  {name: "Alex", sing: ƒ}
            `,
          },
          {
            code: false,
            label: `Прототип`,
            description: `• Прототип (prototype) – це екземпляр робочого об'єкта. Об'єкти успадковуються безпосередньо з інших об'єктів.`,
          },
          {
            code: false,
            label: ``,
            description: `• __proto__ є посиланням на властивість прототипу батьківського об'єкта, наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            const obj = {};
            obj.__proto__ === Object.prototype // true
            `,
          },
          {
            code: false,
            label: ``,
            description: `• Властивість prototype належить лише функцій, зокрема, функцій конструктора. Конструктор Object створює обгортку об'єкта.`,
          },
          {
            code: false,
            label: ``,
            description: `• Властивості proto і prototype використовуються створення ланцюжка успадкування властивостей між об'єктами, починаючи з Object і Primitive Types .`,
          },
          {
            code: false,
            label: ``,
            description: `• Object.create() можна використовувати створення об'єктів з його властивістю proto , що з властивістю prototype об'єкта, переданого як аргумент Object.create().`,
          },
          {
            code: false,
            label: ``,
            description: `• Object – це базова функція (конструктор). Коренем всього JavaScript є Object , який насправді є функцією.`,
          },
          {
            code: true,
            label: ``,
            description: `typeof Object // "function"`,
          },
          {
            code: false,
            label: ``,
            description: `Object має властивість prototype , яке є базовим об'єктом для всіх речей JavaScript, включаючи функції JavaScript.`,
          },
          {
            code: true,
            label: ``,
            description: `typeof Object.prototype // "object"`,
          },
          {
            code: false,
            label: `ES6 Класи`,
            description: ``,
          },
          {
            code: false,
            label: ``,
            description: `• Ключове слово class в JS – синтаксичний цукор. Під капотом він все ще використовує прототипне наслідування (prototypal inheritance).`,
          },
          {
            code: false,
            label: ``,
            description: `• Примірники класу повинні створюватись із ключовим словом new .`,
          },
          {
            code: false,
            label: ``,
            description: `• Метод constructor використовується для створення екземпляра state (даних) нового об'єкта . State зазвичай унікальна для кожного екземпляра .`,
          },
          {
            code: false,
            label: ``,
            description: `• Функції зазвичай не включаються до конструктора , оскільки вони створюють посилання на місце в пам'яті в кожному новому екземплярі класу . Таким чином, використовуючи більше пам'яті, ніж необхідно. Включаючи функції як методи класу , екземпляри класу можуть посилатися на функцію через ланцюжок прототипів .`,
          },
          {
            code: false,
            label: ``,
            description: `• Прототипне успадкування (prototypal inheritance) має кращу ефективність пам'яті, ніж класичне успадкування завдяки тому, що воно поділяє посилання пам'яті своїх властивостей прототипу з тими об'єктами , які успадковують від нього. У класичному успадкування екземпляри класу створюють нові посилання на згадку для кожної успадкованої властивості .`,
          },
          {
            code: false,
            label: `Object.create() vs. Classes`,
            description: `• Обидва Object.create() і classє способами створення ланцюжка прототипів .`,
          },
          {
            code: false,
            label: ``,
            description: `• Деякі люди воліють уникати ключові слова constructor , class і this , щоб обмежити плутанину через this .`,
          },
          {
            code: false,
            label: ``,
            description: `• Інші вважають за краще використовувати ключові слова constructor , class і this , можливо, через його схожість з іншими мовами з парадигмою об'єктно-орієнтованого програмування.`,
          },
          {
            code: false,
            label: `Private vs. Public vs. Protected`,
            description: `У багатьох об'єктно-орієнтованих мовах програмування, які мають класи, ідея private та public полів справді важлива. JavaScript цього немає. Раніше, якщо потрібно було зробити поле private , до якого не можна звертатися з класу, ми додавали підкреслення _перед ім'ям, щоб інші програмісти знали, що це private метод. Але, на жаль, наголошення насправді нічого не робить.`,
          },
          {
            code: false,
            label: ``,
            description: `JavaScript має пропозицію ECMAScript, яка призначена для оголошень полів класу .`,
          },
          {
            code: false,
            label: ``,
            description: `Це модифікатори доступу, які допомагають нам реалізувати Encapsulation (або приховування інформації). Вони повідомляють компілятор, які інші класи повинні мати доступ до певного поля або методу.`,
          },
          {
            code: false,
            label: ``,
            description: `Private - тільки поточний клас матиме доступ до поля чи методу. Protected - тільки поточний клас та підкласи цього класу матимуть доступ до поля чи методу. Public – будь-який клас може посилатися на поле або викликати метод.`,
          },
          {
            code: false,
            label: ``,
            description: `Оскільки Javascript таких полів поки немає, їх реалізації ми можемо використовувати TypeScript .`,
          },
          {
            code: false,
            label: `4 принципи ОOП`,
            description: ``,
          },
          {
            code: false,
            label: `Інкапсуляція`,
            description: `Інкапсуляція включає ідею про те, що дані об'єкта не повинні бути безпосередньо доступні. Потрібно викликати методи замість прямого доступу до даних. Інкапсуляція дозволяє нам приховувати/показувати властивості функцій.`,
          },
          {
            code: false,
            label: ``,
            description: `ООП укладаємо код у блоки, які пов'язані один з одним, щоб ці блоки могли просто взаємодіяти один з одним, використовуючи методи та властивості, які ми робимо доступними. Цей принцип робить код простіше в обслуговуванні та більш придатним для повторного використання.`,
          },
          {
            code: true,
            label: `Інкапсуляція з використанням замикання`,
            description: `
            const createCounter = () => {
              // Змінна, визначена в області дії фабрики або конструктора
              // є приватною для цієї функції.  
              let count = 0;
            
              return ({
                // Будь-які інші функції, визначені в тій самій області, є привілейованими:
                // Вони мають доступ до закритої змінної 'count'
                // визначеної в будь-якому місці їхнього ланцюжка областей видимості (що містить області дії функції).
                click: () => count += 1,
                getCount: () => count.toLocaleString()
              });
            };
            
            const counter = createCounter();
            
            counter.click();
            counter.click();
            counter.click();
            
            console.log(counter.getCount()); // "3"
            `,
          },
          {
            code: false,
            label: `Абстракція`,
            description: `Абстракція - це спосіб створення простої моделі, яка містить лише важливі властивості з погляду контексту додатку, з більш складної моделі. Іншими словами - це спосіб приховати деталі реалізації та показати користувачам лише функціональність. Абстракція ігнорує нерелевантні деталі та показує лише необхідні. Важливо пам'ятати, що ми можемо створити екземпляр абстрактного класу.`,
          },
          {
            code: false,
            label: ``,
            description: `Все програмне забезпечення – це абстракція, що приховує всю важку роботу та бездумні деталі.`,
          },
          {
            code: false,
            label: ``,
            description: `Багато програмних процесів повторюються знову і знову. Тому, на етапі декомпозиції проблеми, ми видалимо дублювання, записуючи якийсь компонент (функцію, модуль, клас тощо. буд.), привласнюючи йому ім'я (ідентифікатор) і повторно використовуючи його стільки разів, скільки потрібно.`,
          },
          {
            code: false,
            label: ``,
            description: `Процес декомпозиції – це процес абстракції. Успішна абстракція має на увазі, що результатом є набір незалежно корисних та перекомпонованих компонентів.`,
          },
          {
            code: false,
            label: `Поліморфізм`,
            description: `Поліморфізм є одним із принципів об'єктно-орієнтованого програмування (ООП). Це допомагає проектувати об'єкти таким чином, щоб вони могли спільно використовувати або перевизначати будь-яку поведінку з наданими конкретними об'єктами.`,
          },
          {
            code: false,
            label: ``,
            description: `Саме слово означає багато форм. Існує багато тлумачень того, що саме воно означає, але ідея полягає в здатності викликати той самий метод для різних об'єктів, і при цьому кожен об'єкт реагує по-своєму.`,
          },
          {
            code: false,
            label: ``,
            description: `Щоб це сталося, поліморфізм використовує успадкування .`,
          },
          {
            code: false,
            label: ``,
            description: `У наступному прикладі дочірній об'єкт, такий як Coder, перевизначає метод say, викликаний з батьківського об'єкта Human, і повертає новий рядок відповідно. Тоді як інший дочірній об'єкт Menзамість перевизначення методу sayуспадковує його і відображав батьківський рядок.`,
          },
          {
            code: true,
            label: ``,
            description: `
            class Human {
              constructor(name) {
                this.name = name;
              }
            
              say() {
                return 'Hello, my name is $ {this.name}, I like travelling';
              }
            }
            
            class Men extends Human {
              constructor(name) {
                super(name)
              }
              // Беремо метод say у батька.
            }
            
            class Coder extends Human {
              constructor(name) {
                super(name)
              }
            
              say() {
                // Перевизначаємо метод батька say для відображення нового значення.
                return 'Hello, my name is $ {this.name}, I like coding';
              }
            }
            
            const alex = new Men('Alex');
            const leo = new Coder('Leo');
            
            alex.say() // "Hello, my name is Alex, I like travelling"
            leo.say() // "Hello, my name is Leo, I like coding"`,
          },
          {
            code: false,
            label: `Успадкування`,
            description: `Спадкування - це механізм базування об'єкта або class на іншому об'єкті (спадкування на основі прототипу) або class (спадкування на основі класу). Ми уникаємо необхідності переписувати той самий код, а також економимо простір пам'яті, використовуючи загальні методи.`,
          },
          {
            code: true,
            label: ``,
            description: `
            class Human {
              constructor(name) {
                this.name = name;
              }
            
              sayMyName() {
                return 'Hello, I am ' + this.name;
              }
            }
            
            class Men extends Human {
              constructor(name) {
                super(name)
              }
            }
            class Coder extends Human {
              constructor(name) {
                super(name)
              }
            }
            
            const alex = new Men('Alex');
            const leo = new Coder('Leo');
            
            alex.sayMyName() // Hello, I am Alex
            leo.sayMyName() // Hello, I am Leo`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'SOLID',
        descriptions: [
          {
            code: false,
            label: `SOLID`,
            description: `SOLID - це п'ять основних принципів ООП, які визначають, як добре сконструйована архітектура програми з точки зору розширення та підтримки коду.`,
          },
          {
            code: false,
            label: ``,
            description: `Хоча ці принципи спочатку були визначені для мови програмування Java, вони також можуть бути застосовані до JavaScript.`,
          },
          {
            code: false,
            label: `Ось короткий огляд кожного з принципів SOLID та їх застосування в JavaScript:`,
            description: ``,
          },
          {
            code: false,
            label: `Принцип єдиного обов'язку (Single Responsibility Principle, SRP)`,
            description: `1. Принцип однієї відповідальності (Single Responsibility Principle - SRP)
            Клас або функція повинна мати лише одну відповідальність. Це допомагає зберегти код більш організованим та зрозумілим.`,
          },
          {
            code: true,
            label: ``,
            description: `
            // Клас з багатьма обов'язками:
            class User {
              constructor(name, email) {
                this.name = name;
                this.email = email;
              }

              getName() {
                return this.name;
              }

              getEmail() {
                return this.email;
              }

              sendEmail(subject, body) {
                // Відправляє електронний лист з вказаним тілом та темою.
              }

              saveToDatabase() {
                // Зберігає користувача в базу даних.
              }
            }

            // Перероблений клас з одним обов'язком:
            class User {
              constructor(name, email) {
                this.name = name;
                this.email = email;
              }

              getName() {
                return this.name;
              }

              getEmail() {
                return this.email;
              }
            }

            class EmailService {
              sendEmail(user, subject, body) {
                // Відправляє електронний лист з вказаним тілом та темою.
              }
            }

            class DatabaseService {
              saveUser(user) {
                // Зберігає користувача в базу даних.
              }
            }
            `,
          },
          {
            code: false,
            label: `Принцип відкритості/закритості (Open/Closed Principle - OCP)`,
            description: `Принцип відкритості/закритості (Open/Closed Principle - OCP)
            Класи та функції повинні бути відкриті для розширення, але закриті для змін. Це означає, що ви можете додавати нові функціональності, не змінюючи існуючий код.`,
          },
          {
            code: true,
            label: ``,
            description: `
            // Клас, який порушує принцип відкритості/закритості:
            class Shape {
              constructor(type) {
                this.type = type;
              }

              getType() {
                return this.type;
              }

              getArea() {
                // Визначає площу геометричної фігури.
              }
            }

            // Перероблений клас, який дотримується принципу відкритості/закритості:
            class Shape {
              constructor(type) {
                this.type = type;
              }

              getType() {
                return this.type;
              }
            }

            class Rectangle extends Shape {
              constructor(width, height) {
                super('rectangle');
                this.width = width;
                this.height = height;
              }

              getArea() {
                return this.width * this.height;
              }
            }

            class Circle extends Shape {
              constructor(radius) {
                super('circle');
                this.radius = radius;
              }

              getArea() {
                return Math.PI * this.radius * this.radius;
              }
            }
            `,
          },
          {
            code: false,
            label: `Liskov Substitution Principle - LSP`,
            description: `Принцип заміщення Лісков (Liskov Substitution Principle - LSP)
            Підкласи повинні бути замінювані своїми батьківськими класами. Це означає, що клас або функція не повинні змінювати поведінку підкласів.`,
          },
          {
            code: false,
            label: ``,
            description: `За принципом Liskov Substitution Principle класи повинні бути замінювані їх підкласами без зміни коректності програми. Для цього необхідно дотримуватися одного з основних правил: підклас не може змінювати поведінку методів базового класу.
            Ось приклад коду, який ілюструє принцип Liskov Substitution:`,
          },
          {
            code: true,
            label: ``,
            description: `
            class Rectangle {
              constructor(width, height) {
                this.width = width;
                this.height = height;
              }
            
              setWidth(width) {
                this.width = width;
              }
            
              setHeight(height) {
                this.height = height;
              }
            
              getArea() {
                return this.width * this.height;
              }
            }
            
            class Square extends Rectangle {
              constructor(size) {
                super(size, size);
              }
            
              setWidth(width) {
                this.width = width;
                this.height = width;
              }
            
              setHeight(height) {
                this.height = height;
                this.width = height;
              }
            }
            
            function calculateArea(rectangle) {
              rectangle.setWidth(3);
              rectangle.setHeight(4);
              return rectangle.getArea();
            }
            
            const rectangle = new Rectangle(5, 6);
            console.log(calculateArea(rectangle)); // Виводить 12
            
            const square = new Square(5);
            console.log(calculateArea(square)); // Очікується, що виведе 25, але виводить 12
            `,
          },
          {
            code: false,
            label: ``,
            description: `В цьому прикладі, клас Square наслідується від класу Rectangle. Проте методи setWidth та setHeight змінюють поведінку, що порушує принцип Liskov Substitution. В результаті, метод calculateArea поводиться неочікувано при використанні об'єкта Square, який має однакову ширину та висоту, а не відрізняється як у випадку з Rectangle.`,
          },
          {
            code: false,
            label: `Принцип інверсії залежності (Dependency Inversion Principle - DIP)`,
            description: `Принцип інверсії залежності (Dependency Inversion Principle - DIP)
            Класи повинні залежати від абстракцій, а не від конкретних реалізацій. Це означає, що ви повинні створювати інтерфейси для взаємодії з об'єктами, а не прив'язуватися до конкретних реалізацій.`,
          },
          {
            code: false,
            label: ``,
            description: `Принцип інверсії залежності (Dependency Inversion Principle - DIP) передбачає, що модулі високого рівня не повинні залежати від модулів низького рівня. Вони повинні залежати від абстракцій, а не від конкретних реалізацій. Крім того, деталі повинні залежати від абстракцій, а не навпаки.
            Ось приклад коду, де принцип DIP використовується для зменшення залежності модулів:`,
          },
          {
            code: true,
            label: ``,
            description: `class Database {
              constructor() {
                this.data = [];
              }
            
              add(item) {
                this.data.push(item);
              }
            
              getAll() {
                return this.data;
              }
            }
            
            class Logger {
              constructor() {}
            
              log(message) {
                console.log(message);
              }
            }
            
            class User {
              constructor(database, logger) {
                this.database = database;
                this.logger = logger;
              }
            
              create(username) {
                this.database.add({ username });
                this.logger.log('User $ {username} created');
              }
            }
            
            const database = new Database();
            const logger = new Logger();
            const user = new User(database, logger);
            
            user.create("John"); // User John created
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі клас User залежить від класів Database та Logger. Однак, використовуючи принцип DIP, ми можемо зменшити залежність User від цих класів, передаючи їм абстракції замість конкретних реалізацій. Ми можемо створити інтерфейси IDatabase та ILogger та передавати їх у конструктор класу User. Таким чином, ми можемо змінювати реалізацію Database та Logger без впливу на клас User:`,
          },
          {
            code: true,
            label: ``,
            description: `
            class IDatabase {
              constructor() {}
            
              add(item) {}
            
              getAll() {}
            }
            
            class ILogger {
              constructor() {}
            
              log(message) {}
            }
            
            class Database extends IDatabase {
              constructor() {
                super();
                this.data = [];
              }
            
              add(item) {
                this.data.push(item);
              }
            
              getAll() {
                return this.data;
              }
            }
            
            class Logger extends ILogger {
              constructor() {}
            
              log(message) {
                console.log(message);
              }
            }
            
            class User {
              constructor(database, logger) {
                this.database = database;
                this.logger = logger;
              }
            
              create(username) {
                this.database.add({ username });
                this.logger.log('User $ {username} created');
              }
            }
            
            const database = new Database();
            const logger = new Logger();
            const user = new User(database, logger);
            
            user.create("John"); // User John created
            `,
          },
          {
            code: false,
            label: `Принцип розділення інтерфейсу (Interface Segregation Principle - ISP)`,
            description: `Принцип розділення інтерфейсу стверджує, що клієнти не повинні залежати від методів, які вони не використовують. Цей принцип підтримує розділення великих інтерфейсів на менші та специфічніші, щоб клієнти могли залежати лише від тих методів, які їм потрібні.

            Розглянемо приклад коду:`,
          },
          {
            code: true,
            label: ``,
            description: `
            interface IWorker {
              doWork(): void;
              getSalary(): number;
              hireDate(): Date;
              fireDate(): Date;
            }
            `,
          },
          {
            code: false,
            label: ``,
            description: `В даному інтерфейсі реалізовано чотири методи: doWork(), getSalary(), hireDate() та fireDate(). Проте, в реальному додатку, можуть бути використані не всі ці методи. Для виконання принципу ISP, ми можемо розділити інтерфейс на більш специфічні, які будуть використовуватись окремо:`,
          },
          {
            code: true,
            label: ``,
            description: `interface IWorker {
              doWork(): void;
            }
            
            interface ISalary {
              getSalary(): number;
            }
            
            interface IEmployment {
              hireDate(): Date;
              fireDate(): Date;
            }
            `,
          },
          {
            code: false,
            label: ``,
            description: `Тепер, якщо потрібен лише доступ до методу doWork(), можна залежати лише від інтерфейсу IWorker, що спрощує код та зменшує його залежності від непотрібних методів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'OOD',
        descriptions: [
          {
            code: false,
            label: `OOD`,
            description: `OOD означає Об'єктно-орієнтоване проектування (Object-Oriented Design). Це методологія проектування програмного забезпечення, яка базується на концепції об'єктів і класів. OOD надає можливість розбити програму на невеликі модулі, кожен з яких може мати власний стан, поведінку та взаємодію з іншими модулями. Це дозволяє полегшити розробку, тестування та підтримку коду.`,
          },
          {
            code: false,
            label: ``,
            description: `ООД - це об'єктно-орієнтований дизайн. Основні принципи ООД допомагають розробникам створювати більш ефективні, гнучкі, масштабовані та повторно використовувані програми.`,
          },
          {
            code: false,
            label: ``,
            description: `Ось декілька прикладів використання ООД в програмуванні:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Створення класів та об'єктів для представлення реальних об'єктів або процесів в програмі. Наприклад, у програмі замовлення є клас "Замовлення", що містить властивості, такі як ім'я клієнта, сума замовлення та дата замовлення.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Використання інкапсуляції для захисту даних від неправильного використання. Наприклад, в класі "Замовлення" можна використовувати приватні поля, які не можна змінювати ззовні, щоб запобігти помилкам введення даних.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Використання поліморфізму для створення більш гнучких програм. Наприклад, в програмі замовлення можуть бути різні типи замовлень, які наслідують клас "Замовлення", але мають додаткові властивості або методи.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Використання наслідування для створення нових класів на основі вже існуючих. Наприклад, у програмі замовлення можна створити новий клас "Оплата з кредитної карти", який наслідує клас "Замовлення", але має додаткові методи та властивості для обробки оплати.`,
          },
          {
            code: false,
            label: ``,
            description: `5. Використання абстракції для представлення складних систем та процесів. Наприклад, в програмі замовлення можна використовувати абстрактний клас "Платіж", який містить загальну логіку для обробки оплати, а потім створювати конкретні класи для різних методів оплати.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'KISS',
        descriptions: [
          {
            code: false,
            label: `KISS`,
            description: `KISS - Keep It Simple, Stupid - це принцип проектування, який заохочує розробників до створення простих і зрозумілих рішень замість складних і складних. Основна ідея полягає в тому, що більш прості рішення часто є кращими, надійнішими та легшими для зрозуміння, зміни та супроводження.`,
          },
          {
            code: false,
            label: `Ось кілька прикладів використання принципу KISS:`,
            description: `1. Створення простого та прямолінійного інтерфейсу користувача для веб-сайту або додатку, щоб забезпечити легкий доступ до функцій та можливостей.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Використання простих алгоритмів у веб-розробці замість складних та глибоких аналізів, які можуть затримати роботу сайту.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Використання простих структур даних, таких як масиви та об'єкти, замість складних ієрархій та пов'язаних списків, що допомагає зменшити складність коду та покращити його читабельність.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Створення простих тестових сценаріїв для перевірки функцій додатку, забезпечення їх простоти та легкої змінності.`,
          },
          {
            code: false,
            label: ``,
            description: `5. Використання простих та лаконічних імен змінних, функцій та класів для полегшення зрозуміння коду та його супроводження.`,
          },
          {
            code: false,
            label: `Приклади в коді JS використання принципу KISS:`,
            description: ``,
          },
          {
            code: true,
            label: `1. Перевірка на наявність елемента в масиві`,
            description: `
            // Завдання: перевірити, чи є в масиві numbers число 5
            // Поганий варіант:
            let isFiveInArray = false;
            for (let i = 0; i < numbers.length; i++) {
              if (numbers[i] === 5) {
                isFiveInArray = true;
                break;
              }
            }

            // Кращий варіант:
            let isFiveInArray = numbers.includes(5);
            `,
          },
          {
            code: false,
            label: ``,
            description: `В цьому прикладі, принцип KISS застосований шляхом використання методу includes замість складної ручної перевірки наявності елемента в масиві.`,
          },
          {
            code: true,
            label: `2. Створення об'єкта з даними`,
            description: `
            // Завдання: створити об'єкт person з ім'ям, віком та адресою
            // Поганий варіант:
            let person = new Object();
            person.name = "John";
            person.age = 30;
            person.address = new Object();
            person.address.street = "Main St";
            person.address.city = "New York";
            person.address.state = "NY";
            person.address.zip = "10001";

            // Кращий варіант:
            let person = {
              name: "John",
              age: 30,
              address: {
                street: "Main St",
                city: "New York",
                state: "NY",
                zip: "10001"
              }
            };
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі, принцип KISS застосовується шляхом створення об'єкта person з простою структурою даних в одному рядку, замість ручного створення об'єкта та його властивостей.`,
          },
          {
            code: true,
            label: `3. Використання вбудованих методів для простих операцій з масивами:`,
            description: `
            // Приклад поганого коду без використання методів масиву:
            let numbers = [2, 4, 6, 8, 10];
            let sum = 0;
            for (let i = 0; i < numbers.length; i++) {
              sum += numbers[i];
            }

            // Приклад кращого коду з використанням методу reduce:
            let numbers = [2, 4, 6, 8, 10];
            let sum = numbers.reduce((total, current) => total + current);
            `,
          },
          {
            code: true,
            label: `4. Використання шаблонних рядків для форматування рядків:`,
            description: `
            // Приклад поганого коду без використання шаблонних рядків:
            let firstName = "John";
            let lastName = "Doe";
            let age = 30;
            let message = "My name is " + firstName + " " + lastName + " and I am " + age + " years old.";

            // Приклад кращого коду з використанням шаблонних рядків:
            let firstName = "John";
            let lastName = "Doe";
            let age = 30;
            let message = 'My name is $ {firstName} $ {lastName} and I am $ {age} years old.';

            `,
          },
          {
            code: true,
            label: `5. Проста функція обробки рядків:`,
            description: `
            // Погано:
            function processString(string) {
              const reversedString = string.split('').reverse().join('');
              const uppercaseString = reversedString.toUpperCase();
              const shortenedString = uppercaseString.substring(0, 10);
              return shortenedString;
            }

            // Добре:
            function processString(string) {
              return string.slice(0, 10).toUpperCase().split('').reverse().join('');
            }
            `,
          },
          {
            code: true,
            label: `6. Проста функція для додавання класів до елементу DOM::`,
            description: `
            // Погано:
            function addClasses(element, classes) {
              classes.forEach(className => {
                element.classList.add(className);
              });
            }
            
            // Добре:
            function addClasses(element, classes) {
              element.classList.add(...classes);
            }
            `,
          },
          {
            code: false,
            label: ``,
            description: `Ці приклади демонструють те, як простіші і менш складні функції можуть зробити код більш зрозумілим і підтримуваним.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'DRY',
        descriptions: [
          {
            code: false,
            label: `DRY`,
            description: `DRY - Don't Repeat Yourself - це принцип розробки програмного забезпечення, який закликає до того, щоб не дублювати код і замість цього використовувати повторно вже існуючий код. Це дозволяє зменшити кількість коду в проекті, зменшити його складність, збільшити швидкість розробки та знизити ймовірність помилок.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, замість дублювати код створення підключення до бази даних в кожному модулі проекту, можна створити окремий модуль, який буде містити цей код, і використовувати його в кожному модулі, де потрібне підключення до бази даних.`,
          },
          {
            code: false,
            label: `Ось ще декілька прикладів використання принципу DRY в коді JS:`,
            description: `1. Використання функцій для уникнення дублювання коду. Наприклад, якщо в проекті є декілька місць, де потрібно виконувати одну і ту ж операцію, можна створити окрему функцію, яка буде виконувати цю операцію, і використовувати її в кожному місці, де потрібно виконати цю операцію.`,
          },
          {
            code: true,
            label: ``,
            description: `
            // поганий приклад без використання DRY
            let width = 10;
            let height = 20;
            let area = width * height;
            let perimeter = 2 * (width + height);

            // добрий приклад з використанням DRY
            function rectangle(width, height) {
              let area = width * height;
              let perimeter = 2 * (width + height);
              return { area, perimeter };
            }

            let rect = rectangle(10, 20);
            console.log(rect.area); // виведе 200
            console.log(rect.perimeter); // виведе 60
            `,
          },
          {
            code: true,
            label: `2.Виділення повторюваного коду в окрему функцію`,
            description: `// Повторюваний код
            function calculateArea(width, height) {
              return width * height;
            }
            
            console.log(calculateArea(10, 5)); // 50
            console.log(calculateArea(7, 3)); // 21
            
            // Використання функції замість повторюваного коду
            function calculateVolume(length, width, height) {
              return length * calculateArea(width, height);
            }
            
            console.log(calculateVolume(2, 10, 5)); // 100
            console.log(calculateVolume(3, 7, 3)); // 63
            `,
          },
          {
            code: true,
            label: `3. Використання змінних для зберігання значень, які повторюються:`,
            description: `// Повторюваний код
            console.log("Hello, " + name + "!");
            console.log("Welcome, " + name + "!");
            
            // Використання змінних для зберігання повторюваних значень
            var greeting = "Hello, " + name + "!";
            console.log(greeting);
            var welcomeMessage = "Welcome, " + name + "!";
            console.log(welcomeMessage);
            `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'TDD',
        descriptions: [
          {
            code: false,
            label: `TDD`,
            description: `TDD (Test-driven development) - це методологія розробки програмного забезпечення, що базується на написанні тестів перед написанням відповідного коду. Процес TDD складається з трьох основних етапів: написання тестів, написання коду і рефакторингу коду.`,
          },
          {
            code: false,
            label: ``,
            description: `Основними перевагами TDD є покращення якості коду, зменшення кількості багів, підвищення стійкості до змін та зменшення часу на відладку.`,
          },
          {
            code: false,
            label: `Давайте розглянемо декілька прикладів використання TDD в коді JavaScript:`,
            description: `1. Наприклад, ми можемо використовувати TDD для розробки функції, яка повертає суму двох чисел:`,
          },
          {
            code: true,
            label: ``,
            description: `// написання тестів
            describe('addition', () => {
              it('should add two numbers correctly', () => {
                expect(add(2, 3)).toBe(5);
                expect(add(4, 6)).toBe(10);
              });
            });
            
            // написання коду
            function add(a, b) {
              return a + b;
            }
            `,
          },
          {
            code: false,
            label: ``,
            description: `2. Інший приклад використання TDD може полягати в розробці функції, яка перевіряє, чи є рядок паліндромом (тобто читається однаково зліва направо і справа наліво):`,
          },
          {
            code: true,
            label: ``,
            description: `// написання тестів
            describe('palindrome', () => {
              it('should return true if a string is a palindrome', () => {
                expect(isPalindrome('racecar')).toBe(true);
                expect(isPalindrome('level')).toBe(true);
              });
            
              it('should return false if a string is not a palindrome', () => {
                expect(isPalindrome('hello')).toBe(false);
                expect(isPalindrome('world')).toBe(false);
              });
            });
            
            // написання коду
            function isPalindrome(str) {
              return str === str.split('').reverse().join('');
            }
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цих прикладах ми спочатку написали тестові сценарії, щоб перевірити очікуваний результат, а потім написали відповідний код для проходження тестів. Цей процес забезпечує, що функціональність коду працює, як очікувалося, і що цей код не порушує вже наявних функцій.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'ES5+, JavaScript',
    questions: [
      {
        id: generateUUID(),
        question: 'Типи даних у JavaScript?',
        descriptions: [
          {
            code: false,
            label: `JavaScript має наступні типи даних:`,
            description: ``,
          },
          {
            code: false,
            label: `1. Примітивні типи:`,
            description: `• number: включає числа будь-якого типу (цілі, дробові, з плаваючою точкою).`,
          },
          {
            code: false,
            label: ``,
            description: `• string: текстові дані, які записуються у лапки ('' або "") або використанням шаблонних літералів (\`\`).`,
          },
          {
            code: false,
            label: ``,
            description: `• boolean: тип даних з двома значеннями true (істина) та false (хиба).`,
          },
          {
            code: false,
            label: ``,
            description: `• null: це спеціальне значення, яке вказує на відсутність будь-якого значення або посилання на об'єкт, який не існує.`,
          },
          {
            code: false,
            label: ``,
            description: `• undefined: це спеціальне значення, яке вказує на те, що змінна не має значення або що вона не була ініціалізована.`,
          },
          {
            code: false,
            label: ``,
            description: `• symbol: це унікальний тип даних, який використовується для створення унікальних ідентифікаторів.`,
          },
          {
            code: false,
            label: ``,
            description: `• NaN: належить до примітивних типів даних і представляється значенням типу number. NaN використовується для позначення помилок, пов'язаних з операціями, які не повинні повертати значення, яке може бути використане для подальших обчислень.

            Наприклад, якщо ми спробуємо здійснити математичну операцію зі значеннями, які не можуть бути обчислені, наприклад ділення на 0, то результатом буде NaN.
            
            Також, якщо ми спробуємо перетворити рядок на число, але рядок не може бути коректно перетворений, то результатом буде NaN.`,
          },
          {
            code: false,
            label: ``,
            description: `• BigInt: є типом даних в JavaScript, який дозволяє зберігати цілі числа довільної величини, що перевищує максимальну точність, яку можна зберігати в типі даних number.

            У JavaScript числа типу number зберігаються у форматі 64-бітових чисел з плаваючою комою, що обмежує їх максимальну точність до 15-16 десяткових знаків. Завдяки типу даних BigInt, ми можемо зберігати значення цілих чисел, що перевищують цей максимум.
            
            Для створення значень типу BigInt, ми можемо використовувати суфікс "n" після числа, яке потрібно перетворити на BigInt. `,
          },
          {
            code: true,
            label: ``,
            description: `const bigIntNumber = 1234567890123456789012345678901234567890n;`,
          },
          {
            code: false,
            label: ``,
            description: `Також, можна виконувати арифметичні операції зі значеннями типу BigInt, включаючи додавання, віднімання, множення та ділення.

            На відміну від чисел типу number, значення типу BigInt не можуть бути порівняні зі значеннями інших типів даних, таких як рядки або числа. Для порівняння двох значень BigInt необхідно використовувати спеціальні методи, такі як BigInt.compare().`,
          },
          {
            code: false,
            label: `2. Об'єктні типи:`,
            description: `• Object: це складний тип даних, що складається з набору властивостей (ключів) та їх значень. Об'єкти створюються за допомогою фігурних дужок {} або за допомогою конструктора Object().`,
          },
          {
            code: false,
            label: ``,
            description: `• Array: це об'єкт, що складається з упорядкованого набору значень. Масиви створюються за допомогою квадратних дужок [] або за допомогою конструктора Array().`,
          },
          {
            code: false,
            label: ``,
            description: `• Function: це об'єкт, який містить визначення функції. Функції можуть приймати параметри та повертати значення.`,
          },
          {
            code: false,
            label: ``,
            description: `• Date: це об'єкт, який містить дату та час.`,
          },
          {
            code: false,
            label: ``,
            description: `• RegExp: це об'єкт, який використовується для роботи з регулярними виразами.`,
          },
          {
            code: false,
            label: ``,
            description: `Ці типи даних можуть використовуватися окремо або в поєднанні для створення складних структур даних та об'єктів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між == і === (нестрога/строга рівність)?',
        descriptions: [
          {
            code: false,
            label: `Різниця між \`==\` і \`===\` (нестрога/строга рівність)?`,
            description: `В JavaScript, \`==\` і \`===\` є операторами порівняння, які використовуються для порівняння значень.`,
          },
          {
            code: false,
            label: ``,
            description: `\`==\` (нестрога рівність) порівнює два операнди на рівність без урахування типу даних. Якщо типи даних різні, то JavaScript може спробувати конвертувати один з них до типу іншого операнда перед порівнянням. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            console.log(5 == "5"); // true, так як JavaScript конвертує рядок "5" до числа 5
            console.log(true == 1); // true, так як true конвертується до числа 1
            console.log(null == undefined); // true
            `,
          },
          {
            code: false,
            label: ``,
            description: `\`===\` (строга рівність) порівнює два операнди на рівність з урахуванням типу даних. Якщо типи даних різні, то вони не рівні. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            console.log(5 === "5"); // false, так як типи даних різні (число та рядок)
            console.log(true === 1); // false, так як типи даних різні (boolean та число)
            console.log(null === undefined); // false, так як типи даних різні (null та undefined)
            `,
          },
          {
            code: false,
            label: ``,
            description: `У загальному випадку, рекомендується використовувати \`===\` (строгу рівність), якщо ви хочете порівняти значення з урахуванням типу даних.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Strict mode у JavaScript?',
        descriptions: [
          {
            code: false,
            label: `Що таке Strict mode у JavaScript?`,
            description: `Strict mode (строгий режим) - це спеціальний режим роботи JavaScript, який дозволяє писати більш безпечний і ефективний код. У цьому режимі мова JavaScript застосовується у більш суворому варіанті, що дозволяє позбутися деяких характерних для JavaScript проблем.`,
          },
          {
            code: false,
            label: ``,
            description: `Для включення строгого режиму у файлі скрипта або функції необхідно додати рядок "use strict"; на початку файлу або функції. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            "use strict";
            function myFunction() {
              // код функції в строгому режимі
            }
            `,
          },
          {
            code: false,
            label: `Основні відмінності між строгим і нестрогим режимами:`,
            description: `1. Змінні та функції повинні бути оголошені перед використанням. В іншому випадку виникне помилка.`,
          },
          {
            code: true,
            label: ``,
            description: `
            "use strict";
            x = 10; // помилка, змінна не оголошена
            `,
          },
          {
            code: false,
            label: ``,
            description: `2. У строгому режимі не можна використовувати слова, які є зарезервованими для майбутніх версій JavaScript, наприклад, implements, interface, package, private, protected, public, static та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `3. У строгому режимі eval має свої особливості. Він не може створювати змінні та функції в зовнішньому контексті.`,
          },
          {
            code: false,
            label: ``,
            description: `4. У строгому режимі не можна видаляти змінні, функції, аргументи та інші об'єкти. В іншому випадку виникне помилка.`,
          },
          {
            code: false,
            label: ``,
            description: `5. У строгому режимі не можна використовувати with. В іншому випадку виникне помилка.`,
          },
          {
            code: false,
            label: ``,
            description: `6. У строгому режимі не можна використовувати дублювання параметрів у функціях. В іншому випадку виникне помилка.`,
          },
          {
            code: false,
            label: ``,
            description: `7. У строгому режимі недопустимо використання delete для властивостей об'єктів, які не дозволяють видалення (наприклад, Object.preventExtensions()). В іншому випадку виникне помилка.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між function declaration і function expression?',
        descriptions: [
          {
            code: false,
            label: `Різниця між function declaration і function expression?`,
            description: `У JavaScript існують два способи створення функцій: Function Declaration та Function Expression.`,
          },
          {
            code: false,
            label: ``,
            description: `Function Declaration - це спосіб створення функції, який використовує ключове слово function, за яким слідує ім'я функції та її параметри. Функції, створені за допомогою Function Declaration, можуть бути викликані до того, як вони були оголошені.`,
          },
          {
            code: true,
            label: ``,
            description: `
            function multiply(a, b) {
              return a * b;
            }
            `,
          },
          {
            code: false,
            label: ``,
            description: `Function Expression - це спосіб створення функції, де функція присвоюється змінній як значення. Цей спосіб створення функцій потрібно закінчувати символом крапки з комою (;), оскільки це вираз. Функції, створені за допомогою Function Expression, не можуть бути викликані до того, як вони були оголошені.`,
          },
          {
            code: true,
            label: ``,
            description: `
            const multiply = function(a, b) {
              return a * b;
            };
            `,
          },
          {
            code: false,
            label: ``,
            description: `Різниця між Function Declaration та Function Expression полягає в тому, як вони інтерпретуються. Function Declarations інтерпретуються двічі - спочатку, перед тим як будь-що буде виконано, а потім при зверненні до функції. Function Expressions інтерпретуються один раз - коли потрібно виконати код, що містить їх.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між null і undefined?',
        descriptions: [
          {
            code: false,
            label: `Різниця між null і undefined?`,
            description: `У JavaScript, null і undefined є двома різними типами даних зі своїми відмінностями:`,
          },
          {
            code: false,
            label: ``,
            description: `• \`null\` - це значення, що вказує на те, що змінна не має жодного значення. Вона є спеціальним типом даних, що означає "відсутність значення". Якщо змінна має значення null, це означає, що вона пуста і нічого не містить.`,
          },
          {
            code: false,
            label: ``,
            description: `• \`undefined\` - це значення, що вказує на те, що змінна не має присвоєного значення. Вона означає, що змінна не була ініціалізована. Якщо змінна має значення undefined, це означає, що вона була створена, але не була ініціалізована.`,
          },
          {
            code: false,
            label: ``,
            description: `Різниця між ними полягає в тому, що null це присвоєне значення, яке вказує на відсутність чогось, а undefined - значення, яке використовується для змінних, які ще не були ініціалізовані, або для властивостей об'єкта, які не існують.`,
          },
          {
            code: false,
            label: ``,
            description: `Проте, у більшості випадків null і undefined використовуються взаємозамінно і не мають великої різниці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Типи таймерів у JavaScript?',
        descriptions: [
          {
            code: false,
            label: `Типи таймерів у JavaScript?`,
            description: `У JavaScript існують три типи таймерів: setTimeout, setInterval і requestAnimationFrame.`,
          },
          {
            code: false,
            label: `setTimeout`,
            description: `1. setTimeout: Цей таймер запускає функцію один раз через задану кількість мілісекунд. Синтаксис: setTimeout(function, delay).`,
          },
          {
            code: true,
            label: ``,
            description: `
            setTimeout(function() {
              console.log("Hello, world!");
            }, 1000); //  Виконання функції через 1 секунду.
            `,
          },
          {
            code: false,
            label: `setInterval`,
            description: `2. setInterval: Цей таймер запускає функцію через задану кількість мілісекунд повторно. Синтаксис: setInterval(function, delay).`,
          },
          {
            code: true,
            label: ``,
            description: `
            setInterval(function() {
              console.log("Hello, world!");
            }, 2000); //  Виконання функції кожні 2 секунди.
            `,
          },
          {
            code: false,
            label: `requestAnimationFrame`,
            description: `3. requestAnimationFrame: Цей таймер використовується для анімації та виклику функцій на кожному кадрі анімації. Він працює з частотою оновлення екрану (кадрів на секунду) та автоматично підлаштовується під швидкість браузера. Синтаксис: requestAnimationFrame(callback).`,
          },
          {
            code: true,
            label: ``,
            description: `
            var element = document.getElementById("myElement");
            var opacity = 1;

            function animate() {
              opacity -= 0.01;
              element.style.opacity = opacity;
              
              if (opacity > 0) {
                requestAnimationFrame(animate);
              }
            }

            requestAnimationFrame(animate); //  Анімаційна функція, що змінює прозорість елемента на сторінці.
            `,
          },
          {
            code: false,
            label: ``,
            description: `Ці таймери можуть бути корисними для виконання різноманітних функцій в JavaScript, таких як запуск анімації, автоматичне оновлення сторінки, періодичні операції тощо.приклади показують, як можна використовувати таймери у JavaScript для виконання різноманітних завдань, від простого виведення повідомлень до складних анімацій та інтерактивних ефектів на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке підняття (Hoisting)?',
        descriptions: [
          {
            code: false,
            label: `Що таке підняття (Hoisting)?`,
            description: `Hoisting - це механізм в JavaScript, що дозволяє використовувати змінні та функції, навіть якщо вони були оголошені пізніше в коді. Підняття відбувається в два етапи: підняття змінних (variable hoisting) та підняття функцій (function hoisting).`,
          },
          {
            code: false,
            label: ``,
            description: `Variable hoisting дозволяє оголошувати змінні з будь-яким значенням та використовувати їх у коді до їхньої фактичної ініціалізації. Під час підняття змінної, їй автоматично надається значення undefined. Однак, якщо змінна була вже оголошена з використанням let або const, її не можна використовувати до фактичної ініціалізації.`,
          },
          {
            code: true,
            label: ``,
            description: `
            console.log(x); // undefined
            var x = 5;
            console.log(x); // 5
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі змінна x піднімається вгору в область видимості, тому що вона оголошується за допомогою var. Тому, коли ми викликаємо console.log(x) перед оголошенням змінної x, ми отримуємо значення undefined.`,
          },
          {
            code: false,
            label: `Function hoisting`,
            description: `Function hoisting дозволяє оголошувати функції та використовувати їх у коді до їхнього фактичного оголошення. Це означає, що функції можуть бути викликані до їхнього фактичного оголошення в коді. Однак, якщо функція була оголошена з використанням const або let, вона не може бути використана до їїнього фактичного оголошення.`,
          },
          {
            code: true,
            label: `function declaration`,
            description: `
            foo(); // "Hello, World!"

            function foo() {
              console.log("Hello, World!");
            }
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі функція foo також піднімається вгору в область видимості, тому ми можемо її викликати перед її оголошенням.`,
          },
          {
            code: false,
            label: `function expression`,
            description: `Проте, якщо ми оголошуємо функцію з використанням function expression, то піднімання (hoisting) не працює. Ось приклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            bar(); // TypeError: bar is not a function

            var bar = function() {
              console.log("Hello, World!");
            };
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі змінна bar піднімається вгору в область видимості, але її значення залишається undefined до того моменту, поки їй не буде присвоєно функційне значення. Тому коли ми викликаємо bar() перед присвоєнням функційного значення, ми отримуємо помилку TypeError, оскільки bar не є функцією.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке область видимості (Scope)?',
        descriptions: [
          {
            code: false,
            label: `Що таке область видимості (Scope)?`,
            description: `Область видимості (Scope) - це механізм в JavaScript, який визначає доступність змінних та інших ресурсів в певному місці коду.`,
          },
          {
            code: false,
            label: ``,
            description: `У JavaScript існує два типи областей видимості: глобальна та локальна.`,
          },
          {
            code: false,
            label: ``,
            description: `Глобальна область видимості визначається за межами всіх функцій та блоків коду. Змінні, які визначені в глобальній області видимості, можуть бути доступні в усьому коді.`,
          },
          {
            code: false,
            label: ``,
            description: `Локальна область видимості визначається всередині функцій та блоків коду. Змінні, які визначені в локальній області видимості, доступні лише всередині цієї області та не можуть бути доступні за її межами.`,
          },
          {
            code: false,
            label: ``,
            description: `Ось приклад коду, який ілюструє це поняття:`,
          },
          {
            code: true,
            label: ``,
            description: `
            var a = 10; // глобальна змінна

            function foo() {
              var b = 20; // локальна змінна, доступна лише всередині функції

              console.log(a); // 10
              console.log(b); // 20
            }

            foo();

            console.log(a); // 10
            console.log(b); // Uncaught ReferenceError: b is not defined
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі, змінна a визначена в глобальній області видимості, тому вона доступна в усьому коді. Змінна b визначена в локальній області видимості функції foo(), тому вона доступна лише всередині цієї функції, і за її межами вона не існує.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між var, let і const?',
        descriptions: [
          {
            code: false,
            label: `Різниця між var, let і const?`,
            description: `У JavaScript є три ключових слова для оголошення змінних: var, let та const. Основна різниця між ними полягає в їх області видимості та можливості зміни значення.`,
          },
          {
            code: false,
            label: ``,
            description: `Ключове слово var було першим, яке з'явилось у JavaScript. Воно має глобальну або функціональну область видимості, що означає, що змінна, оголошена з використанням var, буде доступна будь-де у функції або за її межами, якщо вона оголошена поза функцією. Змінні, оголошені з використанням var, також мають підняття (hoisting), що означає, що їх можна використовувати перед тим, як вони були оголошені.`,
          },
          {
            code: true,
            label: ``,
            description: `
            console.log(x); // Виведе "undefined"
            var x = 10;
            console.log(x); // Виведе "10"
            `,
          },
          {
            code: false,
            label: ``,
            description: `Ключове слово let було додане у ECMAScript 6. Воно також має блокову область видимості, що означає, що змінна, оголошена з використанням let, буде доступна тільки в межах блоку, у якому вона була оголошена (наприклад, у функції або циклі). Змінні, оголошені з використанням let, не мають підняття (hoisting), тому їх не можна використовувати перед їх оголошенням.`,
          },
          {
            code: true,
            label: ``,
            description: `
            console.log(x); // Виведе помилку "ReferenceError: x is not defined"
            let x = 10;
            console.log(x); // Виведе "10"
            `,
          },
          {
            code: false,
            label: ``,
            description: `Ключове слово const також було додане у ECMAScript 6. Воно має таку ж блокову область видимості, як let, але змінні, оголошені з використанням const, не можна змінювати після їх ініціалізації.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке замикання (Closure)?',
        descriptions: [
          {
            code: false,
            label: `Що таке замикання (Closure)?`,
            description: `Замикання (Closure) - це механізм мови JavaScript, який дозволяє функції звертатися до змінних з батьківського області видимості, навіть після того, як батьківська функція виконана. За допомогою замикання можна створювати приватні змінні і функції в JavaScript.`,
          },
          {
            code: false,
            label: ``,
            description: `Ось приклад замикання, де змінна counter не є глобальною, але доступна внутрішній функції incrementCounter, завдяки замиканню:`,
          },
          {
            code: true,
            label: ``,
            description: `
            function counterFunction() {
              let counter = 0;
            
              function incrementCounter() {
                counter++;
                console.log(counter);
              }
            
              return incrementCounter;
            }
            
            const counter = counterFunction(); // повертає функцію incrementCounter
            counter(); // 1
            counter(); // 2
            counter(); // 3
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі функція counterFunction повертає функцію incrementCounter, яка збільшує значення змінної counter та виводить його в консоль. Змінна counter є локальною змінною, що знаходиться в області видимості функції counterFunction. Кожен раз, коли функція counter викликається, вона збільшує значення змінної counter. Завдяки замиканню функції incrementCounter має доступ до змінної counter навіть після закінчення роботи функції counterFunction.`,
          },
          {
            code: false,
            label: ``,
            description: `Ось ще один приклад замикання, де створюється функція, яка повертає об'єкт з двома методами getName та setName для отримання та зміни імені:`,
          },
          {
            code: true,
            label: ``,
            description: `
            function person(name) {
              return {
                getName: function() {
                  return name;
                },
                setName: function(newName) {
                  name = newName;
                }
              }
            }
            
            const john = person("John");
            console.log(john.getName()); // "John"
            john.setName("Jack");
            console.log(john.getName()); // "Jack"
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі функція person приймає параметр name та повертає об\'єкт з двома методами getName та setName. Змінна name є локальною змінною, яка знаходиться в області видимості функції person`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що означає this у JavaScript?',
        descriptions: [
          {
            code: false,
            label: `Що означає this у JavaScript?`,
            description: `Новачкам (і не тільки ним) буває важко розібратися з ключовим словом this. Існує 5 правил, що допоможуть вам зрозуміти принцип роботи this та не плутатися в майбутньому. Звісно, ці правила не покривають всі випадки, але вони працюють в більшості ситуацій.`,
          },
          {
            code: false,
            label: ``,
            description: `1. Значення this залежить від контексту виконання. Контекст — це те, як і де функцію викликають.`,
          },
          {
            code: false,
            label: ``,
            description: `2. При кожному виклику функції this може вказувати на різні об'єкти.`,
          },
          {
            code: false,
            label: `1. Глобальний об'єкт`,
            description: `Давайте відразу перейдемо до практики. Відкрийте консоль (Windows: Ctrl + Shift + J)(Mac: Cmd + Option + J) і наберіть наступне:`,
          },
          {
            code: true,
            label: ``,
            description: `console.log(this); // Window {...}`,
          },
          {
            code: false,
            label: ``,
            description: `Так, об'єкт window. Це сталося тому що в глобальній області видимості this вказує на глобальний об'єкт, а для браузера це window.

            Щоб краще зрозуміти чому так виходить, давайте трохи зануримося в теорію. Створіть нову змінну в консолі з вашим ім'ям.`,
          },
          {
            code: true,
            label: ``,
            description: `var myName = 'Petro';`,
          },
          {
            code: false,
            label: ``,
            description: `Ми можемо отримати його значення, викликавши:`,
          },
          {
            code: true,
            label: ``,
            description: `
            myName
            // 'Petro'`,
          },
          {
            code: false,
            label: ``,
            description: `А чи знали ви, що всі змінні в глобальній області видимості прикріплені до об'єкта window?`,
          },
          {
            code: true,
            label: ``,
            description: `
            window.myName
            // 'Brandon'
            window.myName === myName
            // true`,
          },
          {
            code: false,
            label: ``,
            description: `Круто. Тепер ви знаєте трохи більше. А тепер давайте помістимо this всередину функції. Згідно з правилом вище, значення this залежить від способу виклику функції. Як думаєте, що поверне функція? Скопіюйте цей код в консоль браузера і перевірте свої здогадки:`,
          },
          {
            code: true,
            label: ``,
            description: `
            function test() {
              return this;
            }
            test()`,
          },
          {
            code: false,
            label: ``,
            description: `this все ще вказує на глобальний об'єкт. Це відбувається тому що this знаходиться не всередині оголошеного об'єкту, тому і посилається на глобальний об'єкт. Це може бути трохи складно зрозуміти, тому просто продовжуйте читати, далі. Також слід зауважити, що якщо ви використовуєте суворий режим ("use strict";), то в прикладі вище this буде вказувати на undefined.`,
          },
          {
            code: false,
            label: `2. Оголошений об'єкт`,
            description: `Коли this використовується всередині оголошеного об'єкту, він приймає значення найближчого предка. Подивіться на код, де я оголошую об'єкт person і використовую this всередині методу full:`,
          },
          {
            code: true,
            label: ``,
            description: `
            var person = {
              first: 'Andrii',
              last: 'Kovalcuk',  
              full: function() {
                console.log(this.first + ' ' + this.last);
              }
            };
            person.full();
            // 'Andrii Kovalchuk'`,
          },
          {
            code: false,
            label: ``,
            description: `Ви можете переконатися в тому, що this вказує на потрібний об'єкт, замінивши тіло методу full на console.log(this):`,
          },
          {
            code: true,
            label: ``,
            description: `
            var person = {
              first: 'Andrii',
              last: 'Kovalcuk', 
              full: function() {
                console.log(this);
              }
            };
            person.full();
            // Object {first: "Andrii", last: "Kovalchuk", full: function}`,
          },
          {
            code: false,
            label: ``,
            description: `Перед тим, як рухатися далі, я хочу ще раз наголосити, що this вказує на найближчого предка. Уявіть випадок коли в вас будуть вкладені об'єкти:`,
          },
          {
            code: true,
            label: ``,
            description: `
            var person = {
              first: 'Andrii',
              last: 'Kovalchuk',
              full: function() {
                console.log(this.first + ' ' + this.last);
              },
              personTwo: {
                first: 'Ivan',
                last: 'Yarema',
                full: function() {
                  console.log(this.first + ' ' + this.last);
                }
              }
            };`,
          },
          {
            code: false,
            label: ``,
            description: `Що станеться коли ми викличемо метод full? Ось що:`,
          },
          {
            code: true,
            label: ``,
            description: `
            person.full();
            // 'Andrii Kovalchuk'
            person.personTwo.full();
            // 'Ivan Yarema'`,
          },
          {
            code: false,
            label: `3. Ключове слово new`,
            description: `Коли використовується ключове слово new (конструктор), this вказує на новий об'єкт, що створюється.

            Розглянемо приклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            function Car(make, model) {
              this.make = make;
              this.model = model;
            };`,
          },
          {
            code: false,
            label: ``,
            description: `Ви можете подумати, що this буде вказувати на глобальний об'єкт, і це буде правдою. Допоки ми не додамо ключове слово new! Тепер this буде вказувати на новий об'єкт, в даному випадку myCar.`,
          },
          {
            code: true,
            label: ``,
            description: `
            var myCar = new Car('Ford', 'Escape');
            console.log(myCar);
            // Car {make: "Ford", model: "Escape"}`,
          },
          {
            code: false,
            label: ``,
            description: `Щоб зрозуміти, чому так відбувається, вам потрібно знати як працює new, але це — вже тема для окремої статті. А зараз ви повинні пам'ятати, що якщо перед викликом стоїть new, то всередині this вказує на новий об'єкт.`,
          },
          {
            code: false,
            label: `4. call, bind, apply`,
            description: `За допомогою цих функцій ми можемо явно вказати значення this. Ці три функції схожі між собою, але тим не менш мають суттєві відмінності в роботі.`,
          },
          {
            code: false,
            label: ``,
            description: `call та apply дуже схожі, вони обидва приймають значення this та аргументи, і викликають функцію з цими даними. Різниця лиш в тому, що call приймає аргументи окремо, а apply — в масиві.

            Не розумієте? Давайте розглянемо на прикладі. Ми намагаємось додати числа, але це не працює:`,
          },
          {
            code: true,
            label: ``,
            description: `
            function add(c, d) {
              console.log(this.a + this.b + c + d);
            }
            add(3,4);
            // NaN`,
          },
          {
            code: false,
            label: ``,
            description: `Функція повертає NaN (not a number), адже this.a та this.b не існує, а неможливо додати те, чого немає.

            Давайте створимо новий об'єкт і використаємо call та apply:`,
          },
          {
            code: true,
            label: ``,
            description: `
            function add(c, d) {
              console.log(this.a + this.b + c + d);
            }
            var ten = {a: 1, b: 2};
            add.call(ten, 3, 4);
            // 10
            add.apply(ten, [3,4]);
            // 10`,
          },
          {
            code: false,
            label: ``,
            description: `Коли ми використовуємо call та apply, this прив'язується до значення першого аргументу і функція викликається з заданими параметрами.`,
          },
          {
            code: false,
            label: ``,
            description: `А як щодо bind? Параметри bind ідентичні до call, але bind не викликає функцію, натомість він повертає іншу функцію, в якій this вже привязано. Це корисно коли ви не ще не знаєте з якими параметрами будуть викликати вашу функцію.`,
          },
          {
            code: true,
            label: ``,
            description: `
            var small = {
              a: 1,
              go: function(b,c,d){
                console.log(this.a+b+c+d);
              }
            }
            var large = {
              a: 100
            }`,
          },
          {
            code: false,
            label: ``,
            description: `Скопіюйте цей код в консоль, а потім виконайте:`,
          },
          {
            code: true,
            label: ``,
            description: `
            small.go(2,3,4);
            // 1+2+3+4 => 10`,
          },
          {
            code: false,
            label: ``,
            description: `Поки що нічого нового. А якщо ви хочемо викликати функцію, використавши large.a? Ви можемо використати call/apply:`,
          },
          {
            code: true,
            label: ``,
            description: `
            small.go.call(large,2,3,4);
            // 100+2+3+4 => 109`,
          },
          {
            code: false,
            label: ``,
            description: `А якщо ми не знаємо всі три параметри? Ми використовуємо bind.`,
          },
          {
            code: true,
            label: ``,
            description: `var bindTest = small.go.bind(large,2);`,
          },
          {
            code: false,
            label: ``,
            description: `Якщо ми виведемо нашу змінну, то побачимо, що це функція:`,
          },
          {
            code: true,
            label: ``,
            description: `
            console.log(bindTest);
            // function (b,c,d){console.log(this.a+b+c+d);}`,
          },
          {
            code: false,
            label: ``,
            description: `Як ви пам'ятаєте, bind створює контекст виконання. Ми вже задали значення this та наш перший аргумент. Пізніше, коли ви дізналися всі параметри, ви можете викликати функцію, передавши лише два аргументи:`,
          },
          {
            code: true,
            label: ``,
            description: `
            bindTest(3,4);
            // 100+2+3+4 => 109`,
          },
          {
            code: false,
            label: ``,
            description: `Для вашої зручності ось весь код одним блоком. Експерементуйте!`,
          },
          {
            code: true,
            label: ``,
            description: `
            var small = {
              a: 1,
              go: function(b,c,d){
                console.log(this.a+b+c+d);
              }
            }
            var large = {
              a: 100
            }
            small.go(2,3,4);
            // 1+2+3+4 => 10
            var bindTest = small.go.bind(large,2);
            console.log(bindTest);
            // function (b,c,d){console.log(this.a+b+c+d);}
            bindTest(3,4);
            // 100+2+3+4 => 109`,
          },
          {
            code: false,
            label: `5. Стрілочні функції`,
            description: `стрілочні функції не змінюють this, вони беруть його з контексту.`,
          },
          {
            code: false,
            label: `Підсумки`,
            description: `Тепер ви знаєте про JavaScript більше. Давайте підведемо короткий підсумок:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Значення this зазвичай залежить від контексту виконання.`,
          },
          {
            code: false,
            label: ``,
            description: `2. В глобальній області видимості this вказує на глобальний об'єкт (window)`,
          },
          {
            code: false,
            label: ``,
            description: `3. Коли використовується ключове слово new, this вказує на об'єкт, що створюється.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Ви можемо явно вказати значення this при виконанні функції за допомогою apply, call та bind..`,
          },
          {
            code: false,
            label: ``,
            description: `5. Стрілочні функції не змінюють this.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке функції вищого порядку (Higher Order Functions)?',
        descriptions: [
          {
            code: false,
            label: `Що таке функції вищого порядку (Higher Order Functions)?`,
            description: `У JavaScript функції вищого порядку (Higher Order Functions) є функціями, які приймають іншу функцію як аргумент або повертають функцію як результат. Це дозволяє створювати більш абстрактний код, що може бути перевикористаний в різних контекстах.`,
          },
          {
            code: false,
            label: ``,
            description: `Ось декілька прикладів функцій вищого порядку у JavaScript:`,
          },
          {
            code: false,
            label: ``,
            description: `1. map() - функція, яка створює новий масив, проходячи через кожен елемент масиву та застосовуючи до нього передану функцію.`,
          },
          {
            code: true,
            label: ``,
            description: `
            const arr = [1, 2, 3, 4, 5];

            const squared = arr.map(num => num * num);

            console.log(squared); // [1, 4, 9, 16, 25]
            `,
          },
          {
            code: false,
            label: ``,
            description: `2. filter() - функція, яка створює новий масив з елементів масиву, які проходять перевірку, здійснювану переданою функцією.`,
          },
          {
            code: true,
            label: ``,
            description: `
            const arr = [1, 2, 3, 4, 5];

            const evenNums = arr.filter(num => num % 2 === 0);

            console.log(evenNums); // [2, 4]
            `,
          },
          {
            code: false,
            label: ``,
            description: `3. reduce() - функція, яка обчислює один значення на основі елементів масиву, який проходить через нього, та переданої функції-акумулятора.`,
          },
          {
            code: true,
            label: ``,
            description: `
            const arr = [1, 2, 3, 4, 5];

            const sum = arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);

            console.log(sum); // 15
            `,
          },
          {
            code: false,
            label: ``,
            description: `4. setTimeout() - функція, яка встановлює затримку перед виконанням функції, яка передана як аргумент.`,
          },
          {
            code: true,
            label: ``,
            description: `
            setTimeout(() => {
              console.log('Hello, world!');
            }, 2000);
            `,
          },
          {
            code: false,
            label: ``,
            description: `Ці приклади демонструють, як функції можуть бути використані як аргументи і повертатись як результати, що дозволяє створювати більш абстрактний та перевикористовуваний код.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як перетворити будь-який тип даних на булевий? Перелічіть хибні значення в JS?',
        descriptions: [
          {
            code: false,
            label: `Булеві інтерпретації js`,
            description: `У JavaScript можна перетворити будь-який тип даних на булевий за допомогою конструктора Boolean() або застосувавши логічний оператор !!.`,
          },
          {
            code: false,
            label: ``,
            description: `Деякі типи даних, які можуть бути приведені до false, називаються "falsy" значеннями, інші, які завжди приводяться до true, називаються "truthy" значеннями.`,
          },
          {
            code: false,
            label: `Ось деякі приклади булевої інтерпретації в JavaScript:`,
            description: ``,
          },
          {
            code: false,
            label: `Falsy значення:`,
            description: `Falsy значення в JavaScript - це значення, які в інтерпретації являються false або перетворюються в false при конвертації до булевого типу. Ось перелік всіх falsy значень:`,
          },
          {
            code: false,
            label: ``,
            description: `• false`,
          },
          {
            code: false,
            label: ``,
            description: `• 0 (та інші числа рівні 0, наприклад, 0n, -0, 0.0, тощо)`,
          },
          {
            code: false,
            label: ``,
            description: `• '' (пустий рядок)`,
          },
          {
            code: false,
            label: ``,
            description: `• null`,
          },
          {
            code: false,
            label: ``,
            description: `• undefined`,
          },
          {
            code: false,
            label: ``,
            description: `• NaN`,
          },
          {
            code: false,
            label: ``,
            description: `Щоб видалити всі Falsy значення з масиву, можна використати метод filter(), який поверне новий масив з елементами, які є істинними:`,
          },
          {
            code: true,
            label: ``,
            description: `
            const arr = [0, 1, '', 'hello', null, undefined, NaN];

            const truthyArr = arr.filter(Boolean); // [1, 'hello']
            `,
          },
          {
            code: false,
            label: ``,
            description: `Також можна використати оператор !! для конвертації значення до булевого типу. Це дасть те саме результат, що й передача функції Boolean до методу filter():`,
          },
          {
            code: true,
            label: ``,
            description: `
            const truthyArr = arr.filter(x => !!x); // [1, 'hello']`,
          },
          {
            code: false,
            label: ``,
            description: `У обох випадках результатом буде новий масив з істинними елементами, а всі Falsy значення будуть видалені.`,
          },
          {
            code: false,
            label: `Truthy значення:`,
            description: `• true`,
          },
          {
            code: false,
            label: ``,
            description: `• Любе число, крім 0`,
          },
          {
            code: false,
            label: ``,
            description: `• Любий непорожній рядок, включаючи пробіли і символи`,
          },
          {
            code: false,
            label: ``,
            description: `• Любий об'єкт, включаючи масиви і функції`,
          },
          {
            code: false,
            label: ``,
            description: `• Infinity і -Infinity`,
          },
          {
            code: false,
            label: ``,
            description: `Ось деякі приклади булевої інтерпретації в JavaScript:`,
          },
          {
            code: true,
            label: ``,
            description: `
            console.log(Boolean(false));     // false
            console.log(Boolean(0));         // false
            console.log(Boolean(''));        // false
            console.log(Boolean(null));      // false
            console.log(Boolean(undefined)); // false
            console.log(Boolean(NaN));       // false

            console.log(Boolean(true));      // true
            console.log(Boolean(1));         // true
            console.log(Boolean('hello'));   // true
            console.log(Boolean([]));        // true
            console.log(Boolean({}));        // true
            console.log(Boolean(Infinity));  // true
            `,
          },
          {
            code: false,
            label: ``,
            description: `Ці правила використовуються в умовних конструкціях, таких як if, while, for, switch, тому розуміння булевої інтерпретації є важливим для розуміння логіки програм.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Логічні оператори в JS',
        descriptions: [
          {
            code: false,
            label: `Логічні оператори в JS`,
            description: `Логічні оператори - це оператори, які працюють з булевими значеннями та використовуються для виконання логічних операцій в JavaScript. Ось кілька прикладів:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Оператор ?? - нульове злиття (nullish coalescing operator)
            Оператор ?? використовується для повернення першого операнда, якщо він не є null або undefined, інакше повертається другий операнд. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            const x = null;
            const y = x ?? 'default';
            console.log(y); // виведе 'default', оскільки x є null
            `,
          },
          {
            code: false,
            label: ``,
            description: `2. Оператор && - Логічне І (logical AND)
            Оператор && поверне перший операнд, якщо він є false, в іншому випадку поверне другий операнд. Цей оператор використовується для виконання логічного І між двома значеннями. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            const x = 5;
            const y = 10;
            if (x > 0 && y > 0) {
              console.log('Обидва значення є більші за 0');
            }
            `,
          },
          {
            code: false,
            label: ``,
            description: `Оператор || - Логічне АБО (logical OR)
            Оператор || поверне перший операнд, якщо він є true, в іншому випадку поверне другий операнд. Цей оператор використовується для виконання логічного АБО між двома значеннями. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            const x = null;
            const y = x || 'default';
            console.log(y); // виведе 'default', оскільки x є null
            `,
          },
          {
            code: false,
            label: ``,
            description: `Оператор ! - Логічне НЕ (logical NOT)
            Оператор ! поверне протилежне булеве значення операнду. Якщо операнд є true, то поверне false, якщо false, то поверне true. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
            const x = true;
            const y = !x;
            console.log(y); // виведе false
            `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Методи рядків у JavaScript?',
        descriptions: [
          {
            code: false,
            label: `Методи рядків у JavaScript?`,
            description: ``,
          },
          {
            code: false,
            label: ``,
            description: ``,
          },
          {
            code: false,
            label: ``,
            description: ``,
          },
          {
            code: false,
            label: ``,
            description: ``,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'TypeScript',
    questions: [
      {
        id: generateUUID(),
        question: 'Що таке TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'TypeScript',
            description: `TypeScript - це мова програмування, яка є строго типізованою версією JavaScript.`,
          }, {
            code: false,
            label: '',
            description: `Однією з головних переваг TypeScript є можливість виявлення помилок під час компіляції, що дозволяє позбутися багатьох потенційних помилок в коді ще до його виконання. Крім того, TypeScript дозволяє зберігати код більш структурованим і організованим, що полегшує розробку і підтримку програм в майбутньому.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Основні компоненти TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'Основні компоненти TypeScript, які варто знати, це:',
            description: ``,
          }, {
            code: false,
            label: '',
            description: `1. Синтаксис: TypeScript використовує синтаксис, який є розширенням синтаксису JavaScript. Це означає, що TypeScript включає всі функції JavaScript, а також додає нові функції, такі як типи даних, інтерфейси, декоратори та інші.`,
          }, {
            code: false,
            label: '',
            description: `2. Компілятор: TypeScript поставляється з компілятором, який перетворює TypeScript-код у JavaScript-код, який може бути виконаний у браузері або на сервері. Компілятор дозволяє налаштувати TypeScript-код на конкретних потребах проекту та перетворювати його на JavaScript.`,
          }, {
            code: false,
            label: '',
            description: `3. Визначення типів: TypeScript є строго типізованою мовою, що означає, що розробник повинен визначити тип кожної змінної, аргументу та поверненого значення функції. Це допомагає уникнути помилок, пов'язаних з неправильними типами даних, що можуть виникнути під час виконання програми.`,
          }, {
            code: false,
            label: '',
            description: `4. Інтерфейси: TypeScript підтримує інтерфейси, які дозволяють розробникам описувати структуру об'єктів. Інтерфейси використовуються для забезпечення типової безпеки в коді та для документування API.`,
          }, {
            code: false,
            label: '',
            description: `5. Декоратори: TypeScript підтримує декоратори, які дозволяють додавати анотації до класів, функцій та інших конструкцій. Декоратори дозволяють розробникам додавати додаткову логіку до коду на етапі компіляції.`,
          }, {
            code: false,
            label: '',
            description: `6. Модулі: TypeScript підтримує модулі, які дозволяють розробникам організовувати свій код у логічні блоки. Модулі дозволяють імпортувати та експортувати функції, класи та інші конструкції між різними файлами `,
          }, {
            code: false,
            label: '',
            description: `7. Enums: TypeScript має підтримку перерахувань, які дозволяють розробникам створювати іменовані константи. Перерахування дозволяють зручно описувати набір можливих значень для змінної.`,
          }, {
            code: false,
            label: '',
            description: `8. Generics: TypeScript підтримує generics, які дозволяють розробникам створювати загальні класи та функції, які можуть працювати з різними типами даних. Generics дозволяють зменшити дублювання коду та покращити його читабельність.`,
          }, {
            code: false,
            label: '',
            description: `9. Неймспейси: TypeScript підтримує неймспейси, які дозволяють розробникам групувати пов'язані об'єкти, змінні та функції в одному місці. Це дозволяє зменшити конфлікти назв та полегшити організацію коду.`,
          }, {
            code: false,
            label: '',
            description: `10. Міжплатформні можливості: TypeScript підтримує розробку коду для різних платформ, таких як браузери та сервери. TypeScript може бути використаний для розробки Node.js додатків та додатків для браузера з використанням бібліотек, таких як React та Angular.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Особливості TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'TypeScript має кілька особливостей, які роблять його корисним інструментом для розробки програмного забезпечення. Ось кілька з них:',
            description: `1. Строга типізація: TypeScript використовує строгу типізацію, що дозволяє виявляти помилки ще до виконання програми, забезпечуючи вищу надійність і підтримуваність коду.`,
          },
          {
            code: false,
            label: '',
            description: `2. Класи і інтерфейси: TypeScript підтримує класи та інтерфейси, що дозволяє розробникам створювати код більш організованим та легким для розуміння.`,
          },
          {
            code: false,
            label: '',
            description: `3. Перелічення: TypeScript дозволяє використовувати перелічення, що дозволяє вказати допустимі значення для змінної.`,
          },
          {
            code: false,
            label: '',
            description: `4. Збірка модулів: TypeScript дозволяє розробникам організовувати свій код у модулі, що сприяє легшій підтримці і використанню коду.`,
          }, {
            code: false,
            label: '',
            description: `5. Короткий час компіляції: TypeScript компілюється у звичайний JavaScript, що дозволяє зберігати час на відлагодженні і розгортанні коду.`,
          }, {
            code: false,
            label: '',
            description: `6. Підтримка ES6 та новіші версії JavaScript: TypeScript підтримує нові функції та синтаксис, які додані у JavaScript після ES6, такі як async/await, стрілкові функції та інші.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Мінуси використання TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'Незважаючи на численні переваги, TypeScript також має свої недоліки, серед яких:',
            description: `1. Великий поріг входження: TypeScript потребує від розробників знань виключної синтаксичної сумісності з JavaScript та додаткових знань про типи даних, що може бути важким для початківців.`,
          }, {
            code: false,
            label: '',
            description: `2. Додаткові витрати на розробку: TypeScript може збільшити час та витрати на розробку, оскільки вимагає додаткового часу на написання додаткового коду для визначення типів даних.`,
          }, {
            code: false,
            label: '',
            description: `3. Додаткова обробка на етапі компіляції: TypeScript потребує додаткової обробки на етапі компіляції, що може призвести до збільшення часу компіляції та збільшення розміру вихідного коду.`,
          }, {
            code: false,
            label: '',
            description: `4. Необов'язкове використання: TypeScript є додатковим інструментом, тому його використання не є обов'язковим, що може призвести до того, що деякі розробники можуть не використовувати його, що ускладнює розробку та підтримку коду.`,
          }, {
            code: false,
            label: '',
            description: `5. Додаткова навантаження на процесор: TypeScript потребує додаткового часу та ресурсів процесора для обробки типів даних, що може призвести до зменшення продуктивності виконання коду.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які є типи у TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'Типи у TypeScript',
            description: `1. number - числовий тип даних (наприклад, 1, 2.5, -3).`,
          }, {
            code: false,
            label: '',
            description: `2. string - рядковий тип даних (наприклад, "Hello, world!", '123').`,
          }, {
            code: false,
            label: '',
            description: `3. boolean - логічний тип даних (true або false).`,
          }, {
            code: false,
            label: '',
            description: `4. null та undefined - спеціальні значення, які використовуються для відсутності значення.`,
          }, {
            code: false,
            label: '',
            description: `5. object - тип даних, що представляє об'єкти JavaScript (наприклад, {name: "John", age: 30}).`,
          }, {
            code: false,
            label: '',
            description: `6. array - тип даних, який представляє масиви (наприклад, [1, 2, 3], ['a', 'b', 'c']).`,
          }, {
            code: false,
            label: '',
            description: `7. tuple - тип даних, який дозволяє вказати фіксовану кількість елементів з різними типами (наприклад, [string, number], де перший елемент масиву є рядком, а другий - числом).`,
          }, {
            code: false,
            label: '',
            description: `8. enum - тип даних, який дозволяє створювати набір іменованих значень.`,
          }, {
            code: false,
            label: '',
            description: `9. any - тип даних, який дозволяє присвоювати будь-яке значення.`,
          }, {
            code: false,
            label: '',
            description: `10. void - тип даних, який позначає відсутність поверненого значення функцією.`,
          }, {
            code: false,
            label: '',
            description: `11. never - тип даних, який позначає значення, яке ніколи не може бути створено.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке декоратори?',
        descriptions: [
          {
            code: false,
            label: 'Декоратори',
            description: `Декоратори - це функції, які додають метадані до класів, методів або властивостей в TypeScript. Вони використовуються для зміни поведінки класу або його складових без зміни вихідного коду.`,
          }, {
            code: false,
            label: '',
            description: `Декоратори можуть бути застосовані до класів, методів, властивостей і параметрів методів. Вони використовуються як функції і приймають один або два параметри: цільовий об'єкт (клас, метод, властивість або параметр) і необов'язковий ключовий об'єкт, що містить додаткові параметри для декоратора.`,
          }, {
            code: false,
            label: '',
            description: `Декоратори в TypeScript є потужним інструментом, що дозволяє зробити код більш читабельним та допомагає в розробці більш складних програм. Вони також дозволяють розширити функціональність TypeScript та реалізувати різноманітні патерни проектування, такі як Dependency Injection та інші.`,
          }, {
            code: false,
            label: '',
            description: `Наприклад, розглянемо клас Person, який містить метод greet, який повертає рядок привітання з іменем особи. Ми можемо додати декоратор log до методу, щоб вивести інформацію про його виклик та результат.`,
          }, {
            code: true,
            label: '',
            description: `function log(target: any, name: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  descriptor.value = function(...args: any[]) {
    console.log(\`Calling $ {name} with arguments: $ {JSON.stringify(args)}\`);
    const result = original.apply(this, args);
    console.log(\`Result of $ {name}: $ {JSON.stringify(result)}\`);
    return result;
  }
  return descriptor;
}

class Person {
  constructor(public name: string) {}

  @log
  greet() {
    return \`Hello, $ {this.name}!\`;
  }
}

const john = new Person('John');
john.greet();
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі декоратор log приймає три параметри: цільовий об'єкт (клас Person), назву методу (greet) та об'єкт PropertyDescriptor. Далі він замінює оригінальний метод на нову функцію, яка виводить інформацію про виклик методу та його результат, а потім викликає оригінальний метод і повертає його результат.`,
          }, {
            code: false,
            label: '',
            description: `При виклику методу greet на об'єкті john, ми побачимо наступний вивід в консолі:`,
          }, {
            code: true,
            label: '',
            description: `Calling greet with arguments: []
Result of greet: "Hello, John!"
`,
          }, {
            code: false,
            label: '',
            description: `Цей приклад демонструє, як декоратор може доповнити функціональність методу, додавши до нього метадані і додаткову логіку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Чи підтримує TypeScript навантаження функцій?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Так, TypeScript підтримує навантаження функцій (або функціональне перевантаження). Це означає, що ви можете мати кілька функцій з однаковим іменем, але з різними параметрами, типами повернення та кількістю параметрів.`,
          }, {
            code: true,
            label: 'Наведемо приклад функціонального перевантаження в TypeScript:',
            description: `function foo(x: number): number;
function foo(x: string): string;
function foo(x: boolean): boolean;
function foo(x: any): any {
  if (typeof x === 'number') {
    return x * 2;
  } else if (typeof x === 'string') {
    return \`Hello, $ {x}!\`;
  } else if (typeof x === 'boolean') {
    return !x;
  } else {
    return x;
  }
}

const result1 = foo(42); // result1: number
const result2 = foo('John'); // result2: string
const result3 = foo(true); // result3: boolean
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі функція <foo> перевантажується три рази з різними параметрами: один параметр типу <number>, один параметр типу <string> та один параметр типу <boolean>. Залежно від типу переданого параметра, функція повертає різний тип даних. В результаті, ви можете викликати функцію <foo> з різними типами параметрів і отримати різний тип поверненого значення.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між типом (type) та інтерфейсом (interface)?',
        descriptions: [
          {
            code: false,
            label: 'В TypeScript існують дві основні конструкції для опису типів: <type> та <interface>',
            description: `interface - це іменований набір вимог, які об'єкт повинен виконувати. Вони найчастіше використовуються для опису формату об'єктів, але можуть також використовуватися для опису функцій, масивів, класів і т. д.`,
          }, {
            code: false,
            label: '',
            description: `type - це псевдонім (alias) для іншого типу. Він найчастіше використовується для опису складних типів, які важко або неможливо описати з використанням <interface>. Також, <type> може використовуватися для створення об'єднань типів, перетину типів, аліасів для примітивних типів та т. д.`,
          }, {
            code: false,
            label: '',
            description: `Основна відмінність між <interface> та <type> полягає в тому, що <interface> може бути розширеним, тоді як <type> ні. Це означає, що ви можете додавати нові вимоги до інтерфейсу, або розширювати його з використанням ключового слова <extends>, тоді як <type> неможливо розширити з використанням ключового слова <extends>.`,
          }, {
            code: false,
            label: '',
            description: `Також, <interface> підтримує зведення інтерфейсів (interface merging), коли два інтерфейси з однаковим іменем автоматично об'єднуються в один. Це дозволяє розділити визначення інтерфейсу на кілька файлів і зберегти зручність роботи з кодом. <type> не підтримує зведення типів.`,
          }, {
            code: false,
            label: '',
            description: `Отже, коли ви хочете описати формат об'єкту, використовуйте <interface>. Якщо ви хочете описати складний тип або створити псевдонім для іншого типу, використовуйте <type>.`,
          }, {
            code: true,
            label: 'Ось приклад використання interface для опису формату об\'єкту:',
            description: `interface User {
  name: string;
  age: number;
  email: string;
}

const user: User = {
  name: "John",
  age: 30,
  email: "john@example.com"
}
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі ми створили інтерфейс User, який вимагає наявності трьох властивостей у об'єкті: name (типу string), age (типу number) та email (типу string). Потім ми створили змінну user, яка відповідає цьому формату, тому що ми використали User як тип для цієї змінної.`,
          }, {
            code: true,
            label: 'А ось приклад використання type для створення псевдоніма для складного типу:',
            description: `type Employee = {
  name: string;
  age: number;
  email: string;
  salary: number;
}

const employee: Employee = {
  name: "Alice",
  age: 25,
  email: "alice@example.com",
  salary: 50000
}
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі ми створили псевдонім Employee для складного типу, який вимагає наявності чотирьох властивостей у об'єкті: name (типу string), age (типу number), email (типу string) та salary (типу number). Потім ми створили змінну employee, яка відповідає цьому формату, тому що ми використали Employee як тип для цієї змінної.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке JSX у TypeScript? Які режими JSX підтримує TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'JSX (JavaScript XML)',
            description: `JSX (JavaScript XML) - це розширення синтаксису JavaScript, яке дозволяє використовувати XML-подібний синтаксис для опису інтерфейсу користувача у JavaScript-файлах.`,
          }, {
            code: false,
            label: 'TypeScript підтримує JSX і має два режими JSX:',
            description: ``,
          }, {
            code: false,
            label: '',
            description: `1. Режим preserve: в цьому режимі TypeScript не змінює код JSX під час компіляції, а просто перетворює його на звичайний JavaScript. Цей режим використовується за замовчуванням.`,
          }, {
            code: false,
            label: '',
            description: `2. Режим react: в цьому режимі TypeScript перетворює JSX на виклики функцій React. Цей режим використовується, коли використовується бібліотека React.`,
          }, {
            code: true,
            label: 'Ось приклад використання JSX в TypeScript:',
            description: `import React from 'react';

interface GreetingProps {
  name: string;
}

const Greeting = (props: GreetingProps) => {
  return <div>Hello, {props.name}!</div>;
}

export default Greeting;
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо JSX, щоб створити елемент div, який вітає користувача з використанням імені, переданого через властивість name. У компоненті Greeting ми використовуємо інтерфейс GreetingProps для задання типів для властивостей компонента, включаючи тип name, що є рядком.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке директиви з трьома похилими характеристиками (Triple-Slash Directives), їх типи?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Директиви з трьома похилими характеристиками (Triple-Slash Directives) - це спеціальні коментарі в TypeScript, які починаються з трипохилої лінії (///) і використовуються для надання інформації компілятору TypeScript про файл або модуль. Ці директиви можуть бути розміщені в головному файлі або на початку модульного файлу. TypeScript компілятор розуміє ці директиви та використовує їх для налаштування компіляції, підключення залежностей, генерації документації тощо.`,
          }, {
            code: false,
            label: '',
            description: `/// <reference path="..." />: використовується для вказівки залежностей, які потрібно включити в проект. Ця директива дозволяє включати залежності, що не є модулями, наприклад, бібліотеки JavaScript, які не мають вбудованої підтримки модулів.`,
          }, {
            code: false,
            label: '',
            description: `/// <reference types="..." />: використовується для вказівки типів, які потрібно включити в проект. Ця директива дозволяє включати типи для зовнішніх бібліотек, які не мають вбудованої підтримки в TypeScript.`,
          }, {
            code: false,
            label: '',
            description: `/// <reference lib="..." />: використовується для включення бібліотеки типів, що містить різноманітні типові оголошення, які використовуються в проекті. Ця директива дозволяє включати певні типи, які використовуються в проекті, наприклад, типи для роботи з промісами або типи для роботи з масивами.`,
          }, {
            code: false,
            label: '',
            description: `/// <amd-module />: використовується для позначення модуля як AMD-модуля. Ця директива дозволяє включати TypeScript-модулі в проекти, які використовують AMD-завантажувач.`,
          }, {
            code: false,
            label: '',
            description: `/// <esModuleInterop /> використовується в TypeScript для налаштування підтримки інтероперації модулів ES та CommonJS.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке зовнішні оголошення змінних (ambient declaration) у TypeScript?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Зовнішні оголошення змінних (ambient declaration) - це механізм, що дозволяє оголошувати типи для коду, який не написаний на TypeScript.`,
          }, {
            code: false,
            label: '',
            description: `Зовнішнє оголошення змінної містить ключове слово declare, після якого йде оголошення змінної, функції, класу, інтерфейсу тощо. Оголошення містить лише типи, а не реалізацію.`,
          }, {
            code: true,
            label: 'Ось приклад зовнішнього оголошення змінної для функції fetch():',
            description: `declare function fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;`,
          }, {
            code: false,
            label: '',
            description: `Це дозволяє нам використовувати функцію fetch() у TypeScript, незалежно від того, чи була вона написана на TypeScript чи на JavaScript. Також, під час компіляції TypeScript не буде перевіряти реалізацію fetch(), але будуть перевірені типи, що зазначені в зовнішньому оголошенні.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між абстрактним класом (abstract class) та інтерфейсом (interface)?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Інтерфейс (interface) та абстрактний клас (abstract class) є двома різними засобами абстракції, які забезпечують структуру та типізацію коду в TypeScript. Основна різниця між ними полягає в тому, що інтерфейси описують поведінку або контракти, тоді як абстрактні класи містять реалізацію.`,
          }, {
            code: false,
            label: 'Інтерфейс (interface):',
            description: `Описує форму об'єкта.`,
          }, {
            code: false,
            label: '',
            description: `Може містити лише оголошення методів, властивостей, індексів та конструкторів.`,
          }, {
            code: false,
            label: '',
            description: `Не може містити реалізацію.`,
          }, {
            code: false,
            label: '',
            description: `Не може мати модифікаторів доступу, таких як public, private, protected.`,
          }, {
            code: false,
            label: '',
            description: `Може наслідувати інші інтерфейси.`,
          }, {
            code: false,
            label: '',
            description: `Може бути реалізований класами та об'єктами.`,
          }, {
            code: true,
            label: 'Ось приклад інтерфейсу:',
            description: `interface Shape {
  color: string;
  getArea(): number;
}
`,
          }, {
            code: false,
            label: 'Абстрактний клас (abstract class):',
            description: `Описує базову реалізацію класу, яку можна успадкувати та розширити.`,
          }, {
            code: false,
            label: '',
            description: `Може містити оголошення методів, властивостей та конструкторів, які можуть бути перевизначені у дочірніх класах.`,
          }, {
            code: false,
            label: '',
            description: `Може містити абстрактні методи, які потрібно реалізувати у дочірніх класах.`,
          }, {
            code: false,
            label: '',
            description: `Може мати модифікатори доступу, такі як public, private, protected.`,
          }, {
            code: false,
            label: '',
            description: `Не може бути створений окремо, ми можемо створювати лише його дочірні класи.`,
          }, {
            code: false,
            label: '',
            description: `Може бути успадкований.`,
          }, {
            code: true,
            label: 'Ось приклад абстрактного класу:',
            description: `abstract class Animal {
  constructor(public name: string) {}

  abstract makeSound(): void;

  move(distanceInMeters: number = 0) {
    console.log(\`$ {this.name} moved $ {distanceInMeters}m.\`);
  }
}
`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які елементи ООП підтримуються у TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'TypeScript - це розширена версія JavaScript, яка підтримує об\'єктно-орієнтоване програмування (ООП). TypeScript підтримує багато елементів ООП, включаючи:',
            description: `1. Класи: TypeScript дозволяє створювати класи з полями (змінні) та методами (функції), які можуть бути викликані на об'єктах класу.`,
          }, {
            code: false,
            label: '',
            description: `2. Об'єкти: TypeScript підтримує об'єкти, які можуть мати поля (змінні) та методи (функції).`,
          }, {
            code: false,
            label: '',
            description: `3. Наслідування: TypeScript підтримує наслідування класів, що дозволяє створювати новий клас, що успадковує властивості та методи від іншого класу.`,
          }, {
            code: false,
            label: '',
            description: `4. Інтерфейси: TypeScript дозволяє створювати інтерфейси, які визначають структуру об'єкта, тобто список полів та їх типів, які має реалізувати об'єкт.`,
          }, {
            code: false,
            label: '',
            description: `5. Абстрактні класи та методи: TypeScript підтримує абстрактні класи та методи, які не мають реалізації, але можуть бути успадковані та реалізовані в похідних класах.`,
          }, {
            code: false,
            label: '',
            description: `6. Інкапсуляція: TypeScript дозволяє забезпечити захист поля класу від прямого доступу ззовні.`,
          }, {
            code: false,
            label: '',
            description: `7. Поліморфізм: TypeScript підтримує поліморфізм, тобто можливість використовувати один метод з різними аргументами та повертати різні типи даних.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Модифікатори доступу до TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'Модифікатори доступу до TypeScript',
            description: `Модифікатори доступу - це ключові слова в TypeScript, які використовуються для зміни доступності полів та методів класів. TypeScript підтримує три модифікатори доступу: public, private та protected.`,
          }, {
            code: false,
            label: '',
            description: `1. public - поля та методи з модифікатором public доступні з будь-якого місця програми, якщо звернення до них здійснюється через об'єкт класу. Якщо модифікатор не вказується явно, то він за замовчуванням є public.`,
          }, {
            code: false,
            label: '',
            description: `2. private - поля та методи з модифікатором private доступні тільки в межах класу, в якому вони оголошені. Інші класи та об'єкти не можуть отримати доступ до цих полів та методів.`,
          }, {
            code: false,
            label: '',
            description: `3. protected - поля та методи з модифікатором protected доступні в межах класу та його похідних класів. Інші класи та об'єкти не можуть отримати доступ до цих полів та методів.`,
          }, {
            code: true,
            label: '',
            description: `class Person {
  public name: string; // доступний з будь-якого місця
  private age: number; // доступний тільки всередині класу
  protected gender: string; // доступний в межах класу та його похідних класів

  constructor(name: string, age: number, gender: string) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }

  public getAge(): number {
    return this.age;
  }

  private setAge(age: number): void {
    this.age = age;
  }

  protected getGender(): string {
    return this.gender;
  }
}

class Student extends Person {
  public studentId: number;

  constructor(name: string, age: number, gender: string, studentId: number) {
    super(name, age, gender);
    this.studentId = studentId;
  }

  public getDetails(): string {
    return \`Name: $ {this.name}, Age: $ {this.getAge()}, Gender: $ {this.getGender()}, Student ID: $ {this.studentId}\`;
  }
}

const person = new Person('John Doe', 30, 'male');
console.log(person.name); // доступно
console.log(person.age); // недоступно (поле з модифікатором \`private\`)
console.log(person.gender); // недоступно (поле з модифікатором \`protected\`)

const student = new Student('Jane Doe', 20, 'female', 123);
console.log(student.getDetails()); // "Name: Jane Doe,
`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між внутрішнім (Internal Module) та зовнішнім модулями (External Module)?',
        descriptions: [
          {
            code: false,
            label: 'В TypeScript є два способи організації коду в модулі: внутрішній (Internal Module) та зовнішній модулі (External Module)',
            description: `Внутрішній модуль є набором функцій, класів, змінних та інших елементів, що оголошені всередині тіла одного файлу TypeScript. Цей підхід дозволяє організовувати код в більш структурований спосіб, відокремлюючи логіку від інших частин коду в тому ж файлі.`,
          }, {
            code: true,
            label: 'Наприклад, ось приклад внутрішнього модуля:',
            description: `// person.ts
namespace MyNamespace {
  export class Person {
    private name: string;

    constructor(name: string) {
      this.name = name;
    }

    public greet(): void {
      console.log(\`Hello, my name is $ {this.name}\`);
    }
  }
}

const person = new MyNamespace.Person('John Doe');
person.greet();
`,
          }, {
            code: false,
            label: '',
            description: `Зовнішній модуль, з іншого боку, є окремим файлом з кодом, який можна використовувати у інших файлах TypeScript за допомогою ключового слова import. Зовнішні модулі дозволяють повторне використання коду, збільшення структурованості та зменшення залежностей між частинами програми.`,
          }, {
            code: true,
            label: 'Наприклад, ось приклад зовнішнього модуля:',
            description: `// person.ts
export class Person {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  public greet(): void {
    console.log(\`Hello, my name is $ {this.name}\`);
  }
}
`,
          }, {
            code: true,
            label: '',
            description: `// app.ts
import { Person } from './person';

const person = new Person('John Doe');
person.greet();
`,
          }, {
            code: false,
            label: 'Різниця',
            description: `Отже, різниця між внутрішнім та зовнішнім модулями в тому, що внутрішній модуль містить код, який є частиною одного файлу TypeScript, тоді як зовнішній модуль - це окремий файл з кодом, який можна використовувати в інших файлах TypeScript за допомогою ключового слова import.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як TypeScript підтримує необов`язкові та дефолтні параметри функції?',
        descriptions: [
          {
            code: false,
            label: 'TypeScript підтримує необов\'язкові та дефолтні параметри функції за допомогою спеціальних синтаксичних конструкцій.',
            description: `Необов'язкові параметри визначаються за допомогою символу ? після імені параметру. Наприклад, ось функція з необов'язковим параметром в TypeScript:`,
          }, {
            code: true,
            label: '',
            description: `function greet(name?: string) {
  if (name) {
    console.log(\`Hello, $ {name}!\`);
  } else {
    console.log(\`Hello, anonymous!\`);
  }
}

greet(); // "Hello, anonymous!"
greet("John"); // "Hello, John!"
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі, параметр name є необов'язковим, оскільки він може бути опущений при виклику функції. Якщо він не опущений, його значення за замовчуванням є undefined`,
          }, {
            code: false,
            label: '',
            description: `Дефолтні параметри визначаються за допомогою символу = після імені параметру. Наприклад, ось функція з дефолтним параметром в TypeScript:`,
          }, {
            code: true,
            label: '',
            description: `function greet(name: string = "anonymous") {
  console.log(\`Hello, $ {name}!\`);
}

greet(); // "Hello, anonymous!"
greet("John"); // "Hello, John!"
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі, параметр name має значення за замовчуванням "anonymous". Якщо параметр не заданий при виклику функції, його значення автоматично стає значенням за замовчуванням.`,
          }, {
            code: false,
            label: '',
            description: `Значення за замовчуванням можна використовувати разом з необов'язковими параметрами. Наприклад, ось функція з необов'язковим та дефолтним параметрами в TypeScript:`,
          }, {
            code: true,
            label: '',
            description: `function greet(name: string = "anonymous", message?: string) {
  if (message) {
    console.log(\`$ {message}, $ {name}!\`);
  } else {
    console.log(\`Hello, $ {name}!\`);
  }
}

greet(); // "Hello, anonymous!"
greet("John"); // "Hello, John!"
greet("John", "Goodbye"); // "Goodbye, John!"
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі, параметр <name> має значення за замовчуванням "<anonymous>", а параметр <message> є необов'язковим. Якщо <mess>age не заданий, використовується рядок "<Hello>". Якщо <message> заданий, використовується його значення.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке перерахування (enum)?',
        descriptions: [
          {
            code: false,
            label: 'Enum',
            description: `Перерахування (enum) в TypeScript - це спеціальний тип даних, який дозволяє визначити набір іменованих констант, які можуть використовуватися в коді. Перерахування дозволяють створювати зрозуміліші та легкі для розуміння програми, що містять константи змінного типу.`,
          }, {
            code: false,
            label: '',
            description: `В TypeScript перерахування визначаються за допомогою ключового слова enum. Наприклад, ось простий приклад перерахування, що визначає кольори:`,
          }, {
            code: true,
            label: '',
            description: `enum Color {
  Red,
  Green,
  Blue,
}

let backgroundColor = Color.Red;
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі ми визначили перерахування Color, яке містить три іменовані константи: Red, Green та Blue. При використанні перерахування ми можемо присвоїти змінній значення однієї з цих констант.`,
          }, {
            code: false,
            label: '',
            description: `За замовчуванням, першій константі присвоюється значення 0, другій - 1, третій - 2 і т.д. Але ми можемо вказати числове значення для будь-якої з констант, якщо потрібно. Наприклад:`,
          }, {
            code: true,
            label: '',
            description: `enum Color {
  Red = 0,
  Green = 1,
  Blue = 2,
}
`,
          }, {
            code: false,
            label: '',
            description: `Ми також можемо отримати ім'я константи за її числовим значенням. Наприклад, для того, щоб отримати ім'я константи, що має числове значення 1, ми можемо використати такий код:`,
          }, {
            code: true,
            label: '',
            description: `let colorName = Color[1];
console.log(colorName); // "Green"
`,
          }, {
            code: false,
            label: '',
            description: `Перерахування в TypeScript можуть мати додаткові функції та методи, наприклад, можуть мати конструктор і методи. Також можна використовувати перерахування в різних контекстах, наприклад, в параметрах функцій і в об'єктах.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Навіщо в TypeScript використовується NoImplicitAny?',
        descriptions: [
          {
            code: false,
            label: 'NoImplicitAny',
            description: `В TypeScript, NoImplicitAny - це параметр компілятора, який забороняє неявне присвоєння типу any змінним і параметрам функцій, якщо вони не мають явно визначеного типу.`,
          }, {
            code: false,
            label: '',
            description: `За замовчуванням, якщо тип не вказаний явно, TypeScript автоматично визначає тип змінної або параметра як any. Це може призвести до того, що TypeScript не виявляє помилок в коді, що можуть бути проблемами відладки в майбутньому.`,
          }, {
            code: true,
            label: 'Наприклад, наступний код не має помилок компіляції, але містить помилку логіки:',
            description: `function add(a, b) {
  return a + b;
}

const result = add(2, '2'); // '22'
`,
          }, {
            code: false,
            label: '',
            description: `В цьому прикладі <a> і <b> не мають визначеного типу, тому TypeScript встановлює їх тип як <any>. Під час виконання коду <2> і '<2>' конкатенуються як рядки, оскільки <b> має тип <any> і TypeScript не виявляє цю помилку під час компіляції.`,
          }, {
            code: false,
            label: '',
            description: `Якщо ввімкнути параметр NoImplicitAny, то при компіляції коду, TypeScript виведе помилку компіляції, що дозволить виявити цю помилку до того, як вона виникне під час виконання програми.`,
          }, {
            code: false,
            label: '',
            description: `Відповідно, використання параметра NoImplicitAny дозволяє більш точно визначити типи в програмі, що поліпшує якість і зрозумілість коду, зменшує кількість помилок виконання і полегшує відладку програми.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між типами “Об\'єднання” (|) та “Перетин” (&)?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `У TypeScript оператори | та & використовуються для відповідно об'єднання та перетину типів.`,
          }, {
            code: false,
            label: '',
            description: `Оператор | використовується для створення типу, який може мати один з двох або більше можливих значень. Наприклад, якщо ми хочемо створити тип, який може містити або рядок, або число, то ми можемо використати оператор | таким чином:`,
          }, {
            code: true,
            label: '',
            description: `let myVar: string | number;
myVar = 'Hello'; // допустиме
myVar = 123; // допустиме
myVar = true; // недопустиме
`,
          }, {
            code: false,
            label: '',
            description: `Оператор & використовується для створення типу, який містить всі властивості двох або більше типів. Наприклад, якщо ми маємо об'єкт, який містить властивості "name" та "age", і ми хочемо створити тип, який містить тільки ці дві властивості, то ми можемо використати оператор & таким чином:`,
          }, {
            code: true,
            label: '',
            description: `interface Person {
  name: string;
  age: number;
}

interface Employee {
  id: number;
  department: string;
}

type EmployeeRecord = Person & Employee;

const employee: EmployeeRecord = {
  name: 'John',
  age: 30,
  id: 123,
  department: 'IT',
};
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі ми створили тип <EmployeeRecord>, який містить всі властивості типу <Pers>on та всі властивості типу <Employee>. Об'єкт <employee> містить всі ці властивості, тому він відповідає типу <EmployeeRecord>.`,
          }, {
            code: false,
            label: 'Основна відмінність',
            description: `Отже, різниця між типами | та & полягає в тому, що оператор | об'єднує типи, що дозволяє значенню бути одним з декількох можливих типів, тоді як оператор & об'єднує типи, що дозволяє створити тип, який містить всі властивості двох або більше типів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке загальні типи (generic) у TypeScript?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Загальні типи (generics) у TypeScript дозволяють створювати функції та класи, які можуть працювати з будь-яким типом даних, а не з конкретним. Загальні типи дозволяють нам створювати код, який є більш гнучким, повторно використовуваним та безпечним у відношенні типів даних.`,
          }, {
            code: false,
            label: '',
            description: `Загальні типи визначаються за допомогою параметрів типу, які вказуються в кутових дужках (<>). У прикладі нижче, ми використовуємо параметр типу T для визначення типу масиву:`,
          }, {
            code: true,
            label: '',
            description: `function reverse<T>(items: T[]): T[] {
  return items.reverse();
}

const letters = ['a', 'b', 'c'];
const numbers = [1, 2, 3];

const reversedLetters = reverse(letters);
const reversedNumbers = reverse(numbers);
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі, T - це параметр типу, який дозволяє визначити будь-який тип даних, переданий функції reverse. Ми передаємо масив букв та чисел до функції, і вона повертає перевернутий масив того ж типу.`,
          }, {
            code: true,
            label: 'Загальні типи можуть також використовуватися для визначення типу класу. Наприклад:',
            description: `class Box<T> {
  contents: T;

  constructor(value: T) {
    this.contents = value;
  }
}

const box1 = new Box("hello");
const box2 = new Box(42);
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі ми визначаємо клас Box за допомогою параметра типу T, який вказує на тип вмісту, збереженого в Box. При створенні нового екземпляру класу, ми передаємо значення типу T в конструктор.`,
          }, {
            code: false,
            label: '',
            description: `Загальні типи є потужним інструментом у TypeScript, який дозволяє створювати код, який може працювати з будь-яким типом даних. Вони дозволяють зменшити дублювання коду та зробити код більш безпечним у відношенні типів даних.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які області видимості доступні у TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'У TypeScript доступні наступні модифікатори доступу:',
            description: `public - Змінні та методи з цим модифікатором доступні з будь-якої частини коду, включаючи поза класом.`,
          }, {
            code: false,
            label: '',
            description: `private - Змінні та методи з цим модифікатором доступні тільки з середини класу, в якому вони визначені. Їх неможливо доступати ззовні класу.`,
          }, {
            code: false,
            label: '',
            description: `protected - Змінні та методи з цим модифікатором доступні тільки з середини класу, в якому вони визначені, а також з середини підкласів.`,
          }, {
            code: false,
            label: '',
            description: `readonly - Цей модифікатор може бути використаний для забезпечення того, що значення змінної може бути встановлене тільки один раз, під час її ініціалізації.`,
          }, {
            code: false,
            label: 'У TypeScript також доступні модифікатори доступу до конструкторів, які використовуються для забезпечення доступу до властивостей класу під час його створення:',
            description: `public - Конструктори з цим модифікатором доступні з будь-якої частини коду, включаючи поза класом.`,
          }, {
            code: false,
            label: '',
            description: `protected - Конструктори з цим модифікатором доступні тільки з середини класу, в якому вони визначені, а також з середини підкласів.`,
          }, {
            code: false,
            label: '',
            description: `private - Конструктори з цим модифікатором доступні тільки з середини класу, в якому вони визначені.`,
          }, {
            code: false,
            label: '',
            description: `Ці модифікатори дозволяють забезпечити доступ до змінних та методів класу у залежності від їх видимості та контексту використання. Вони допомагають зменшити кількість помилок у коді та роблять його більш безпечним.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке .map файл, як і навіщо його використовувати?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `.map файл - це файл, який містить інформацію про зв'язок між оригінальним кодом та відповідним кодом JavaScript, що був згенерований компілятором TypeScript. Він містить інформацію про вихідний файл, номери рядків та стовпців, що відповідають кожному рядку вихідного коду та вихідні імена змінних та функцій.`,
          }, {
            code: false,
            label: '',
            description: `.map файл можна використовувати для відлагодження коду TypeScript у браузері чи середовищі Node.js, де виконується згенерований JavaScript код. Під час відлагодження, браузер або середовище Node.js використовує інформацію з .map файлу для відображення вихідного коду TypeScript замість згенерованого коду JavaScript. Це полегшує відлагодження коду, оскільки ви можете бачити вихідний код, з яким працюєте, замість згенерованого коду, який може бути складним для розуміння.`,
          }, {
            code: false,
            label: '',
            description: `Для генерації .map файлів у TypeScript необхідно додати параметр --sourceMap при компіляції. Він дозволяє генерувати .map файл разом із згенерованим JavaScript кодом. За замовчуванням .map файл зберігається поруч з вихідним файлом JavaScript, але це можна змінити за допомогою параметра --mapRoot, який дозволяє задати іншу директорію для збереження .map файлу.`,
          }, {
            code: false,
            label: '',
            description: `.map файли є корисним інструментом для відлагодження коду, що допомагає зробити розробку програмного забезпечення в TypeScript більш ефективною та зменшити кількість помилок.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Чи можна використовувати TypeScript у серверній розробці?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Так, TypeScript можна використовувати для розробки серверних додатків. TypeScript підтримує Node.js, який є платформою для виконання JavaScript на стороні сервера, тому TypeScript можна використовувати для розробки серверних додатків з Node.js.`,
          }, {
            code: false,
            label: '',
            description: `Завдяки сильній типізації та іншим функціональним можливостям TypeScript, таким як перевірка типів під час компіляції та властивості об'єктно-орієнтованого програмування, TypeScript є привабливим вибором для розробки серверних додатків з Node.js. TypeScript дозволяє створювати більш безпечний та чистий код, що полегшує розуміння коду для інших розробників.`,
          }, {
            code: false,
            label: '',
            description: `Більше того, TypeScript має ряд фреймворків та бібліотек, що сприяють розробці серверних додатків. Наприклад, NestJS - це фреймворк для розробки серверних додатків на Node.js з використанням TypeScript. НестJS надає структуру для розробки серверної частини додатків та спрощує роботу з HTTP-запитами, WebSocket та іншими протоколами.`,
          }, {
            code: false,
            label: '',
            description: `Отже, TypeScript є гарним вибором для розробки серверних додатків, оскільки він допомагає зробити код безпечнішим, чистішим та більш ефективним, та має ряд фреймворків та бібліотек для розробки серверних додатків.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Для чого TypeScript використовують ключове слово declare?',
        descriptions: [
          {
            code: false,
            label: 'Declare',
            description: `Ключове слово declare в TypeScript використовується для оголошення типів, які визначені за межами файлу TypeScript. Це означає, що замість визначення типів у файлі TypeScript, ми можемо вказати, що ці типи визначені у зовнішньому контексті, такому як бібліотека JavaScript.`,
          }, {
            code: false,
            label: '',
            description: `Ключове слово declare може бути використане для оголошення типів зовнішніх бібліотек, модулів, змінних та функцій. Наприклад, якщо ми використовуємо зовнішню бібліотеку, можна використати ключове слово declare для оголошення типів змінних, функцій та інтерфейсів, які використовуються в цій бібліотеці.`,
          }, {
            code: false,
            label: '',
            description: `Також ключове слово declare може бути використане для оголошення типів у вбудованих модулях TypeScript. Наприклад, ми можемо використати declare module для оголошення типів, які належать певному модулю, щоб TypeScript знав, як взаємодіяти з цим модулем.`,
          }, {
            code: false,
            label: '',
            description: `Загалом, ключове слово declare в TypeScript дозволяє оголошувати типи, які визначені в зовнішньому контексті, та допомагає TypeScript розуміти, як взаємодіяти з цими типами у ваших програмах.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між типами void, never та unknown?',
        descriptions: [
          {
            code: false,
            label: 'У TypeScript є кілька спеціальних типів, які можуть бути незрозумілими або заплутаними для початківців. Розглянемо різницю між типами void, never та unknown:',
            description: `1. void - це тип, який представляє відсутність значення. Він використовується для функцій, які не повертають значення. Наприклад:`,
          }, {
            code: true,
            label: '',
            description: `function log(message: string): void {
  console.log(message);}`,
          }, {
            code: false,
            label: '',
            description: `Тут функція log не повертає значення, тому тип її повернення вказано як void.`,
          }, {
            code: false,
            label: '',
            description: `2. never - це тип, який представляє значення, які ніколи не відбуваються. Він використовується для функцій, які завершуються або кидають помилки, а також для значень, які не можуть існувати. Наприклад:`,
          }, {
            code: true,
            label: '',
            description: `function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {
    // do something
  }
}

function returnNever(): never {
  return throwError("An error occurred.");
}
`,
          }, {
            code: false,
            label: '',
            description: `У функції throwError завжди виникає помилка, тому вона повертає тип never. У функції infiniteLoop немає повернення, тому вона також повертає тип never. Функція returnNever повертає результат виклику функції throwError, тому вона також повертає тип never.`,
          }, {
            code: false,
            label: '',
            description: `3. unknown - це тип, який представляє значення, про які ми нічого не знаємо. Він використовується, коли ми не можемо визначити тип змінної на етапі компіляції. Наприклад:`,
          }, {
            code: true,
            label: '',
            description: `let x: unknown = 10;

if (typeof x === "number") {
  console.log(x + 5); // OK
}

let y: unknown = "hello";

// Error: Object is of type 'unknown'.
// console.log(y.toUpperCase());
`,
          }, {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо змінну x з типом unknown, яка спочатку містить число, а потім порівнюється з типом "number". Якщо тип змінної x є "number", то викон`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як ви відловлюєте помилки в коді TypeScript?',
        descriptions: [
          {
            code: false,
            label: 'Існує кілька способів відловлювання помилок в коді TypeScript:',
            description: `1. Компіляція: TypeScript перевіряє типи в коді на етапі компіляції. Якщо код містить помилки типів, компілятор виведе помилки і не дозволить збірку програми.`,
          }, {
            code: false,
            label: '',
            description: `2. IDE / Редактор: Більшість редакторів, які підтримують TypeScript, мають можливість підказування типів та відловлювання помилок під час редагування коду.`,
          }, {
            code: false,
            label: '',
            description: `3. Використання linter: Linter - це інструмент, який використовується для автоматичної перевірки коду на відповідність певним правилам і стандартам. На приклад, ESLint для TypeScript.`,
          }, {
            code: false,
            label: '',
            description: `4. Тестування: Для виявлення помилок у програмі, які не можна визначити під час компіляції або перевірки коду в редакторі, можна написати тести, щоб переконатися в тому, що програма працює як очікувалось.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Webpack, Babel',
    questions: [
      {
        id: generateUUID(),
        question: 'Webpack',
        descriptions: [
          {
            code: false,
            label: 'Part 1',
            description: `https://codeguida.com/post/454`,
          }, {
            code: false,
            label: 'Part 2',
            description: `https://codeguida.com/post/688`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Babel',
        descriptions: [
          {
            code: false,
            label: 'Babel',
            description: `https://codeguida.com/post/2297`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Configuration project',
    questions: [
      {
        id: generateUUID(),
        question: 'Eslint',
        descriptions: [
          {
            code: false,
            label: 'Eslint, як його використовувати у проектах',
            description: `https://dev.ua/blogs/posts/sinevych`,
          },
          {
            code: false,
            label: 'Основи Eslint',
            description: `https://www.youtube.com/watch?v=Q794gDZcY6E`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Prettier',
        descriptions: [
          {
            code: false,
            label: 'Prettier, як його використовувати у проектах',
            description: `https://www.digitalocean.com/community/tutorials/how-to-format-code-with-prettier-in-visual-studio-code-ru`,
          }, {
            code: false,
            label: 'Prettier, як його використовувати у проектах',
            description: `https://www.youtube.com/watch?v=Cj9cCoIUb-w`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'React JS',
    questions: [
      {
        id: generateUUID(),
        question: 'Що таке реакт?',
        descriptions: [
          {
            code: false,
            label: 'React',
            description: `React — відкрита JavaScript бібліотека для створення інтерфейсів користувача, яка покликана вирішувати проблеми часткового оновлення вмісту вебсторінки, з якими стикаються в розробці односторінкових застосунків.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Особливості React',
        descriptions: [
          {
            code: false,
            label: 'Які особливості має react',
            description: `1. Компонентний підхід: React розбиває користувацький інтерфейс на невеликі та незалежні компоненти, які можуть бути повторно використані.`,
          },{
            code: false,
            label: '',
            description: `2. Віртуальний DOM: React використовує віртуальний DOM для оптимізації оновлення інтерфейсу. Зміни відбуваються спочатку у віртуальному DOM, а потім ефективно оновлюються на сторінці.`,
          },{
            code: false,
            label: '',
            description: `3. Одностороннє зв'язування даних: React пропагує дані у одному напрямку, що полегшує відслідковування та управління станом даних.`,
          },{
            code: false,
            label: '',
            description: `JSX: React використовує спеціальну синтаксичну конструкцію JSX, яка дозволяє вписувати HTML-подібний код безпосередньо в JavaScript.`,
          },{
            code: false,
            label: '',
            description: `Реактивність: React забезпечує швидке реагування на зміни даних та автоматично оновлює відповідні частини інтерфейсу.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Virtual DOM? Як він працює з React?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Віртуальний DOM (VDOM) - це концепція, що використовується в React для оптимізації оновлення інтерфейсу користувача.`,
          },{
            code: false,
            label: '',
            description: `У React, замість безпосередньої маніпуляції реальним DOM, створюється віртуальне представлення (віртуальний DOM) всього інтерфейсу. Це структура даних, яка відображає реальний стан DOM-дерева. Коли відбуваються зміни в стані даних, React порівнює нове віртуальне DOM з попереднім станом.`,
          },{
            code: false,
            label: '',
            description: `React аналізує різницю між попереднім та новим віртуальним DOM і ефективно оновлює тільки ті частини реального DOM, які потребують змін. Цей процес називається "поновленням віртуального DOM". Порівняння та оновлення робляться за допомогою алгоритмів порівняння ключів та визначення різниці між елементами.`,
          },{
            code: false,
            label: '',
            description: `Використання віртуального DOM дозволяє React оптимізувати процес оновлення інтерфейсу та зменшити кількість безпосередніх маніпуляцій з реальним DOM. Це призводить до покращеної продуктивності та швидшої відповіді на зміни в даних.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Навіщо потрібен атрибут key при рендері списків?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Атрибут "key" використовується при рендері списків в бібліотеках для створення користувацького інтерфейсу, таких як React. Цей атрибут допомагає ідентифікувати унікальність кожного елемента списку і використовується для оптимізації процесу віртуального відображення.`,
          },{
            code: false,
            label: '',
            description: `Коли ми маємо список елементів, React використовує атрибут "key" для відстеження та ідентифікації змін у цьому списку. Кожен елемент списку повинен мати унікальний ключ, який дозволяє React ефективно визначати, які елементи були додані, видалені або змінені. Це допомагає зберегти стан і виконати оптимізації при оновленні списку.`,
          },{
            code: false,
            label: '',
            description: `Без атрибута "key" React може зазнавати проблем з віртуальним відображенням, яке призводить до неефективної роботи і помилок відображення. Також, відсутність ключа може призвести до втрати стану компонентів при перерендерингу списку. `,
          },{
            code: false,
            label: '',
            description: `Отже, атрибут "key" є важливим елементом при рендері списків і допомагає забезпечити правильну роботу React компонентів, зберігаючи їх стан і забезпечуючи оптимізацію віртуального відображення.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке PureComponent?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `PureComponent є спеціальним типом компонента в бібліотеці React, який надає автоматичну оптимізацію перерендерингу.`,
          }, {
            code: false,
            label: '',
            description: `Клас PureComponent є підкласом класу Component в React. Основна відмінність між ними полягає в тому, що PureComponent реалізує метод shouldComponentUpdate автоматично. Цей метод порівнює попередній стан і властивості компонента з новими і визначає, чи потрібно виконати перерендеринг компонента.`,
          }, {
            code: false,
            label: '',
            description: `Використання PureComponent може сприяти покращенню продуктивності додатка, оскільки він автоматично оптимізує процес перерендерингу шляхом виконання поверхневого порівняння стану і властивостей. Якщо стан і властивості компонента не змінилися, PureComponent запобігає перерендерингу і зберігає попередній результат рендерингу.`,
          },{
            code: false,
            label: '',
            description: `Однак, важливо пам'ятати, що автоматична оптимізація PureComponent ґрунтується на поверхневому порівнянні, тобто вона не порівнює вкладені об'єкти або масиви. У таких випадках можуть виникнути проблеми з некоректним оновленням компонентів. Тому, при використанні PureComponent, необхідно враховувати цю особливість та переконатися, що властивості компонента мають імутабельний характер.`,
          },{
            code: false,
            label: '',
            description: `Узагалі, використання PureComponent варто розглядати, коли компонент має просту логіку та незначну кількість властивостей, і його перерендеринг можна оптимізувати шляхом порівняння попереднього та нового стану/властивостей.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Компонент вищого ладу (Higher-Order Component/HOC)?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Компонент вищого ладу (Higher-Order Component або HOC) є одним із шаблонів проектування в бібліотеці React, який дозволяє повторно використовувати логіку компонентів та додавати додаткові функції до існуючих компонентів.`,
          },{
            code: false,
            label: '',
            description: `HOC є функцією, яка приймає вхідний компонент і повертає новий компонент. Цей новий компонент може мати додаткову логіку, здійснювати обробку даних, звертатися до зовнішніх сервісів або додавати додаткові властивості до переданого компонента.`,
          },{
            code: false,
            label: '',
            description: `HOC дозволяє забезпечити повторне використання логіки та функціональності між різними компонентами, що зменшує дублювання коду. Він також дозволяє розширювати функціональність компонентів без потреби модифікувати їх самостійно.`,
          },{
            code: false,
            label: '',
            description: `Наприклад, можна створити HOC, який додає логіку аутентифікації до компонента. Цей HOC може перевіряти, чи користувач має доступ до певного роуту, перевіряти його статус аутентифікації та відповідно перенаправляти на інші сторінки. Ця логіка може бути використана для будь-якого компонента, який потребує аутентифікації, без необхідності дублювати код.`,
          },{
            code: false,
            label: '',
            description: `Компоненти вищого ладу є потужним інструментом для розширення функціональності та підвищення повторного використання коду в React. Вони дозволяють виокремити спільну логіку і функціональність в окремі компоненти, що полегшує розробку та підтримку додатків.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між керованими (controlled) та не керованими (uncontrolled) компонентами?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Різниця між керованими (controlled) та не керованими (uncontrolled) компонентами полягає у тому, як управляється та отримується значення елемента вводу (input) в React.`,
          },{
            code: false,
            label: '',
            description: `1. Керовані компоненти (controlled components):`,
          },{
            code: false,
            label: '',
            description: `Значення елемента вводу (input value) контролюється станом (state) компонента.`,
          },{
            code: false,
            label: '',
            description: `Значення передається через властивість value компонента, і його зміна викликає оновлення стану.`,
          },{
            code: false,
            label: '',
            description: `При зміні значення елемента вводу, React відображає нове значення, оновлює стан та перерендерює компонент.`,
          },{
            code: false,
            label: '',
            description: `Керовані компоненти надають більшу контроль над значеннями та поведінкою елементів вводу.`,
          },{
            code: false,
            label: '',
            description: `2. Не керовані компоненти (uncontrolled components):`,
          },{
            code: false,
            label: '',
            description: `Значення елемента вводу не контролюється станом компонента.`,
          },{
            code: false,
            label: '',
            description: `Значення не передається через властивість value, а отримується за допомогою посилання на елемент в DOM.`,
          },{
            code: false,
            label: '',
            description: `Зміни значення елемента вводу не впливають на стан компонента і не викликають його перерендеринг.`,
          },{
            code: false,
            label: '',
            description: `Значення елемента вводу можна отримати за допомогою посилання на DOM, наприклад, ref.current.value.`,
          },{
            code: false,
            label: '',
            description: `Вибір між керованими та не керованими компонентами залежить від конкретної ситуації та вимог проекту. Керовані компоненти надають більшу контроль та зручність в управлінні значеннями елементів вводу, але можуть потребувати більше коду. Не керовані компоненти можуть бути корисними в простих сценаріях, де не потрібна детальна контроль над значеннями.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Методи життєвого циклу компонента у React?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `У React є кілька методів життєвого циклу, які викликаються на різних етапах створення, оновлення та знищення компонента. Однак, з введенням хуків (hooks) у React 16.8 версії, більшість з цих методів були замінені хуками. Ось список найбільш поширених методів життєвого циклу компонента до введення хуків:`,
          }, {
            code: false,
            label: '',
            description: `1. constructor(): Цей метод викликається при створенні компонента. Використовується для ініціалізації стану та встановлення початкових значень.`,
          }, {
            code: false,
            label: '',
            description: `2. componentDidMount(): Викликається після того, як компонент був вперше відображений на екрані (mount). Використовується для виконання завантаження даних з сервера, підписок на події або запуску таймерів.`,
          }, {
            code: false,
            label: '',
            description: `3. componentDidUpdate(prevProps, prevState): Викликається після оновлення компонента, тобто після зміни властивостей (props) або стану (state). Використовується для реагування на зміни та виконання певних дій після оновлення компонента.  `,
          }, {
            code: false,
            label: '',
            description: `4. componentWillUnmount(): Викликається перед тим, як компонент буде знищений (unmount). Використовується для очищення ресурсів, таких як відписки від подій або зупинка таймерів.`,
          }, {
            code: false,
            label: '',
            description: `5. shouldComponentUpdate(nextProps, nextState): Цей метод визначає, чи потрібно виконувати оновлення компонента після зміни властивостей (props) або стану (state). Використовується для оптимізації, щоб уникнути непотрібного перерендерингу компонента.`,
          }, {
            code: false,
            label: '',
            description: `Зазначу, що з введенням хуків, які є функціональними компонентами, методи життєвого циклу були замінені хуками, такими як useEffect, useMemo, useCallback і т.д. Ці хуки надають більш зручний спосіб управління життєвим`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Стадії життєвого циклу компонента у React?',
        descriptions: [
          {
            code: false,
            label: 'У React є три основні стадії життєвого циклу компонента:',
            description: `1. Монтаж (Mounting):`,
          },{
            code: false,
            label: '',
            description: ` constructor(): Ініціалізація компонента, встановлення початкового стану та прив'язка методів.`,
          },{
            code: false,
            label: '',
            description: ` render(): Рендеринг компонента та його дочірніх компонентів.`,
          },{
            code: false,
            label: '',
            description: ` componentDidMount(): Викликається після першого рендерингу компонента. Використовується для виконання завантаження даних, підписок на події або запуску таймерів.`,
          },{
            code: false,
            label: '',
            description: `2. Оновлення (Updating):`,
          },{
            code: false,
            label: '',
            description: ` render(): Рендеринг компонента та його дочірніх компонентів.`,
          },{
            code: false,
            label: '',
            description: ` componentDidUpdate(prevProps, prevState): Викликається після оновлення компонента. Використовується для реагування на зміни та виконання певних дій після оновлення компонента.`,
          },{
            code: false,
            label: '',
            description: ` shouldComponentUpdate(nextProps, nextState): Викликається перед оновленням компонента та дозволяє контролювати, чи потрібно виконувати оновлення. Оптимізаційний метод, який дозволяє уникнути непотрібного перерендерингу.`,
          },{
            code: false,
            label: '',
            description: `3. Розмонтовування (Unmounting):`,
          },{
            code: false,
            label: '',
            description: ` componentWillUnmount(): Викликається перед тим, як компонент буде знищений. Використовується для очищення ресурсів, таких як відписки від подій або зупинка таймерів.`,
          },{
            code: false,
            label: '',
            description: `Ці стадії відображають послідовність подій, які відбуваються під час життєвого циклу компонента у React. Зауважу, що з введенням хуків (hooks) у React, функціональні компоненти мають власний спосіб управління стадіями життєвого циклу за допомогою хуків, таких як useEffect, useLayoutEffect, useMemo і т.д.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [
          {
            code: false,
            label: '',
            description: ``,
          },
        ],
      },{
        id: generateUUID(),
        question: 'question 3',
        descriptions: [
          {
            code: false,
            label: '',
            description: ``,
          },
        ],
      },{
        id: generateUUID(),
        question: 'question 3',
        descriptions: [
          {
            code: false,
            label: '',
            description: ``,
          },
        ],
      },{
        id: generateUUID(),
        question: 'question 3',
        descriptions: [
          {
            code: false,
            label: '',
            description: ``,
          },
        ],
      },{
        id: generateUUID(),
        question: 'question 3',
        descriptions: [
          {
            code: false,
            label: '',
            description: ``,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Testing',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Metodologies',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Practical  part',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
];
