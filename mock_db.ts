import generateUUID from './src/services/generateUUID';

export const modules = [
  {
    id: generateUUID(),
    name: 'Internet',
    questions: [
      {
        id: generateUUID(),
        question: 'What is DNS?',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Прогресивний рендеринг',
        descriptions: [
          {
            code: false,
            label: 'Що таке прогресивний рендеринг?',
            description:
              'Прогресивний рендеринг – це назва технологій, що використовуються для прискорення відтворення сторінок (зокрема, для зменшення часу завантаження), щоб показати користувачеві контент якнайшвидше. До того, як широкосмуговий інтернет поширився повсюдно, прогресивний рендеринг зустрічався досить часто.',
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке прогресивний SSR?',
        descriptions: [
          {
            code: false,
            label: 'Прогресивний SSR?',
            description: `SSR (Server-Side Rendering) генерує повний HTML для сторінки на сервері у відповідь на запит (перехід по посиланню). Це дозволяє уникнути додаткових запитів даних, наповнення шаблонів на стороні клієнта, оскільки вони обробляються до того, як браузер отримує відповідь.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке потік документа?',
        descriptions: [
          {
            code: false,
            label: 'Що таке потік документа?',
            description: `Документний потік - це сукупність розподілених у часі і просторі документів, які рухаються по комунікаційним каналам від створювачів та виробників до користувачів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Різниця між адаптивним (adaptive) та чуйним (responsive) дизайнами?',
        descriptions: [
          {
            code: false,
            label: 'Responsive design',
            description: `За найпростішим визначенням, гнучкий дизайн використовує лише один макет веб-сторінки і «гнучко» змінюється так, щоб краще відповідати екрану користувача, будь то настільний комп’ютер, ноутбук, планшет чи мобільний телефон.
Якщо дивитися з більш технічного боку, то гнучкі веб-сторінки використовують CSS медіазапити та маркери розмірів (breakpoints; далі брейкпоінт) для коригування масштабу зображень, переносу (а також масштабування) тексту та інших елементів.`,
          },
          {
            code: false,
            label: 'Adaptive design',
            description: `Загалом вважається, що адаптивний дизайн — це фіксовані макети, які адаптуються до певних розмірів екрану. Коротко кажучи, у вас є кілька версій веб-сторінки, які відповідають якомусь пристрою, на відміну від однієї, статичної сторінки, яка виглядає однаково і змінює порядок (чи змінює розмір вмісту) на всіх пристроях.В адаптивному дизайні прийнято розробляти UI-макети для 6 найпоширеніших ширин екрану: 320, 480, 760, 960, 1200 і 1600 пікселів`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Різниця між Progressive Enhancement та Graceful Degradation?',
        descriptions: [
          {
            code: false,
            label: 'Graceful Degradation || Поступова Деградація',
            description: `Поступова деградація—це стратегія розробки, при якій ваш веб-інтерфейс першочергово призначений для перегляду в сучасних браузерах, тоді як в старих браузерах він відображатиметься з обмеженим набором можливостей, але, як мінімум, з базовим функціоналом. Якщо ми говорим про JavaScript, то це означає, що не весь функціонал може бути доступним, в силу відсутності підтримки окремих JS можливостей. Або ж, сайт функціонуватиме і за умови виключеного JS, але лише у базовому режимі. Щодо CSS, за відсутності підтримки тієї чи іншої CSS властивості, сайт функціонуватиме і матиме зрозумілий вигляд, але не такий красивий як у сучасному броузері, що підтримує останні можливості CSS`,
          },
          {
            code: false,
            label: 'Progressive enhancement || Прогресивне покращення',
            description: `Прогресивне покращення дивиться на проблему підтримки старих браузерів з протилежної сторони — розробка веб-інтерфейсу відбувається поетапно, від простого до складного. На кожному з етапів ми отримуємо завершений веб-інтерфейс, що з кожним етапом стає ще кращим, ще зручнішим. В результаті виходить ресурс, що працює у всіх браузерах.`,
          },
          {
            code: false,
            label: 'Основна відміннсть',
            description: `Основна відмінність між цими двома принципами це те, звідки починається розробка. Якщо починати розробку, орієнтуючись на найстаріший браузер зі списку тих, що повинен підтрумувати ваш продукт, а опісля додавати специфічний функціонал для новіших версій, то це — прогресивне покращення. Якщо ж починати створення веб-інтерфейсу під найновіші браузери, а потім просто ховати чи спрощувати деякі функціональності для старіших — це поступова деградація.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке кросбраузерність?',
        descriptions: [
          {
            code: false,
            label: 'Кросбраузерність',
            description: `Кросбраузерність сайту — це властивість сайту однаково відображатися та функціонувати у відповідності до поставленого завдання в усіх браузерах. Простіше кажучи, таку характеристику дають сайтам, дизайн яких однаковий як в Internet Explorer, так і в Google Chrome.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Babel',
        descriptions: [
          {
            code: false,
            label: 'Що таке Babel? Навіщо він використовується?',
            description: `Babel — можливість писати код «нового стандарту» (з новим функціоналом) не хвилюючись, що цей новий функціонал може не підтримуватись браузерами.`,
          },
          {
            code: false,
            label: 'Що він робить?',
            description: `Babel бере написаний нами код з новим функціоналом та перетворює (транскомпілює) його в аналогічний код, але «старого зразка». Це робиться тому, що саме цей код, код «старого зразка», браузер розуміє без проблем.`,
          },
          {
            code: true,
            label: 'Put in next-gen JavaScript',
            description: `[1,2,3].map(n => n ** 2)`,
          },
          {
            code: true,
            label: 'Get Browser-compatible JavaScript out',
            description: `[1,2,3].map(function (n) {
  return Math.pow(n, 2);
}`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Різниця між feature detection, feature inference та аналізом рядка user-agent?',
        descriptions: [
          {
            code: false,
            label: 'Feature detection',
            description: `Feature detection - це визначення можливостей браузера чи пристрою, які можуть бути використані у веб-додатках за допомогою коду. Наприклад, перевірка на підтримку HTML5 або CSS3.`,
          },
          {
            code: false,
            label: 'Feature inference',
            description: `Feature inference - це визначення можливостей браузера чи пристрою, які не можуть бути прямо перевірені за допомогою коду. Наприклад, визначення підтримки WebGL на основі підтримки OpenGL.`,
          },
          {
            code: false,
            label: 'User-agent ',
            description: `User-agent string analysis - це аналіз інформації про браузер та операційну систему, яка передається в HTTP-запиті від браузера до веб-сайту. Це може допомогти веб-сайту визначити, як він повинен поводитися для даного користувача. Наприклад, відображення вмісту у форматі мобільного пристрою для мобільного браузера.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Що таке Веб-компоненти та які технології в них використовуються?',
        descriptions: [
          {
            code: false,
            label: 'Feature detection',
            description: `Веб-компоненти (Web Components) - це стандартизований набір технологій веб-розробки, що дозволяють створювати перевикористовувані елементи інтерфейсу користувача (UI) зі своїм функціоналом, які можуть використовуватись в різних веб-додатках без необхідності копіювання та вставки коду.
            Веб-компоненти складаються з трьох технологій:
            Custom Elements - дозволяє розробникам створювати свої власні HTML-елементи зі своїми властивостями та методами. За допомогою цієї технології можна створити зручні, перевикористовувані компоненти зі своїм функціоналом.

Shadow DOM - дозволяє розробникам ізолювати стилі та логіку свого компонента від зовнішнього середовища. За допомогою Shadow DOM можна побудувати структуру компонента, яка буде недоступна для змін з зовнішнього коду, тим самим підвищивши безпеку та знизивши імовірність конфліктів між стилями та скриптами.

HTML Templates - дозволяє створювати шаблони HTML-коду, які можуть бути використані для створення нових елементів. Ця технологія дозволяє розробникам використовувати та маніпулювати зі складовими частинами елемента, що збільшує його перевикористовуваність.

Всі ці технології включаються в HTML-сторінку та забезпечують можливість створення веб-компонентів з уніфікованою структурою та поведінкою, що значно полегшує розробку та підтримку веб-додатків.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Способи зменшення часу завантаження веб-сторінки?',
        descriptions: [
          {
            code: false,
            label: 'Способи зменшення часу завантаження веб-сторінки',
            description: `Компресія зображень: Зображення часто становлять більше половини завантаженого контенту на сторінці. Використовуючи інструменти для компресії зображень, наприклад, Adobe Photoshop, ImageOptim або TinyPNG, можна зменшити розмір файлу зображення без втрати якості.
Мінімізація коду: Використання засобів, таких як CSS минифікатори та JS компресори, дозволяє зменшити розмір коду сторінки, що зменшує час завантаження.
Кешування: Використання кешування для зберігання тимчасової копії веб-сторінки на стороні клієнта може зменшити кількість запитів на сервер та зменшити час завантаження сторінки для повторних відвідувань.
Комбінування та мінімізація запитів: За допомогою об'єднання декількох файлів CSS та JavaScript в один файл та їх минифікації можна зменшити кількість запитів на сервер та зменшити час завантаження.
Використання CDN: Використання CDN (Content Delivery Network) дозволяє розподілити завантаження ресурсів на кілька серверів, що знаходяться ближче до користувача, що допомагає зменшити час завантаження сторінки.
Видалення зайвого контенту: Видалення зайвого контенту, такого як сторонні скрипти та не використовуваний код, може допомогти зменшити розмір сторінки`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Особливості розробки мультимовних сайтів?',
        descriptions: [
          {
            code: false,
            label: 'Мультимовний сайт',
            description: `Мультимовний сайт – це вебресурс, адаптований для користувачів, що володіють різними мовами.
            Як реалізувати мультимовність на сайті?
            Різні домени
            Найочевидніший спосіб зробити мультимовність сайту – використовувати різні доменні імена. Наприклад, для України – .ua, для Польщі – .pl, для Чехії – .cz. І так далі.
            За допомогою категорій та папок
            В даному випадку на сайт встановлюється модуль мультимовності, створюються категорії та папки, куди копіюється контент. Подібним чином структура сайту реалізується в рамках одного піддомену, а отже, і вага теж зберігається.
            Параметри
Такий метод вважається спірним, і навіть Google його не рекомендує. Принцип у тому, що дані про мовну та регіональну приналежність вебресурсу передаються через параметр URL. Реалізація мультимовності здійснюється в рамках єдиного домену, але просувати сторінки з параметрами насправді безглуздо.
            `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Flash Of Unstyled Content (FOUC)? Як його уникнути?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Flash Of Unstyled Content (FOUC)?',
            description: `Flash Of Unstyled Content (FOUC) - це проблема, коли сторінка завантажується без зовнішніх CSS стилів або з частково завантаженими стилями, що призводить до тимчасового зображення сторінки без стилів, а потім до зображення з правильним виглядом. Це може зіпсувати візуальний досвід користувачів та порушити дизайн сторінки.`,
          },
          {
            code: false,
            label: 'Як його уникнути?',
            description: `Щоб уникнути FOUC, можна використовувати такі підходи, як inline CSS, deferred loading of CSS, або використання preloading CSS. Inline CSS дозволяє браузеру відображати сторінку зі стилями, навіть якщо зовнішні стилі ще не завантажилися. Deferred loading дозволяє браузеру завантажувати стилі пізніше, коли основний зміст сторінки вже завантажено. Preloading CSS дозволяє браузеру завантажувати стилі раніше, ніж вони потрібні для відображення сторінки.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між layout, painting та compositing?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між layout, painting та compositing?',
            description: `
Layout, painting та compositing - це три різні етапи процесу відображення веб-сторінки в браузері. Кожен з цих етапів відповідає за певні аспекти відображення сторінки, і вони відбуваються послідовно один за одним. Ось короткий опис кожного з цих етапів:`,
          },
          {
            code: false,
            label: 'Layout (розміщення)',
            description: `Layout (розміщення): це перший етап відображення сторінки, коли браузер обчислює розміри та позиції кожного елемента на сторінці, враховуючи стиль та структуру HTML. Наприклад, браузер визначає, де повинен бути розміщений блок тексту та якого розміру повинен бути зображення.`,
          },
          {
            code: false,
            label: 'Painting (фарбування)',
            description: `Painting (фарбування): це другий етап відображення, коли браузер використовує розраховану розмітку та стилі для заповнення кольорами та тексту елементів сторінки. Цей етап включає фарбування фонів, текстів, зображень та інших елементів сторінки.`,
          },
          {
            code: false,
            label: 'Compositing (композиція)',
            description: `Compositing (композиція): це останній етап відображення, коли браузер об'єднує зображення та елементи сторінки в один зображення, яке потім відображається на екрані. Цей етап включає об'єднання шарів зображень, що містяться в окремих блоках`,
          },
          {
            code: false,
            label: 'Узагальнення',
            description: `Загалом, layout відповідає за розміщення елементів на сторінці, painting - за їхнє фарбування, а compositing - за об'єднання різних елементів та зображень в одне зображення. Кожен з цих етапів має важливу роль у відображенні веб-сторінок, і збій в будь-якому з них може призвести до проблем з відображенням сторінки в браузері`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Progressive Web Application?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Progressive Web Application?',
            description: `Progressive Web Application (PWA) – це додаток, створений за допомогою веб-технологій і є гібридом звичайного веб-сайту, доступ до якого здійснюється через браузер (в тому числі і браузер мобільного додатка). Такі гібридні веб-додатки імітують досвід використання нативних додатків і мають максимально наближений до них зовнішній вигляд і юзабіліті.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке міжсайтовий скриптинг (XSS)?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Міжсайтовий скриптинг (Cross-Site Scripting або XSS) - це тип атаки на веб-додатки, який полягає в виконанні зловмисного скрипту в браузері користувача з метою отримання доступу до конфіденційної інформації або контролю над обліковим записом користувача. 

Атака XSS може бути виконана шляхом вставки зловмисного коду у веб-сторінку, яка відображається в браузері користувача. Наприклад, зловмисник може вставити скрипт у поле вводу на веб-сайті, який потім буде відображений іншим користувачам, які зайшли на цей сайт. Якщо користувачі введуть дані в це поле, то зловмисний скрипт може виконатися у їхньому браузері, що може призвести до витоку конфіденційної інформації або виконання дій від імені користувача без його дозволу. 

Для уникнення атак XSS веб-розробники можуть використовувати заходи безпеки, такі як валідація та екранування введених користувачем даних, використання безпечних HTTP кукі, використання Content Security Policy (CSP) та інших технологій. Крім того, користувачі повинні бути обережні при введенні своїх даних на невідомих веб-сайтах та уникати виконання незнайомих скриптів у своєму браузері.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке API?',
        descriptions: [
          {
            code: false,
            label: 'Що таке API?',
            description: `API — це посередник між програмами, який задає правила «спілкування». API (Application Programming Interface) — це набір готових класів, процедур, функцій, структур і констант, що надаються додатком (бібліотекою, сервісом) для використання в зовнішніх програмних продуктах (Вікіпедія). Своїми словами, API надає нам можливість використовувати чужі напрацювання в своїх цілях.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CDN?',
        descriptions: [
          {
            code: false,
            label: ' CDN - це ...',
            description: `Мережа доставки вмісту (Content Delivery Network, або CDN) — це сукупність серверів, які доставляють вміст користувачеві.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке REST?',
        descriptions: [
          {
            code: false,
            label: 'Що таке REST?',
            description: `REST (скор. англ. Representational State Transfer, «передача репрезентативного стану») — підхід до архітектури мережевих протоколів, які надають доступ до інформаційних ресурсів. Був описаний і популяризований 2000 року Роєм Філдінгом, одним із творців протоколу HTTP.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке ip-адреса?',
        descriptions: [
          {
            code: false,
            label: 'Що таке ip-адреса?',
            description: `IP-адреса, адреса Ай-Пі — це ідентифікатор мережевого рівня, який використовується для адресації комп'ютерів чи пристроїв у мережах, які побудовані з використанням стеку протоколів TCP/IP. `,
          },
          {
            code: false,
            label: 'Як виглядає IP-адреса?',
            description: `У версії протоколу IPv4 IP-адреса має довжину 4 байти. В 4-й версії IP-адреса являє собою 32-бітове число. Зручною формою запису IP-адреси (IPv4) є запис у вигляді чотирьох десяткових чисел значенням від 0 до 255, розділених крапками, наприклад: 192.168.0.1. `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між host і domain?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між host і domain?',
            description: `Хостинг — це місце, де зберігається сайт , Його файли і база даних. Домен — це ім'я сайту в інтернеті. Для повноцінної роботи сайту потрібен і хостинг, і домен.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке URL?',
        descriptions: [
          {
            code: false,
            label: 'Що таке URL?',
            description: `URL означає Уніфікований покажчик інформаційного ресурсу. Це рядок символів, що визначає адресу. Це найпоширеніший спосіб ідентифікації місця розташування ресурсу в World Wide Web (WWW).`,
          },
          {
            code: false,
            label: 'Що таке URI',
            description: `Визначає URI Уніфікований ідентифікатор ресурсу. Це рядок символів, що використовується для ідентифікації ресурсу в Інтернеті або за місцем розташування, або за ім'ям, або за обома.`,
          },
          {
            code: false,
            label: 'Основна відмінність',
            description: `Основна відмінність між URL і URI є те, що URL-адреса дозволяє ідентифікувати веб-ресурс тільки за його розташуванням, а URI дозволяє ідентифікувати веб-ресурс, використовуючи ім'я або місце розташування, або обидва.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Чому очищувати кеш важливо? Як це можна зробити?',
        descriptions: [
          {
            code: false,
            label: 'Чому очищувати кеш важливо?',
            description: `Кеш - це тимчасове сховище, де зберігаються дані, які використовуються повторно для швидшого доступу до них. Кеш може містити збережені сторінки веб-сайту, зображення, стилі, скрипти та інші ресурси.`,
          },
          {
            code: false,
            label: 'Як це можна зробити?',
            description: `Використання клавіш Ctrl + Shift + Delete, щоб відкрити вікно очищення кешу у браузері.
У веб-браузері можна вибрати опцію «Очистити кеш» або «Очистити історію» в меню налаштувань.
У деяких браузерах можна використовувати розширення для очищення кешу та інших тимчасових файлів.
У некоторых ОС можна вибрати опцію "Очистити кеш" в меню налаштувань.
Застосування програм для очищення кешу, таких як CCleaner.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Назвіть критичні етапи рендерингу?',
        descriptions: [
          {
            code: false,
            label: 'Назвіть критичні етапи рендерингу?',
            description: `Критичний рендеринговий шлях (Critical Rendering Path) - це процес відправки запиту до сервера за HTML, обчислення CSS стилів, обчислення та відображення DOM, обчислення та відображення CSSOM і злиття їх в один документ.
Layout - це процес обчислення положення та розмірів елементів на сторінці.
Painting - це процес перетворення обчисленого вигляду елементів на сторінці в пікселі.
Compositing - це процес складання відображення сторінки з оброблених шарів пікселів.
Усі ці етапи взаємодіють між собою, і якщо хоча б один з них займає дуже багато часу, це може призвести до затримок у відображенні сторінки, зниження продуктивності та погіршення користувацького досвіду. Тому оптимізація критичного рендерингового шляху та всіх цих етапів є важливою задачею для покращення продуктивності веб-сторінок.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Core Web Vitals? Які основні метрики входять туди?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Core Web Vitals? Які основні метрики входять туди?',
            description: `Core Web Vitals - це група основних метрик продуктивності веб-сторінок, які були визначені Google з метою покращення користувацького досвіду в Інтернеті. Ці метрики визначаються на основі того, як швидко сторінка завантажується, реагує на дії користувача та як зручно користуватися нею.

Основні метрики Core Web Vitals включають:

1. Largest Contentful Paint (LCP) - ця метрика вимірює час, який потрібно браузеру для відображення найбільшого контентного елементу на сторінці. Ідеальний час LCP - менше 2,5 секунд.

2. First Input Delay (FID) - ця метрика вимірює затримку між першим взаємодією користувача зі сторінкою (наприклад, кліком на кнопку) та відповіддю сторінки. Ідеальний час FID - менше 100 мс.

3. Cumulative Layout Shift (CLS) - ця метрика вимірює, наскільки динамічно змінюється макет сторінки під час її завантаження. Ідеальний показник CLS - менше 0,1.

Ці метрики вважаються основними, оскільки вони дозволяють оцінити швидкість завантаження сторінки, забезпечити реагування на дії користувача та уникнути змін макету сторінки під час завантаження. Оцінка Core Web Vitals є важливою для SEO, тому що Google використовує їх для розміщення веб-сторінок у пошукових результатах.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про метрики Core Web Vitals?',
        descriptions: [
          {
            code: false,
            label: 'Розкажіть про метрики Core Web Vitals?',
            description: `Core Web Vitals - це набір метрик, які вимірюють кількісні показники взаємодії користувача з веб-сторінками, зокрема швидкість, стабільність та якість візуального відображення. Ці метрики були розроблені Google з метою покращення користувацького досвіду та сприяння оптимізації веб-сторінок.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між preload, prefetch, preconnect та prerender?',
        descriptions: [
          {
            code: false,
            label: 'preload',
            description: `Цей метод використовується для попереднього завантаження важливих ресурсів сторінки, таких як шрифти, стилі, скрипти, зображення тощо. Використання цього методу дозволяє покращити швидкість завантаження сторінки, тому що браузер починає завантаження ресурсів ще до того, як вони будуть потрібні для відображення.`,
          },
          {
            code: false,
            label: 'prefetch',
            description: `Цей метод використовується для попереднього завантаження ресурсів, які будуть потрібні в майбутньому. Наприклад, якщо на сторінці є посилання на іншу сторінку, то можна використовувати prefetch, щоб попередньо завантажити цю сторінку та покращити її швидкість завантаження.`,
          },
          {
            code: false,
            label: 'preconnect',
            description: `Цей метод використовується для попередньої настройки з'єднання з сервером, який має надавати ресурси, щоб зменшити затримки. Наприклад, якщо на сторінці використовується сторонній шрифт або скрипт, можна використовувати preconnect, щоб підготувати з'єднання з сервером, який надаватиме ці ресурси, ще до того, як вони будуть потрібні.`,
          },
          {
            code: false,
            label: 'prerender',
            description: `Цей метод використовується для попереднього рендерингу сторінки, що дозволяє покращити її швидкість завантаження.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Навіщо потрібен патерн PRPL?',
        descriptions: [
          {
            code: false,
            label: 'Навіщо потрібен патерн PRPL?',
            description: `PRPL (Push, Render, Pre-cache, Lazy-load) - це паттерн проектування, який допомагає забезпечити швидке завантаження веб-сторінок на мобільних пристроях. Він може бути особливо корисним для веб-додатків з великою кількістю коду та ресурсів, які потрібно завантажувати.

Основна ідея PRPL полягає в тому, щоб завантажувати сторінки якомога швидше та ефективніше. Завдяки PRPL можна використовувати попереднє завантаження, передварительне кешування та ліниве завантаження, щоб зменшити час завантаження сторінки та зменшити кількість запитів до сервера.

Патерн PRPL може бути особливо корисним для веб-додатків на мобільних пристроях, оскільки швидкість та ефективність завантаження сторінок на цих пристроях може бути обмеженою. Принцип PRPL допомагає забезпечити оптимальне використання ресурсів та мінімізувати час завантаження сторінок, що поліпшує користувацький досвід та забезпечує більш високу конверсію.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Web API',
    questions: [
      {
        id: generateUUID(),
        question: 'Що таке HTTP?',
        descriptions: [
          {
            code: false,
            label: 'Що таке HTTP?',
            description: `HTTP означає "Протокол передачі гіпертексту" (англ. "Hypertext Transfer Protocol"). Це стандартний протокол, який використовується для передачі даних в Інтернеті. В основному він використовується для передачі веб-сторінок з веб-сервера на веб-браузер. HTTP використовується для запитів на отримання ресурсів (таких як HTML-сторінки, зображення, відео) з сервера та для передачі даних від користувача до сервера (наприклад, при заповненні форми на веб-сторінці).`,
          },
          {
            code: false,
            label: '',
            description: `HTTP є протоколом передачі даних в Інтернеті, що базується на клієнт-серверній архітектурі. Клієнт (наприклад, веб-браузер) надсилає запит на сервер, який потім відповідає на запит, передаючи необхідну інформацію клієнту.
              HTTP використовується для передачі різних типів даних, таких як HTML-сторінки, зображення, відео, аудіо, CSS-стилі, JavaScript-скрипти, тощо. Для передачі даних використовуються різні методи, зокрема GET, POST, PUT, DELETE, PATCH, які визначають тип запиту та дії, які необхідно виконати на сервері.
              HTTP має певну структуру запиту та відповіді, яка включає заголовки (headers) та тіло (body) повідомлення. У заголовках вказуються метадані про запит або відповідь, такі як тип даних, розмір, кодування тощо. Тіло повідомлення містить основну інформацію, яка передається в запиті або відповіді.
              У заголовках запиту також можуть бути вказані різні параметри, наприклад, заголовок "User-Agent" містить інформацію про веб-браузер або інший клієнтський програмний продукт, який здійснює запит. Це дозволяє серверу адаптувати відповідь до конкретного клієнта.
              Заголовки також можуть включати інформацію про авторизацію, кешування, кодування, мову тощо. Для забезпечення безпеки передачі даних можуть використовуватися різні методи шифрування, такі як TLS/SSL.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'З чого будується HTTP-запит?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `HTTP-запит будується з трьох основних частин: рядка запиту (request line), заголовків запиту (request headers) та тіла запиту (request body).`,
          },
          {
            code: false,
            label: '',
            description: `1. Рядок запиту містить метод запиту, шлях до ресурсу та версію протоколу, наприклад:`,
          },
          {
            code: true,
            label: '',
            description: `GET /index.html HTTP/1.1`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод запиту - GET, шлях до ресурсу - /index.html, а версія протоколу - HTTP/1.1.`,
          },
          {
            code: false,
            label: '',
            description: `2. Заголовки запиту містять додаткову інформацію про запит, таку як тип даних, кодування, мову, кешування, авторизацію тощо. Заголовки вказуються після рядка запиту та розділяються переносом рядка. Приклад заголовків запиту:`,
          },
          {
            code: true,
            label: '',
            description: `
            Host: www.example.com
            User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36
            Accept-Language: en-US,en;q=0.9
            `,
          },
          {
            code: false,
            label: '',
            description: `3. Тіло запиту містить додаткові дані, які надсилаються разом з запитом. Наприклад, у випадку відправлення форми на веб-сторінці, тіло запиту міститиме дані, які були введені користувачем. У деяких випадках запит може не містити тіла, тоді ця частина буде відсутня. Якщо тіло запиту присутнє, то воно повинно розділюватись від заголовків порожнім рядком.`,
          },
          {
            code: true,
            label: '',
            description: `
              POST /submit-form.php HTTP/1.1
              Host: www.example.com
              Content-Type: application/x-www-form-urlencoded
              Content-Length: 23
              
              username=johndoe&password=12345
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод запиту - POST, шлях до ресурсу - /submit-form.php, версія протоколу - HTTP/1.1. Заголовки запиту вказують тип даних (application/x-www-form-urlencoded) та розмір тіла запиту (23 байти). Тіло запиту містить дані, введені користувачем на формі (username=johndoe&password=12345).`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які методи може мати HTTP-запит?',
        descriptions: [
          {
            code: false,
            label: 'Які методи може мати HTTP-запит?',
            description: `HTTP-протокол має кілька методів запиту, які використовуються для взаємодії з сервером. Основні методи HTTP-запитів:`,
          },
          {
            code: false,
            label: '1. GET - запит на отримання ресурсу за вказаною адресою.',
            description: `Метод GET використовується для запиту ресурсу з сервера. Він не змінює стану сервера і повертає лише дані, які були запитані. Оскільки метод GET не змінює стану сервера, він може бути безпечно кешований.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використовувати метод GET, передавши його як параметр у другому об'єкті параметрів запиту. Як правило, метод GET не має тіла запиту, оскільки дані не надсилаються на сервер. Ось приклад використання методу GET:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource?id=12345', {
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json'
                }
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));            
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод GET для запиту ресурсу з сервера з ідентифікатором "12345". За допомогою параметрів запиту, ми передаємо ідентифікатор у URL-адресі. Заголовок "Content-Type" встановлений на "application/json", але це не є обов'язковим для методу GET, оскільки ми не надсилаємо дані на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `Після виконання запиту сервер повинен повернути відповідь з даними запитаного ресурсу. Інформацію про ресурс можна отримати з об'єкту Response, який повертається з fetch().`,
          },
          {
            code: false,
            label: '2. POST - відправлення даних на сервер для обробки.',
            description: `Метод POST використовується для створення нового ресурсу на сервері або відправки даних на сервер для обробки. У відміну від методу PUT, який оновлює існуючий ресурс, метод POST завжди створює новий ресурс на сервері.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використовувати метод POST, передавши його як параметр у другому об'єкті параметрів запиту. Дані, які необхідно відправити на сервер, повинні бути передані у тілі запиту. Ось приклад використання методу POST:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  name: 'New Resource Name',
                  description: 'New Resource Description'
                })
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод POST для створення нового ресурсу на сервері. Також ми встановлюємо заголовок "Content-Type" на "application/json", щоб вказати, що дані, які ми надсилаємо, є об'єктом JSON. Тіло запиту містить об'єкт з даними нового ресурсу.`,
          },
          {
            code: false,
            label: '',
            description: `Після того, як сервер успішно створить новий ресурс, він повинен повернути відповідь з інформацією про створений ресурс, наприклад, з його ідентифікатором або посиланням на ресурс. Відповідь може бути отримана з об'єкту Response, який повертається з fetch().`,
          },
          {
            code: false,
            label: '3. PUT - оновлення ресурсу на сервері за вказаною адресою.',
            description: `Метод PUT використовується для заміни або оновлення ресурсу на сервері. Він відрізняється від методу POST тим, що він не тільки додає новий ресурс, але також оновлює існуючий ресурс на сервері. Цей метод може бути корисним, коли потрібно змінити деякі дані, які вже є на сервері, але які було надіслано раніше.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використати метод PUT, передавши його як параметр у другому об'єкті параметрів запиту. Також потрібно передати дані, які потрібно замінити на сервері, у тілі запиту. Ось приклад використання методу PUT:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource/1', {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  name: 'New Resource Name',
                  description: 'New Resource Description'
                })
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод PUT для заміни даних ресурсу з ідентифікатором "1". Також ми встановлюємо заголовок "Content-Type" на "application/json", щоб вказати, що дані, які ми надсилаємо, є об'єктом JSON. Тіло запиту містить об'єкт з оновленими даними для ресурсу.`,
          },
          {
            code: false,
            label: '',
            description: `Як і в інших методах, сервер повинен повернути відповідь на запит методу PUT, щоб підтвердити, що дані були збережені на сервері.`,
          },
          {
            code: false,
            label:
              '4. DELETE - видалення ресурсу на сервері за вказаною адресою.',
            description: `Mетод DELETE використовується для видалення ресурсу на сервері. Використовуйте метод fetch() з параметром method: 'DELETE', щоб виконати DELETE-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts/1', {
                method: 'DELETE',
              })
              .then(response => {
                console.log('Resource deleted successfully');
              })
              .catch(error => console.error(error));                    
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод DELETE для видалення ресурсу на сервері, за адресою https://example.com/posts/1. У відповідь на запит сервер може повернути статусний код 204 No Content, що означає успішне видалення ресурсу. В нашому випадку ми виводимо повідомлення про успішне видалення ресурсу в консоль. Якщо виникне помилка, ми виводимо повідомлення про помилку в консоль, використовуючи метод console.error().`,
          },
          {
            code: false,
            label:
              '5. HEAD - запит на отримання заголовків відповіді, але без тіла відповіді.',
            description: `Метод HEAD використовується для отримання заголовків відповіді на запит без тіла відповіді. Він корисний, коли ви хочете отримати лише інформацію про ресурс, таку як тип MIME, без отримання всього вмісту ресурсу. Використовуйте метод fetch() з параметром method: 'HEAD', щоб виконати HEAD-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts/1', {
                method: 'HEAD',
              })
              .then(response => {
                console.log(response.headers.get('Content-Type'));
              })
              .catch(error => console.error(error));
                               
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми відправляємо HEAD-запит на URL https://example.com/posts/1. У відповідь на запит сервер поверне лише заголовки відповіді, але не тіло відповіді. Ми використовуємо метод headers.get('Content-Type') для отримання типу MIME відповіді і виводимо його у консолі. У випадку помилки ми виводимо повідомлення про помилку в консолі, використовуючи метод console.error().`,
          },
          {
            code: false,
            label:
              '6. OPTIONS - запит на отримання інформації про можливості сервера для обробки запитів.',
            description: `Метод OPTIONS використовується для отримання інформації про можливі методи HTTP, які підтримуються для конкретного ресурсу на сервері. Використовуйте метод fetch() з параметром method: 'OPTIONS', щоб виконати OPTIONS-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts', {
                method: 'OPTIONS',
              })
              .then(response => {
                console.log(response.headers.get('Allow'));
              })
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми відправляємо OPTIONS-запит на URL https://example.com/posts. У відповідь на запит сервер поверне заголовок Allow, який містить перелік методів HTTP, що підтримуються для даного ресурсу на сервері. Ми використовуємо метод headers.get('Allow') для отримання переліку методів і виводимо їх у консолі. У випадку помилки ми виводимо повідомлення про помилку в консолі, використовуючи метод console.error().`,
          },
          {
            code: false,
            label: `7. CONNECT - встановлення мережевого з'єднання з сервером.`,
            description: `Метод CONNECT використовується для встановлення мережевого з'єднання між клієнтом і сервером за допомогою протоколу TLS/SSL. Використовується в основному для забезпечення безпеки і шифрування даних, переданих між клієнтом і сервером. Зазвичай він використовується для з'єднання з проксі-серверами.`,
          },
          {
            code: false,
            label: '',
            description: `Оскільки цей метод використовується переважно для внутрішньої мережевої комунікації, він рідко використовується у клієнтських додатках. Використання методу CONNECT зазвичай приховане від користувача, а з'єднання установлюється автоматично через проксі-сервери.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, в більшості випадків ви не повинні використовувати метод CONNECT у своїх програмах, якщо ви не створюєте програми, пов'язані з безпекою мережі.
              Якщо ви все ж хочете спробувати виконати запит з методом CONNECT у fetch(), ви можете використати код, подібний до наступного:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com', {
                method: 'CONNECT',
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));            
            `,
          },
          {
            code: false,
            label: '',
            description: `Однак, ймовірно, у вас виникнуть проблеми з автентифікацією на сервері, тому я раджу використовувати цей метод тільки в тому випадку, якщо ви знаєте, що він дійсно необхідний у вашому конкретному випадку.`,
          },
          {
            code: false,
            label:
              '8. TRACE - запит на отримання поверхневої інформації про те, як сервер обробляє запит.',
            description: `Метод TRACE використовується для діагностики мережевих проблем. Він дозволяє клієнту отримати зворотню інформацію від сервера про кожен крок, що відбувається з запитом, відправленим до сервера.`,
          },
          {
            code: false,
            label: '',
            description: `Під час використання методу TRACE, клієнтський запит повторюється на сервері, а сервер відповідає з повідомленням, яке містить всю інформацію про запит. Це може бути корисним для діагностики проблем з мережевим з'єднанням, розуміння того, як сервер обробляє запити та відповідає на них, а також для перевірки того, чи змінювалися дані запиту під час пересилання по мережі.`,
          },
          {
            code: false,
            label: '',
            description: `Якщо ви хочете використати метод TRACE у fetch(), ви можете використати наступний код:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com', {
                method: 'TRACE',
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `Але, як і в разі методу CONNECT, я раджу використовувати цей метод тільки в діагностичних цілях та якщо ви знаєте, що він дійсно необхідний у вашому конкретному випадку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке HTTP cookie? Для чого їх використовують?',
        descriptions: [
          {
            code: false,
            label: 'Що таке HTTP cookie?',
            description: `HTTP cookie - це невеликий фрагмент даних, який веб-сайт зберігає на комп'ютері користувача. Вони зазвичай використовуються для зберігання інформації про користувача та його перевірці при наступних відвідуваннях веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Коли користувач відвідує веб-сайт, сервер може відправити HTTP-відповідь з заголовком Set-Cookie. Цей заголовок містить інформацію про кукі, який повинен зберігатися на комп'ютері користувача. Коли користувач повертається на веб-сайт, його браузер надсилає HTTP-запит зі всіма кукі, які зберігаються на його комп'ютері. Сервер може використовувати ці кукі для ідентифікації користувача та надання персоналізованого досвіду використання.`,
          },
          {
            code: false,
            label: 'Для чого їх використовують?',
            description: `Кукі використовуються для різних цілей, таких як зберігання налаштувань користувача, ідентифікації користувача, зберігання товарів у кошику покупок та відстеження діяльності користувача на веб-сайті. Наприклад, коли користувач здійснює покупку в інтернет-магазині, його кукі можуть зберігати інформацію про товари в кошику покупок, щоб зберегти вибір користувача після перезавантаження сторінки. Кукі також можуть використовуватися для зберігання інформації про вхід в систему користувача, щоб він не потребував вводити дані вхідної форми при кожному відвідуванні веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Хоча кукі зазвичай не є шкідливими, вони можуть становити ризик для приватності користувача, оскільки вони можуть містити особисту інформацію про користувача.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке WebSocket? У чому принцип його роботи?',
        descriptions: [
          {
            code: false,
            label: 'Що таке WebSocket?',
            description: `WebSocket - це технологія, що дозволяє встановлювати двостороннє з'єднання між клієнтом та сервером через один TCP-з'єднання. WebSocket було розроблено з метою зменшення затримок при обміні даними між клієнтом та сервером та для зменшення навантаження на сервер.`,
          },
          {
            code: false,
            label: 'У чому принцип його роботи?',
            description: `Принцип роботи WebSocket полягає в тому, що спочатку клієнт та сервер встановлюють зв'язок через стандартний HTTP-запит. Після цього сервер відповідає з заголовком "Upgrade: WebSocket", який означає, що зв'язок був успішно оновлений до WebSocket.`,
          },
          {
            code: false,
            label: '',
            description: `Після встановлення з'єднання WebSocket клієнт та сервер можуть відправляти додаткові повідомлення один одному без необхідності повторного встановлення з'єднання. Кожне повідомлення має заголовок, що дозволяє ідентифікувати його тип.`,
          },
          {
            code: false,
            label: '',
            description: `WebSocket може бути використаний для багатьох різних завдань, наприклад, для розробки онлайн-ігор, чатів, відео-стрімінгу тощо. В порівнянні з іншими технологіями, WebSocket забезпечує більш ефективний обмін даними між клієнтом та сервером, зменшує навантаження на сервер та забезпечує більш швидку реакцію на події.`,
          },
          {
            code: false,
            label: 'Як встановлюється звязок через HTTP-запит?',
            description: `Зв'язок між клієнтом та сервером зазвичай встановлюється за допомогою стандартного HTTP-запиту типу GET або POST. Клієнт ініціює зв'язок, надсилаючи запит на сервер за певним URL-адресом. Запит містить заголовки, які містять інформацію про запит та можуть включати додаткові параметри.`,
          },
          {
            code: false,
            label: '',
            description: `Сервер, отримавши запит, оброблює його та надсилає відповідь клієнту. Відповідь також містить заголовки, які містять інформацію про відповідь та можуть включати додаткові параметри, такі як кешування або інформація про тип даних, що повертаються.`,
          },
          {
            code: false,
            label: '',
            description: `Якщо під час обробки запиту клієнт та сервер погоджуються використовувати протокол WebSocket, то після відправлення сервером заголовку "Upgrade: WebSocket" з'єднання між клієнтом та сервером переходить у режим WebSocket. З цього моменту клієнт та сервер можуть відправляти повідомлення один одному без необхідності повторного встановлення з'єднання через HTTP-запит.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між HTTP та HTTPS?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між HTTP та HTTPS?',
            description: `Основна різниця між HTTP та HTTPS полягає в тому, що HTTP є протоколом передачі даних через Інтернет у відкритому вигляді, тоді як HTTPS - це захищений протокол передачі даних, який використовує шифрування для забезпечення безпеки даних.`,
          },
          {
            code: false,
            label: '',
            description: `HTTP передає дані відкрито, тому будь-яка інформація, надіслана через HTTP-запит, може бути перехоплена та переглянута ким завгодно. З цієї причини передача конфіденційних даних, таких як логіни та паролі, через HTTP є небезпечною.`,
          },
          {
            code: false,
            label: '',
            description: `HTTPS використовує протокол TLS (Transport Layer Security) або SSL (Secure Sockets Layer), щоб зашифрувати дані, надіслані через Інтернет, що забезпечує більш високий рівень безпеки. Коли веб-браузер отримує відповідь від сервера по HTTPS, то спочатку відбувається процес обміну сертифікатами для підтвердження автентичності сервера, після чого весь трафік між браузером та сервером шифрується.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Long-Polling, Websockets та Server-Sent Events',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Long-Polling, Websockets та Server-Sent Events (SSE) є різними підходами до реалізації двостороннього зв'язку між клієнтом та сервером у веб-додатках.`,
          },
          {
            code: false,
            label: 'Long-Polling',
            description: `Long-Polling використовує запити HTTP, але затримує відповідь сервера на певний час. Коли сервер готовий надіслати відповідь, він повертає її клієнту, після чого клієнт відправляє новий запит. Цей процес повторюється багато разів, щоб створити враження миттєвої взаємодії між клієнтом та сервером.`,
          },
          {
            code: false,
            label: 'Websockets',
            description: `Websockets, з іншого боку, створюють постійне двостороннє з'єднання між клієнтом та сервером через протокол WebSocket. Це дозволяє серверу відправляти повідомлення клієнту, коли вони готові, без очікування запитів від клієнта. Це забезпечує швидку і миттєву взаємодію між клієнтом та сервером, а також значно зменшує кількість запитів, необхідних для обміну даними.`,
          },
          {
            code: false,
            label: 'Server-Sent Events (SSE)',
            description: `Server-Sent Events (SSE) також дозволяють серверу відправляти повідомлення клієнту, але вони використовуються лише для відправки даних від сервера до клієнта. Клієнт може підписатися на потік повідомлень від сервера і приймати їх безпосередньо у своєму браузері. SSE часто використовуються для відображення живих оновлень даних, таких як новини, ігрові події, цінові зміни тощо.`,
          },
          {
            code: false,
            label: '',
            description: `Узагальнюючи, Long-Polling є більш простим, але менш ефективним підходом до забезпечення двостороннього зв'язку між клієнтом та сервером, тоді як Websockets та SSE надають більш ефективні та потужні засоби для цього`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між PUT- і POST-запитами?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між PUT- і POST-запитами?',
            description: `PUT і POST є двома типами HTTP-запитів, які використовуються для відправки даних на сервер. Основною різницею між ними є те, як вони взаємодіють з ресурсами на сервері.`,
          },
          {
            code: false,
            label: '',
            description: `PUT-запит використовується для зміни існуючих даних на сервері. Цей запит вимагає, щоб вказаний ресурс на сервері був замінений вказаними даними. Якщо ресурс відсутній, то він буде створений.`,
          },
          {
            code: false,
            label: '',
            description: `POST-запит, з іншого боку, використовується для відправки нових даних на сервер. Він використовується, коли потрібно створити новий ресурс на сервері або відправити дані на сервер для подальшої обробки. Крім того, POST-запит може використовуватись для оновлення даних на сервері, якщо це потрібно.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, основна різниця між PUT- і POST-запитами полягає в тому, що PUT-запит використовується для зміни існуючих даних, тоді як POST-запит використовується для відправки нових даних на сервер.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке безпечні (Secure) та HttpOnly cookies?',
        descriptions: [
          {
            code: false,
            label: 'Що таке безпечні (Secure) та HttpOnly cookies?',
            description: `Безпечні (Secure) та HttpOnly cookies - це два різні атрибути, які можна встановлювати для HTTP cookies для забезпечення додаткової безпеки.`,
          },
          {
            code: false,
            label: '',
            description: `Атрибут "Secure" вказує на те, що cookie можна використовувати тільки в тому випадку, якщо використовується безпечний протокол зв'язку HTTPS. Якщо веб-сайт використовує HTTPS, то при встановленні cookie встановлюється атрибут "Secure", що дозволяє браузеру передавати cookie тільки через зашифрований канал, а не через незахищені HTTP-запити.`,
          },
          {
            code: false,
            label: '',
            description: `Атрибут "HttpOnly" вказує на те, що cookie не може бути доступний з JavaScript. Це дозволяє захистити cookie від Cross-Site Scripting (XSS) атак, де зловмисник може використовувати JavaScript для отримання доступу до cookie та отримання конфіденційної інформації. Якщо встановлений атрибут "HttpOnly", то веб-програмісти не можуть отримувати доступ до cookie через JavaScript, що дозволяє зменшити ризик XSS-атак.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, використання атрибутів "Secure" та "HttpOnly" є додатковими заходами безпеки для HTTP cookies, які допомагають захистити конфіденційну інформацію користувачів від атак зловмисників.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Content Security Policy (CSP)?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Content Security Policy (CSP)?',
            description: `Content Security Policy (CSP) - це механізм безпеки, що дозволяє зменшити ризик атак на веб-додатки, зокрема на XSS (Cross-Site Scripting) атаки. CSP дає можливість вказати браузеру, які джерела контенту дозволені для завантаження на сторінці, що зменшує можливість виконання зловмисного коду на сторінці в разі, якщо він завантажується з небезпечного джерела.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою CSP можна вказати джерела контенту для різних видів ресурсів, таких як скрипти, стилі, медіа-файли, шрифти, фрейми, AJAX-запити та інші. Також можна налаштувати відправку звіту про спробу завантаження контенту з небезпечних джерел, що дозволяє виявляти та усувати можливі проблеми безпеки.`,
          },
          {
            code: false,
            label: '',
            description: `Приклад вказання CSP на веб-сторінці може виглядати так:`,
          },
          {
            code: true,
            label: '',
            description: `Content-Security-Policy: default-src 'self' https://trusted.com; script-src 'self' 'unsafe-inline' https://trusted.com https://ajax.googleapis.com; style-src 'self' 'unsafe-inline' https://trusted.com; img-src 'self' data: https://trusted.com; font-src 'self' https://fonts.gstatic.com; object-src 'none'; frame-ancestors 'none'; base-uri 'self'; report-uri /csp-report`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми вказуємо, що контент може завантажуватись з поточного джерела ('self'), з довірених джерел (https://trusted.com) для всіх типів контенту, окрім object-src, де ми вказуємо none, щоб заборонити завантаження об'єктів. Крім того, ми вказуємо джерела для кожного типу контенту окремо: для скриптів (script-src) - 'self', 'unsafe-inline', https://trusted.com, https://ajax.googleapis.com; для стилів (style-src) - 'self', 'unsafe-inline', https://trusted.com; для зображень (img-src) - 'self', data:, https://trusted.com. `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'XML',
        descriptions: [
          {
            code: false,
            label: 'XML',
            description: `XML (Extensible Markup Language) - це розширюваний мовний формат, який використовується для зберігання та обміну даними між різними системами. XML є текстовим форматом, що описує дані за допомогою тегів та атрибутів, подібно до HTML. Однак, на відміну від HTML, XML не визначає передбачуваний набір тегів, що дає можливість використовувати його для будь-яких типів даних.`,
          },
          {
            code: false,
            label: '',
            description: `в XML немає заздалегідь визначеного списку тегів, як у HTML. В HTML ви знаєте, що теги, такі як <div>, <p>, <img> і т.д., мають визначене призначення та семантику, і їх застосовують у відповідних випадках. Однак, в XML ви можете створювати власні теги з будь-яким ім'ям і використовувати їх для опису будь-якого типу даних, що дає більшу гнучкість та можливість створення власних мов опису даних. Таким чином, XML набагато більш гнучкий та універсальний, ніж HTML.`,
          },
          {
            code: false,
            label: '',
            description: `XML є стандартом, який можна використовувати у багатьох галузях, включаючи веб-розробку, обробку даних, наукові дослідження, фінанси та багато іншого. XML дозволяє описувати будь-який тип структурованих даних, що робить його потужним інструментом для обміну даними між різними системами та застосунками.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'AJAX',
        descriptions: [
          {
            code: false,
            label: 'AJAX',
            description: `AJAX (Asynchronous JavaScript and XML) - це технологія, яка дозволяє веб-сторінкам взаємодіяти з сервером без перезавантаження сторінки. Завдяки AJAX можна отримувати та відправляти дані на сервер без необхідності в повній перезагрузці сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `AJAX забезпечує асинхронну взаємодію між веб-сторінкою та сервером за допомогою JavaScript-запитів, що виконуються під час роботи сторінки. Це дозволяє завантажувати частини веб-сторінки без повної перезагрузки, що підвищує її продуктивність та зручність використання.`,
          },
          {
            code: false,
            label: '',
            description: `У сучасних веб-додатках AJAX зазвичай використовується для побудови динамічного інтерфейсу, отримання та відображення даних у режимі реального часу, валідації форм, перевірки доступності служб та багатьох інших сценаріїв.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CORS?',
        descriptions: [
          {
            code: false,
            label: 'CORS',
            description: `CORS (Cross-Origin Resource Sharing) - це механізм безпеки браузера, який дозволяє веб-сторінкам запитувати ресурси з інших доменів і серверів. При цьому, браузер перевіряє, чи дозволяє сервер, з якого запитується ресурс, отримувати запити з домену, з якого робиться запит.`,
          },
          {
            code: false,
            label: '',
            description: `Це зроблено для запобігання зловживанням з боку зловмисників, які можуть використовувати код на стороні клієнта для здійснення атак на інші сайти. За допомогою CORS можна дозволити або заборонити запити з конкретних доменів до веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Для налаштування CORS на сервері зазвичай використовують заголовки HTTP, наприклад, Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers тощо.`,
          },
          {
            code: true,
            label:
              'Ось приклад коду, який додає заголовки CORS до відповіді сервера:',
            description: `
              const express = require('express');
              const app = express();
              
              // Додавання заголовків CORS до відповіді сервера
              app.use(function(req, res, next) {
                res.header('Access-Control-Allow-Origin', '*');
                res.header('Access-Control-Allow-Methods', 'GET, PUT, POST, DELETE');
                res.header('Access-Control-Allow-Headers', 'Content-Type');
                next();
              });
              
              // Маршрутизація запитів
              app.get('/', function(req, res) {
                res.send('Привіт з сервера!');
              });
              
              // Запуск сервера
              app.listen(3000, function() {
                console.log('Сервер запущено на порту 3000!');
              });
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому коді ми використовуємо Express.js для створення сервера і додаємо функцію middleware для додавання заголовків CORS до відповіді сервера. Конкретно, ми додаємо заголовок Access-Control-Allow-Origin зі значенням * (дозволяє запити з будь-якого джерела), заголовок Access-Control-Allow-Methods зі значенням дозволених методів (GET, PUT, POST, DELETE) та заголовок Access-Control-Allow-Headers зі значенням дозволених заголовків запиту. Це дозволяє браузеру клієнта виконувати запити до нашого сервера з будь-якого джерела.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між протоколами TCP і UDP?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між протоколами TCP і UDP?',
            description: `TCP (Transmission Control Protocol) і UDP (User Datagram Protocol) - це два основних протоколи мережевого рівня, які використовуються для передачі даних між пристроями в мережі.`,
          },
          {
            code: false,
            label: '',
            description: `Основна різниця між цими протоколами полягає в тому, як вони гарантують доставку даних.`,
          },
          {
            code: false,
            label: '',
            description: `TCP забезпечує забезпечує точну передачу даних, які надходять у вигляді послідовних пакетів. Він використовує механізми підтвердження прийому даних та повторної передачі в разі втрати даних. TCP також контролює потік даних, щоб уникнути перевантаження мережі.`,
          },
          {
            code: false,
            label: '',
            description: `UDP надає меншу гарантію щодо доставки даних, він не передбачає підтвердження прийому даних та повторної передачі в разі втрати даних. Він просто відправляє пакети даних і не контролює їх потік.`,
          },
          {
            code: false,
            label: '',
            description: `Це робить UDP більш швидким за TCP, але менш надійним у тих випадках, коли надійність передачі даних є критично важливою, наприклад, при передачі відео або голосових даних.`,
          },
          {
            code: false,
            label: '',
            description: `Узагалі, TCP використовується для передачі великих обсягів даних, коли точність та надійність передачі даних є важливими, тоді як UDP використовується для швидкої передачі невеликих обсягів даних.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Service Workers?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Service Workers?',
            description: `Service Workers - це скрипти JavaScript, які запускаються в окремому фоновому процесі в браузері і дають можливість розробникам керувати кешуванням, мережевим запитом і поведінкою вашої веб-сторінки під час офлайн взаємодії з користувачем.`,
          },
          {
            code: false,
            label: '',
            description: `Service Workers можуть працювати на задньому плані, незалежно від вашого веб-застосунку, і мають доступ до певного API браузера, який дозволяє їм керувати кешуванням, мережевим запитом і поведінкою вашої веб-сторінки. Вони також можуть використовуватись для реалізації пуш-повідомлень і для покращення швидкості роботи веб-застосунку.`,
          },
          {
            code: false,
            label: '',
            description: `Service Workers працюють в контексті домену, з якого вони були зареєстровані, і вони можуть працювати тільки з HTTPS-з'єднаннями, щоб забезпечити безпеку користувачів. Це означає, що Service Workers можуть бути використані лише на живих веб-сайтах, а не на локальному комп'ютері.`,
          },
          {
            code: false,
            label: '',
            description: `Нижче наведено приклад налаштування Service Worker у ReactJS.`,
          },
          {
            code: true,
            label:
              '1. Створіть файл serviceWorker.js в корені вашого проекту. У цьому файлі ви можете зареєструвати Service Worker, визначити, які ресурси повинні бути кешовані, і які події повинні бути перехоплені.',
            description: `
            // serviceWorker.js

            const CACHE_NAME = 'my-cache';
            
            self.addEventListener('install', (event) => {
              console.log('Service Worker: Installing....');
              event.waitUntil(
                caches.open(CACHE_NAME)
                  .then((cache) => {
                    console.log('Service Worker: Caching app shell');
                    return cache.addAll([
                      '/',
                      '/index.html',
                      '/static/js/bundle.js',
                      '/static/css/main.css'
                    ]);
                  })
              );
            });
            
            self.addEventListener('fetch', (event) => {
              console.log('Service Worker: Fetching....');
              event.respondWith(
                caches.match(event.request)
                  .then((response) => {
                    if (response) {
                      console.log('Service Worker: Serving from cache');
                      return response;
                    }
                    console.log('Service Worker: Fetching from server');
                    return fetch(event.request);
                  })
              );
            });
            `,
          },
          {
            code: true,
            label: '2. Імпортуйте Service Worker у вашому компоненті index.js.',
            description: `
            // index.js

            import React from 'react';
            import ReactDOM from 'react-dom';
            import App from './App';
            import * as serviceWorker from './serviceWorker';
            
            ReactDOM.render(<App />, document.getElementById('root'));
            
            serviceWorker.register();
            
            `,
          },
          {
            code: true,
            label:
              '3. Додайте файл manifest.json у корінь вашого проекту. У цьому файлі ви можете визначити метадані про ваше додаток, такі як іконка, назва та короткий опис.',
            description: `
            // manifest.json

            {
              "name": "My App",
              "short_name": "My App",
              "icons": [
                {
                  "src": "icon.png",
                  "sizes": "192x192",
                  "type": "image/png"
                },
                {
                  "src": "icon-512.png",
                  "sizes": "512x512",
                  "type": "image/png"
                }
              ],
              "start_url": ".",
              "display": "standalone",
              "theme_color": "#000000",
              "background_color": "#ffffff"
            }

            `,
          },
          {
            code: true,
            label:
              '4. Додайте посилання на ваш файл маніфесту у вашому HTML-файлі.',
            description: `
            <!-- index.html -->

            <head>
              <meta charset="utf-8" />
              <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
              <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
              <title>My App</title>
            </head>

            <body>
              <div id="root"></div>
            </body>

            `,
          },
          {
            code: false,
            label: '',
            description: `Тепер ваш React додаток буде мати можливість працювати офлайн завдяки Service Workers.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Web Worklet?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Web Worklet?',
            description: `Web Worklet - це механізм браузера, що дозволяє виконувати скрипти на ізольованому потоці виконання. Це дозволяє відокремити код від основного потоку виконання і запобігти блокуванню інтерфейсу користувача під час виконання важких обчислень.`,
          },
          {
            code: false,
            label: '',
            description: `Web Worklet був запропонований як альтернатива Web Workers, що відкриває шлях для більш широкого спектру використання. Web Worklet може виконувати код, який взаємодіє зі сторонніми сервісами, відображає візуальні компоненти та інші задачі, які не можна виконувати в Web Workers.`,
          },
          {
            code: false,
            label: '',
            description: `Web Worklet використовує технологію WebAssembly, яка дозволяє виконувати код на мовах програмування, які не підтримуються браузером напряму. Це робить Web Worklet більш гнучким і можливою альтернативою Web Workers для виконання важких завдань в браузері.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке History API в браузері?',
        descriptions: [
          {
            code: false,
            label: 'Що таке History API в браузері?',
            description: `History API - це частина JavaScript-інтерфейсу браузера, яка дозволяє змінювати URL в адресній стрічці без перезавантаження сторінки та зберігати записи про історію переходів на сторінках в браузері. За допомогою History API можна змінювати URL без перезавантаження сторінки, отримувати інформацію про поточний URL та історію переходів на сторінках.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, для того, щоб додати запис в історію переходів на сторінках, можна використати метод pushState і передати йому об'єкт з потрібними даними, як показано у прикладі:`,
          },
          {
            code: true,
            label: '',
            description: `history.pushState({page: 2}, "Назва сторінки", "/сторінка-2");`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод pushState додає запис про новий URL "/сторінка-2" з назвою "Назва сторінки" та об'єктом даних {page: 2} до історії переходів на сторінках в браузері. При цьому сторінка не перезавантажується, а URL змінюється на новий. Для зчитування поточного URL можна використати властивість location.href, а для отримання даних про запис в історії переходів на сторінках - методи history.back() та history.forward().`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'що таке веб-сховище (web storage)?',
        descriptions: [
          {
            code: false,
            label: 'що таке веб-сховище (web storage)?',
            description: `Веб-сховище (web storage) - це механізм зберігання даних на стороні клієнта веб-додатків. Цей механізм дозволяє зберігати дані в локальному сховищі браузера без потреби взаємодії з сервером. Збережені дані доступні для веб-додатків, які вони створені для, і можуть бути використані для різних цілей, таких як збереження налаштувань користувачів, запам'ятовування даних форми, аутентифікації користувача та інших задач.`,
          },
          {
            code: false,
            label: '',
            description: `У веб-сховищі два типи об'єктів для зберігання даних: localStorage та sessionStorage. localStorage зберігає дані, які будуть доступні після закриття браузера, а sessionStorage зберігає дані, які будуть доступні лише в рамках одного сеансу браузера (тобто, поки користувач не закриє вкладку з веб-сайтом). Доступ до даних можна отримати за допомогою JavaScript API. Наприклад, для збереження даних у localStorage використовується такий синтаксис:`,
          },
          {
            code: true,
            label: '',
            description: `localStorage.setItem('ключ', 'значення');`,
          },
          {
            code: false,
            label: '',
            description: `А для отримання значення з localStorage:`,
          },
          {
            code: true,
            label: '',
            description: `const value = localStorage.getItem('ключ');`,
          },
          {
            code: false,
            label: '',
            description: `Дані можна видалити з localStorage за допомогою методу removeItem():`,
          },
          {
            code: true,
            label: '',
            description: `localStorage.removeItem('ключ');`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке sessionStorage?',
        descriptions: [
          {
            code: false,
            label: 'Що таке sessionStorage?',
            description: `sessionStorage - це інтерфейс Web Storage, який зберігає дані в браузері на протязі однієї сесії, яка зберігається між сторінками. Коли користувач закриває вкладку браузера або перезавантажує сторінку, дані знищуються.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою sessionStorage можна зберігати прості рядкові значення, що використовуються в додатку для зберігання даних в проміжку між сторінками. Значення можна отримати за ключем або встановити нове значення за ключем, який буде збережено в поточній сесії.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, можна зберігати обраний елемент у формі, щоб він залишався вибраним при оновленні сторінки. Нижче наведено приклад встановлення і отримання значення за допомогою sessionStorage в JavaScript:`,
          },
          {
            code: true,
            label: '',
            description: `
              // встановлюємо значення для ключа "username"
              sessionStorage.setItem("username", "John");

              // отримуємо значення для ключа "username"
              const username = sessionStorage.getItem("username");
              console.log(username); // виведе "John"
            `,
          },
          {
            code: false,
            label: '',
            description: `Значення, збережені у sessionStorage, будуть доступні на всіх сторінках в поточній сесії, але не будуть доступні на інших вкладках або після закриття браузера.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке BOM?',
        descriptions: [
          {
            code: false,
            label: 'Що таке BOM?',
            description: `BOM означає «Browser Object Model» (Об'єктна модель браузера) і є частиною API браузера. Це колекція об'єктів, що відображають властивості та функції браузера, які можуть використовуватися для маніпулювання вмістом веб-сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `До BOM належать такі об'єкти, як window, navigator, location, history, screen та інші. Ці об'єкти надають розробникам можливість отримувати доступ до різних функціональних можливостей браузера, таких як взаємодія з користувачем, навігація, робота з документами та інше. Наприклад, властивість window.location надає доступ до поточної адреси URL сторінки, а window.alert() викликає діалогове вікно з повідомленням для користувача.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою BOM можна маніпулювати не тільки веб-сторінками, а й самим браузером, таким чином, щоб змінювати розміри та положення вікна браузера, відкривати та закривати нові вкладки тощо. Однак, слід пам'ятати, що використання BOM може стати причиною проблем з кросбраузерною сумісністю, тому розробники повинні звертати на це увагу.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між cookie, sessionStorage та localStorage?',
        descriptions: [
          {
            code: false,
            label: 'cookie, sessionStorage та localStorage',
            description: `У веб-розробці є декілька способів зберігання даних в браузері, серед яких cookie, sessionStorage та localStorage. Ось їхні основні відмінності:`,
          },
          {
            code: false,
            label: '',
            description: `1. Cookie - це невеликі текстові файли, які зберігаються в браузері користувача. Вони зазвичай використовуються для зберігання інформації про користувача або його налаштування, які можуть бути використані на інших сторінках сайту. Куки можуть бути встановлені з сервера або з JavaScript на стороні клієнта.`,
          },
          {
            code: false,
            label: '',
            description: `2. sessionStorage - це механізм зберігання даних в браузері, який дозволяє зберігати дані протягом одного сеансу роботи з сайтом. Дані, збережені у sessionStorage, зникають після закриття вкладки або браузера.`,
          },
          {
            code: false,
            label: '',
            description: `3. localStorage - це механізм зберігання даних в браузері, який дозволяє зберігати дані назавжди або до тих пір, поки користувач не видалить їх вручну або не очистить кеш браузера.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, основна відмінність між цими трьома механізмами зберігання даних полягає в тривалості збереження. Cookie - це найменш потужний з них, оскільки він зберігається тільки на короткий проміжок часу. sessionStorage дозволяє зберігати дані протягом одного сеансу роботи з сайтом, тоді як localStorage дозволяє зберігати дані на невизначений термін.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке REST та RESTful api?',
        descriptions: [
          {
            code: false,
            label: 'REST та RESTful api',
            description: `REST (Representational State Transfer) - це архітектурний стиль для створення мережевих протоколів. RESTful API - це API, яке дотримується принципів REST.`,
          },
          {
            code: false,
            label: '',
            description: `REST побудований на основі HTTP і складається з наступних принципів:`,
          },
          {
            code: false,
            label: '',
            description: `• Кожен ресурс (наприклад, користувач, коментар, замовлення) ідентифікується унікальним URI (Uniform Resource Identifier).`,
          },
          {
            code: false,
            label: '',
            description: `• Клієнт взаємодіє з сервером за допомогою стандартних HTTP-запитів, таких як GET, POST, PUT і DELETE, що відповідають CRUD-операціям (створення, читання, оновлення та видалення).`,
          },
          {
            code: false,
            label: '',
            description: `• Кожен запит містить всю необхідну інформацію для обробки запиту (stateless). Сервер не зберігає стан клієнта між запитами.`,
          },
          {
            code: false,
            label: '',
            description: `• Відповідь сервера повинна бути чіткою і включати в себе достатню інформацію про ресурс, який запитується.`,
          },
          {
            code: false,
            label: '',
            description: `RESTful API повинен дотримуватися цих принципів, а також надати легку для розуміння документацію та демонстраційні приклади взаємодії з API. Взаємодія з RESTful API повинна бути безпечною, ефективною і масштабованою.`,
          },
          {
            code: false,
            label: '',
            description: `Основним способом використання RESTful API в React є використання функцій fetch() або бібліотеки, як от Axios чи jQuery AJAX. Ось приклад використання fetch():`,
          },
          {
            code: true,
            label: '',
            description: `
            import React, { useState, useEffect } from 'react';

            function Example() {
              const [data, setData] = useState(null);
            
              useEffect(() => {
                async function fetchData() {
                  const response = await fetch('/api/data');
                  const jsonData = await response.json();
                  setData(jsonData);
                }
            
                fetchData();
              }, []);
            
              if (!data) {
                return <div>Loading...</div>;
              }
            
              return (
                <div>
                  <h1>{data.title}</h1>
                  <p>{data.description}</p>
                </div>
              );
            }            
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо функцію fetch() для отримання даних з нашого RESTful API, яке відповідає на запит на /api/data. Після того, як ми отримаємо відповідь, ми перетворюємо її на об'єкт JSON і встановлюємо його як стан компонента за допомогою setData(). Якщо дані ще не завантажилися, ми виводимо повідомлення "Loading...". Якщо ж дані вже отримано, ми відображаємо їх у відповідних елементах.`,
          },
          {
            code: false,
            label: '',
            description: `Це дуже простий приклад, але можна використовувати різні методи HTTP-запитів (GET, POST, PUT, DELETE) для виконання операцій з базою даних. Також можна використовувати параметри запиту, щоб фільтрувати або сортувати дані перед їхнім отриманням.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке Triple handshake?',
        descriptions: [
          {
            code: false,
            label: 'Triple handshake',
            description: `Triple handshake - це процес установки з'єднання в протоколі TCP, який передбачає взаємодію клієнта і сервера у трьох етапах.`,
          },
          {
            code: false,
            label: '',
            description: `При встановленні з'єднання клієнт надсилає запит на підключення до сервера, відправляючи пакет з установлюючим флагом (SYN). Сервер отримує запит і відповідає на нього пакетом з флагами SYN та ACK. Клієнт в свою чергу надсилає підтвердження ACK.`,
          },
          {
            code: false,
            label: '',
            description: `Triple handshake відрізняється від двостороннього handshake, де після відправлення запиту на підключення клієнт чекає відповіді від сервера і надсилає підтвердження ACK разом з першими даними, що надсилає на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `riple handshake використовується для забезпечення стабільності з'єднання, оскільки перед відправкою даних клієнт та сервер перевіряють, чи є з'єднання доступним для передачі даних.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Git',
    questions: [
      {
        id: generateUUID(),
        question:
          'Як можна скасувати коміт у Git, якщо він уже був опублікований?',
        descriptions: [
          {
            code: false,
            label:
              'Як можна скасувати коміт у Git, якщо він уже був опублікований?',
            description: `Як варіант, зробивши обернений коміт за допомогою команди git revert [commit SHA]. Це створить коміт, що скасовує зміни зазначеного комміту. Після цього необхідно відправити зміни у віддалений репозиторій за допомогою команди git push [repository]/branch-name. Якщо коміт зроблено на особистій гілці, яка не використовується ніким крім автора, помилковий коміт можна відзначити прапором drop в інтерактивному режимі ребейза (git rebase -i), що повністю видалить зазначений коміт з історії. Після цього необхідно відправити зміни у віддалений репозиторій за допомогою команди git push [repository]/branch-name з прапором force.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'У чому полягає різниця між git pull і git fetch?',
        descriptions: [
          {
            code: false,
            label: 'У чому полягає різниця між git pull і git fetch?',
            description: `Git pull витягує (fetch) дані з сервера і автоматично робить злиття (merge) їх із кодом поточної гілки. Git fetch — зв'язується з віддаленим репозиторієм та отримує дані, які відсутні у локальному. Під час виконання цієї команди злиття не відбувається.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке "staging area" або "index" в Git?',
        descriptions: [
          {
            code: false,
            label: 'Що таке "staging area" або "index" в Git?',
            description: `Staging area (область підготовлених файлів) — файл, який зазвичай розташовується в Git-директорії і містить інформацію про зміни, які потраплять до наступного коміту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'За що відповідає команда Git stash?',
        descriptions: [
          {
            code: false,
            label: 'За що відповідає команда Git stash?',
            description: `Git stash - команда, що зберігає змінений стан робочої директорії або окремого файлу в сховищі незавершених змін. Це дає можливість будь-якої миті застосувати їх назад. Наприклад, якщо потрібно перейти між гілками без фіксації змін, можна застосувати команду git stash, робоча директорія залишиться без змін, дані будуть збережені в спеціальному сховищі. Щоб переглянути заховані зміни, потрібно викликати команду git stash list, а для застосування — git stash apply.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як знайти список файлів, які змінилися у певному коміті?',
        descriptions: [
          {
            code: false,
            label: 'Як знайти список файлів, які змінилися у певному коміті?',
            description: `Це досягається переглядом історії коммітів за допомогою команди git log із застосуванням певних прапорів:`,
          },
          {
            code: false,
            label: '',
            description: `stat - під кожним із коммітів з'явиться список та кількість змінених файлів, кількість рядків, доданих та віддалених у кожному з файлів. Насамкінець, під списком, буде виведено сумарну статистику.`,
          },
          {
            code: false,
            label: '',
            description: `name-status — показує список змінених файлів, видалених.`,
          },
          {
            code: false,
            label: '',
            description: `Для пошуку списку файлів у конкретному коміті можна виконати команду git show і вказати хеш комміта.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'За що відповідає команда "git config"?',
        descriptions: [
          {
            code: false,
            label: 'За що відповідає команда "git config"?',
            description: `Git config — команда, яка дозволяє переглядати та настроювати конфігурацію git репозиторію.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'З чого складається коміт у Git?',
        descriptions: [
          {
            code: false,
            label: 'З чого складається коміт у Git?',
            description: `Коміт — це список, який складається з об'єктів із зміненими файлами та посилання на попередній коміт. Також вказуються імена автора, мітки часу та повідомлення комміту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Как створити Git-репозиторий ?',
        descriptions: [
          {
            code: false,
            label: 'Как створити Git-репозиторий ?',
            description: `Створити Git-репозиторій можна двома шляхами. Перший – версіонування існуючого проекту. Для цього потрібно перейти в папку з проектом та виконати команду git init, що задасть структуру Git-репозиторію. Після базової конфігурації (git config), репозиторія можна буде версіонувати проект.
Другий: клонування віддаленого репозиторію. Для цього потрібно виконати команду git clone [url],
            Де [url] - адреса репозиторію.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як об`єднати кілька окремих коммітів в один цілісний коміт?',
        descriptions: [
          {
            code: false,
            label:
              'Як об`єднати кілька окремих коммітів в один цілісний коміт?',
            description: `Це можна зробити за допомогою перебазування в інтерактивному режимі (rebase). Наприклад, щоб об'єднати, 3 останніх коммита в один, необхідно виконати команду git rebase -i HEAD~3 (3 відповідає числу коммітів, які потрібно об'єднати, відлік від HEAD). Відкриється вікно редактора, в якому перші 3 рядки відповідають останнім трьом комітам:`,
          },
          {
            code: true,
            label: '',
            description: `pick ab37583 Added feature 1.
pick 3ab2b83 Added feature 2.
pick 3ab5683 Added feature 3`,
          },
          {
            code: false,
            label: '',
            description: `На початку кожного рядка стоїть слово "pick". Потрібно змінити його на squash або s, зберегти зміни, закрити редактор, після чого git попросить задати повідомлення нового комміта, що містить зміни трьох вихідних.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'За що відповідає команда Git Bisect? Як її можна використовувати визначення джерела бага (регресії) ?',
        descriptions: [
          {
            code: false,
            label: 'Команда Git Bisect',
            description: `Команда Git bisect виконує бінарний пошук з історії комітів. Якщо невідомо, де знаходиться проблема і було зроблено багато коммітів, можна скористатися командою git bisect, щоб визначити комміт, який викликав проблему. Для цього потрібно виконати команду: git bisect start, потім git bisect bad це вкаже Git комміт, в якому була виявлена проблема. Коміт git bisect good [хеш комміта] вкаже Git комміт у якому проблема не виявляється. Далі Git з'ясує кількість проміжних коммітів та за допомогою бінарного пошуку, пересуваючи покажчик на деякі з проміжних коммітів, допоможе знайти проблемний.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як налаштувати Git-репозиторій',
        descriptions: [
          {
            code: false,
            label:
              'Як налаштувати Git-репозиторій для запуску інструментів перевірки працездатності коду безпосередньо перед виконанням коммітів та запобігання їх у разі збою тесту?',
            description: `За допомогою хука pre-commit. Для цього потрібно визначити конфігураційний файл pre-commit (у папці .git/hooks), код перевірки працездатності внесених змін. Після цього, Git запускатиме вказану перевірку перед кожним коммітом. Якщо перевірка поверне код відмінний від нуля, коміт не буде застосований.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які ви знаєте моделі розгалуження у Git? Опишіть їх.',
        descriptions: [
          {
            code: false,
            label: 'Які ви знаєте моделі розгалуження у Git? Опишіть їх.',
            description: `Однією з найпопулярніших моделей розгалуження Git є git flow. Коротко кажучи, працюючи за цією моделлю в репозиторії повинні бути дві постійні гілки (master, develop) і будь-яка кількість тимчасових гілок (feature-, release-, hotfix-) які вливаються в основні. Порядок підготовки релізів від початку розробки та безпосередньо до здійснення релізу чітко диктується моделлю. Докладніше можна почитати за посиланням.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Яким чином можна встановити чи було злиття гілки в master?',
        descriptions: [
          {
            code: false,
            label: 'Яким чином можна встановити чи було злиття гілки в master?',
            description: `Команда git branch -merged відфільтровує гілки, які були злиті`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке git-rebase і для чого він потрібний?',
        descriptions: [
          {
            code: false,
            label: 'Що таке git-rebase і для чого він потрібний?',
            description: `Команда git rebase (перебазирование) — применяет коммиты текущей ветки после коммитов ветки (base tip), указанной в команде rebase. С помощью rebase можно выполнять целый ряд задач: слияние веток, перемотку (fast forwarding), изменение коммитов текущей ветки (редактирование, именование, удаление, слияние, перетасовка коммитов), пересадку текущей ветки (с помощью опции —onto) и др.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке cherry pick?',
        descriptions: [
          {
            code: false,
            label: 'Що таке cherry pick?',
            description: `git cherry-pick - це корисна команда, за допомогою якої можна вибірково застосувати коміти Git до поточної робочої гілки HEAD. З її допомогою можна вибрати коміт із однієї гілки та застосувати його до іншої. Команда git cherry-pick – це зручний спосіб скасувати зміни.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке git amend?',
        descriptions: [
          {
            code: false,
            label: 'Що таке git amend?',
            description: `Команда git amend використовується для зміни останнього коміту в гілці.`,
          },{
            code: false,
            label: 'Що таке git amend?',
            description: `Наприклад, якщо ви зробили коміт з помилковим повідомленням, ви можете використовувати команду git commit --amend для зміни повідомлення без створення нового коміту. Для внесення змін до змісту коміту ви можете спочатку внести зміни в файли, а потім виконати команду git add для додавання змінених файлів до стейджування, а потім використовувати git commit --amend для зміни коміту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке git merge --squash?',
        descriptions: [
          {
            code: false,
            label: 'Що таке git merge --squash?',
            description: `Команда git merge --squash дозволяє злити зміни з однієї гілки в іншу, але при цьому не створює злитого коміту з повною історією злиття. Замість цього, команда злиття створює новий коміт зі змінами, які були злиті, але не включає історію злиття або деталі про походження змін.`,
          },{
            code: false,
            label: '',
            description: `Отже, коли ви використовуєте команду git merge --squash, Git злиття збирає всі зміни з цільової гілки і копіює їх у вашу поточну гілку, але не створює злитого коміту. Потім вам потрібно створити новий коміт за допомогою git commit, в який включаєте всі зміни зі злиття.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'HTML',
    questions: [
      {
        id: generateUUID(),
        question: 'Що таке HTML та для чого його використовують?',
        descriptions: [
          {
            code: false,
            label: `Що таке HTML та для чого його використовують?`,
            description: `HTML (Hypertext Markup Language) - це мова розмітки, що використовується для створення веб-сторінок. За допомогою HTML можна описати структуру сторінки, вказати заголовки, абзаци, зображення, посилання та інші елементи контенту.`,
          },
          {
            code: false,
            label: ``,
            description: `HTML складається з різних тегів, які вказують браузеру, як відображати контент. Наприклад, тег <p> вказує на абзац тексту, тег <img> вказує на зображення, а тег <a> вказує на посилання.`,
          },
          {
            code: false,
            label: ``,
            description: `HTML є основним компонентом веб-сторінок, оскільки він використовується для створення контенту на сторінках, що відображається в браузері. За допомогою HTML можна створювати сайти, бізнес-сторінки, веб-додатки, блоги та інші веб-ресурси.`,
          },
          {
            code: false,
            label: ``,
            description: `Крім того, HTML часто використовується в поєднанні з CSS (Cascading Style Sheets) і JavaScript, щоб створювати інтерактивні та динамічні веб-сторінки з красивим дизайном і відмінними функціональними можливостями.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які глобальні атрибути є у HTML?',
        descriptions: [
          {
            code: false,
            label: `Які глобальні атрибути є у HTML?`,
            description: `У HTML існує декілька глобальних атрибутів, які можуть бути використані з будь-яким елементом:`,
          },
          {
            code: false,
            label: ``,
            description: `1. class - визначає ім'я класу елемента, що дозволяє створювати CSS-стилі для цього елемента.`,
          },
          {
            code: false,
            label: ``,
            description: `2. id - визначає унікальний ідентифікатор елемента.`,
          },
          {
            code: false,
            label: ``,
            description: `3. style - дозволяє встановлювати стилі для елемента без використання CSS-файлу.`,
          },
          {
            code: false,
            label: ``,
            description: `4. title - встановлює заголовок для елемента, який може використовуватися для відображення віджетів допомоги або призначення для скрінрідера.`,
          },
          {
            code: false,
            label: ``,
            description: `5. lang - вказує мову, яка використовується в елементі.`,
          },
          {
            code: false,
            label: ``,
            description: `6. data-* - дозволяє вставляти в елемент додаткові дані, які можуть бути використані для JavaScript і CSS.`,
          },
          {
            code: false,
            label: ``,
            description: `7. dir - вказує напрямок тексту для елемента.`,
          },
          {
            code: false,
            label: ``,
            description: `8. tabindex - вказує порядковий номер елемента в послідовності переходу фокусу.`,
          },
          {
            code: false,
            label: ``,
            description: `Ці глобальні атрибути можуть бути використані з будь-яким елементом в HTML, щоб визначити їхню поведінку та відображення на сторінці. Використання цих атрибутів може полегшити розробку веб-сторінок і підвищити їх доступність для користувачів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке категорії контенту в HTML5?',
        descriptions: [
          {
            code: false,
            label: `Що таке категорії контенту в HTML5?`,
            description: `В HTML5 визначено декілька категорій контенту, які дозволяють відображати різноманітний контент на веб-сторінках. Кожна категорія має свій власний семантичний сенс та дозволяє встановлювати різні атрибути для елементів.`,
          },
          {
            code: false,
            label: ``,
            description: `Основні категорії контенту в HTML5:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Структурні елементи: ці елементи використовуються для визначення структури веб-сторінки, такої як заголовки, меню, футер та інші. До цієї категорії відносяться елементи header, nav, section, article, aside та footer.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Групуючі елементи: ці елементи використовуються для групування контенту в межах веб-сторінки. До цієї категорії відносяться елементи div та span.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Вбудовування контенту: ці елементи використовуються для вбудовування зовнішнього контенту, такого як зображення, відео, аудіо та інші. До цієї категорії відносяться елементи img, video, audio та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Форми та інтерактивні елементи: ці елементи використовуються для створення форм та інших елементів, які дозволяють користувачам взаємодіяти з веб-сторінкою. До цієї категорії відносяться елементи form, input, button, select та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `5. Текстові елементи: ці елементи використовуються для відображення текстового контенту на веб-сторінках. До цієї категорії відносяться елементи p, h1, h2, ul, ol, li та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `6. Мета-інформація: ці елементи використовуються для надання мета-інформації про веб-сторінку, такої як заголовок, мета-теги та інші. До цієї категорії відносяться елементи head, meta,`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які категорії вважаються основними категоріями контенту?',
        descriptions: [
          {
            code: false,
            label: `Які категорії вважаються основними категоріями контенту?`,
            description: `У HTML5 існує сім основних категорій контенту:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Metadata content (метадані) - інформація про сторінку, така як заголовок, опис, автор, ключові слова та інше. Приклади: <title>, <meta>, <link>.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Flow content (потоковий контент) - це найбільш загальна категорія, яка містить звичайний текст, зображення, відео та інші елементи контенту, які можна розміщувати в тілі сторінки. Приклади: <p>, <img>, <video>, <audio>, <a>, <div>, <span>, <h1>, <h2>, <h3>, <h4>, <h5>, <h6>.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Sectioning content (контент секціонування) - це контент, який допомагає організувати сторінку на розділи, що допомагає у покращенні доступності та SEO. Приклади: <section>, <article>, <nav>, <aside>, <header>, <footer>, <main>.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Heading content (заголовки) - це контент, що використовується для позначення заголовків сторінки або розділів сторінки. Приклади: <h1>, <h2>, <h3>, <h4>, <h5>, <h6>.`,
          },
          {
            code: false,
            label: ``,
            description: `5. Phrasing content (фразовий контент) - це контент, який розміщується в межах Flow content та використовується для надання змісту Flow content. Приклади: <strong>, <em>, <mark>, <small>, <big>, <code>, <pre>, <cite>, <abbr>, <br>, <wbr>.`,
          },
          {
            code: false,
            label: ``,
            description: `6. Embedded content (вбудований контент) - це контент, який вбудовується в інший контент, такий як зображення, відео, аудіо, документи та інше. Приклади: <img>, <video>, <audio>, <iframe>, <embed>, <object>.`,
          },
          {
            code: false,
            label: ``,
            description: `7. Interactive content (інтерактивний контент) - це контент, який може бути взаємодійний з користувачем, такий як форми, кнопки, посилання та інше. Приклади: <a>, <button>, <input>, <label>, <select>`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке doctype? І для чого він використовується?',
        descriptions: [
          {
            code: false,
            label: `Що таке doctype? І для чого він використовується?`,
            description: `Doctype (Document Type Declaration) - це інструкція, яка розміщується на початку HTML-документа і вказує на версію HTML, яку слід використовувати для відображення сторінки. Він також допомагає браузеру коректно інтерпретувати HTML-код.`,
          },
          {
            code: false,
            label: ``,
            description: `Doctype дуже важливий, оскільки він допомагає браузеру коректно інтерпретувати HTML-код, а також забезпечує правильне відображення сторінки. Якщо doctype не вказаний або вказаний неправильно, браузер може відображати сторінку неправильно або взагалі не відображати її. Окрім того, doctype дозволяє використовувати сучасні стандарти HTML і CSS для розробки сторінок.`,
          },
          {
            code: true,
            label: ``,
            description: `<!DOCTYPE html>`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Опишіть базову структуру HTML-сторінки?',
        descriptions: [
          {
            code: false,
            label: `Опишіть базову структуру HTML-сторінки?`,
            description: `Основна структура HTML-сторінки містить наступні елементи:`,
          },
          {
            code: false,
            label: ``,
            description: `1. <!DOCTYPE> - тип документу, який використовується на сторінці.`,
          },
          {
            code: false,
            label: ``,
            description: `2. <html> - кореневий елемент сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `3. <head> - контейнер для метаданих сторінки, таких як заголовок, посилання на зовнішні ресурси, мета-теги і т.д.`,
          },
          {
            code: false,
            label: ``,
            description: `4. <meta> - елемент для визначення метаданих сторінки, наприклад, мови, кодування і т.д.`,
          },
          {
            code: false,
            label: ``,
            description: `5. <title> - заголовок сторінки, який відображається в рядку заголовка браузера.`,
          },
          {
            code: false,
            label: ``,
            description: `6. <body> - тіло сторінки, включає в себе контент сторінки, який відображається на веб-сторінці.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, проста HTML-сторінка може мати наступну структуру:`,
          },
          {
            code: true,
            label: ``,
            description: `
            <!DOCTYPE html>
            <html>
              <head>
                <meta charset="UTF-8">
                <title>Моя перша HTML-сторінка</title>
              </head>
              <body>
                <h1>Ласкаво просимо на мою першу HTML-сторінку</h1>
                <p>Це моя перша сторінка, написана на HTML.</p>
              </body>
            </html>            
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі <!DOCTYPE html> визначає тип документу як HTML, <html> є кореневим елементом сторінки, <head> містить метадані, а <body> містить основний контент сторінки, такий як заголовок (<h1>) і абзац (<p>).`,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Що таке валідація? І які типи перевірок HTML документа ви знаєте?',
        descriptions: [
          {
            code: false,
            label: `Що таке валідація? І які типи перевірок HTML документа ви знаєте?`,
            description: `Валідація - це процес перевірки правильності форматування даних у веб-формі або на веб-сторінці перед їх відправкою на сервер. Основна мета валідації - запобігти надходження некоректних даних на сервер, що може призвести до помилок в обробці даних та зниження якості роботи веб-сайту.`,
          },
          {
            code: false,
            label: ``,
            description: `Типи перевірок HTML документа:`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка формату введення даних: перевірка правильності введення текстових даних, чисел, дат, електронних адрес, телефонних номерів та інших типів даних.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка обов'язкових полів: перевірка на заповненість обов'язкових полів форми перед відправкою її на сервер.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка розміру даних: перевірка на максимальний та мінімальний розмір даних, що можуть бути введені в поля форми.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на унікальність даних: перевірка на унікальність введених даних, наприклад, перевірка на унікальність електронної адреси користувача або логіну.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на допустимі символи: перевірка на наявність допустимих символів введення даних.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на відповідність шаблону: перевірка на відповідність введених даних визначеному шаблону, наприклад, шаблону для номера кредитної картки.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на права доступу: перевірка на наявність необхідних прав доступу до ресурсів на сервері.`,
          },
          {
            code: false,
            label: ``,
            description: `• Перевірка на наявність вірусів: перевірка на наявність вірусів у завантажених на сервер файлах або сторінках.`,
          },
          {
            code: false,
            label: ``,
            description: `Ці перевірки можуть бути виконані як на стороні клієнта, так і на стороні сервера.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Основні етапи перевірок валідності HTML-документа',
        descriptions: [
          {
            label: 'Стадія 1: Парсинг',
            description: `
              Першим етапом перевірки є парсинг HTML-документа, коли браузер аналізує HTML-код і створює з нього структуру DOM-дерева.
              Під час парсингу, браузер може виявити синтаксичні помилки, такі як незакриті теги, неправильно вкладені теги тощо.
            `,
            code: false,
          },
          {
            label: 'Стадія 2: Валідація',
            description: `
              Другим етапом є валідація HTML-коду, що означає перевірку, чи відповідає HTML-документ стандартам W3C.
              Якщо в HTML-документі є помилки, то браузер може відображати його неправильно або навіть ігнорувати деякі елементи.
            `,
            code: false,
          },
          {
            label: 'Приклад коду:',
            description: `
              <!DOCTYPE html>
              <html>
                <head>
                  <meta charset="utf-8">
                  <title>Мій HTML-документ</title>
                </head>
                <body>
                  <h1>Привіт світ!</h1>
                  <p>Це мій перший HTML-документ.</p>
                </body>
              </html>
            `,
            code: true,
          },
        ],
      },
      {
        id: generateUUID(),
        question:
          'Якщо уявити HTML5 як відкриту веб-платформу, з яких блоків він складається?',
        descriptions: [
          {
            code: false,
            label:
              'Якщо уявити HTML5 як відкриту веб-платформу, з яких блоків він складається?',
            description: `HTML5 як веб-платформа складається з наступних блоків:`,
          },
          {
            code: false,
            label: '',
            description: `• Семантичні теги - це теги, які використовуються для надання значення контенту і опису його структури на веб-сторінці. Такі теги, як <header>, <nav>, <article>, <section>, <footer> і <aside>, допомагають організувати контент і зробити його більш доступним для користувачів і пошукових систем.`,
          },
          {
            code: false,
            label: '',
            description: `• Форми - це елементи, які дозволяють користувачам взаємодіяти з веб-сторінкою, вводячи дані, виконуючи пошук або відправляючи дані на сервер. HTML5 надає багато нових типів полів вводу, таких як дата, електронна пошта, номер телефону і т.д.`,
          },
          {
            code: false,
            label: '',
            description: `• Мультимедіа - це елементи, які дозволяють вставляти мультимедійний контент на веб-сторінку. HTML5 підтримує відео, аудіо і зображення.`,
          },
          {
            code: false,
            label: '',
            description: `• Графіка і візуалізація - це блок, який містить нові теги, які дозволяють створювати складні візуалізації і графіки на веб-сторінках без необхідності використовувати додаткові плагіни або скрипти.`,
          },
          {
            code: false,
            label: '',
            description: `• Хмарні технології - це блок, який містить нові теги, які дозволяють взаємодіяти з хмарними сервісами, такими як Google Maps і YouTube.`,
          },
          {
            code: false,
            label: '',
            description: `• Нові API - це блок, який містить нові API, які дозволяють взаємодіяти з пристроями, такими як камера і мікрофон, а також зберігати інформацію локально на пристрої користувача.`,
          },
          {
            code: false,
            label: '',
            description: `Ці блоки дозволяють розробникам створювати більш складні та інтерактивні веб-додатки з більшими можливостями та більшим рівнем доступності для користувачів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке інлайновий стиль? Чи можна його перевизначити?',
        descriptions: [
          {
            code: false,
            label: 'Що таке інлайновий стиль? Чи можна його перевизначити?',
            description: `Інлайновий стиль - це метод задання стилів безпосередньо всередині HTML-елементу з використанням атрибуту "style". За допомогою інлайнових стилів можна задавати конкретні стилі для окремих елементів, такі як колір тексту, розмір шрифту, фоновий колір тощо.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, для того, щоб задати червоний колір тексту у певному елементі, можна використати наступний код з інлайновим стилем:`,
          },
          {
            code: true,
            label: '',
            description: `<p style="color: red;">Це червоний текст</p>`,
          },
          {
            code: false,
            label: '',
            description: `Інлайновий стиль можна перевизначати, але це може бути складним, особливо якщо на сторінці є багато елементів з інлайновими стилями. Кращим підходом є використання зовнішніх стилів CSS, що дозволяють централізовано керувати стилями на всій сторінці та уникнути дублювання коду.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Чи є у HTML елементів свої дефолтні специфічні стилі?',
        descriptions: [
          {
            code: false,
            label: 'Чи є у HTML елементів свої дефолтні специфічні стилі?',
            description: `Так, у більшості елементів HTML є дефолтні специфічні стилі, які браузери застосовують до цих елементів, якщо вони не мають власного CSS стилю. Наприклад, для тега <p> браузер застосовує маргіни, шрифт, кольори і інші стилі за замовчуванням.`,
          },
          {
            code: false,
            label: '',
            description: `Ці дефолтні стилі можуть відрізнятися від браузера до браузера, тому рекомендується використовувати reset CSS, щоб забезпечити єдиний вигляд вашого веб-сайту на різних браузерах.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке семантика? Які семантичні теги ви знаєте?',
        descriptions: [
          {
            code: false,
            label: 'Що таке семантика? Які семантичні теги ви знаєте?',
            description: `Семантика - це поняття, яке використовується в програмуванні та розробці веб-сайтів, щоб описати значення контенту на сторінці, зокрема, який контент представляється на сторінці та яку роль він відіграє в структурі сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `У HTML є багато семантичних тегів, які допомагають описати зміст сторінки. Ось деякі з найбільш поширених семантичних тегів:`,
          },
          {
            code: false,
            label: '',
            description: `1. <header> - використовується для визначення верхньої частини сторінки або блоку контенту.`,
          },
          {
            code: false,
            label: '',
            description: `2. <nav> - використовується для визначення навігаційного блоку сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `3. <main> - використовується для визначення головного контенту сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `4. <section> - використовується для групування пов'язаного контенту на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `5. <article> - використовується для визначення самостійних статей або блоків контенту на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `6. <aside> - використовується для визначення бічної панелі, яка може містити додатковий контент, що не пов'язаний з головним контентом сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `7. <footer> - використовується для визначення нижньої частини сторінки або блоку контенту.`,
          },
          {
            code: false,
            label: '',
            description: `8. <time> - використовується для визначення дати та часу.`,
          },
          {
            code: false,
            label: '',
            description: `9. <address> - використовується для визначення контактної інформації.`,
          },
          {
            code: false,
            label: '',
            description: `10. <form> - використовується для створення форми для введення даних користувачем.`,
          },
          {
            code: false,
            label: '',
            description: `Ці семантичні теги допомагають встановити правильну структуру та семантику сторінки, що покращує якість і оптимізує роботу з нею.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як семантично правильно зверстати картинку з підписом?',
        descriptions: [
          {
            code: false,
            label: 'Як семантично правильно зверстати картинку з підписом?',
            description: `Для семантично правильного верстування картинки з підписом, ми можемо використовувати тег <figure> для обгортання картинки і тег <figcaption> для підпису.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, ось такий код може бути використаний для відображення картинки з підписом:`,
          },
          {
            code: true,
            label: '',
            description: `
            <figure>
              <img src="image.jpg" alt="Короткий опис зображення">
              <figcaption>Підпис до зображення</figcaption>
            </figure>`,
          },
          {
            code: false,
            label: '',
            description: `Тут тег <figure> використовується для групування картинки і підпису, а тег <figcaption> використовується для відображення підпису до картинки. Використання таких семантичних тегів дозволяє браузерам та іншим інструментам для обробки вмісту краще розуміти структуру документа і поліпшує доступність та індексацію контенту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Типи списків у HTML?',
        descriptions: [
          {
            code: false,
            label: 'Типи списків у HTML?',
            description: `У HTML є три типи списків:`,
          },
          {
            code: false,
            label: '',
            description: `1. Нумерований список (<ol>) - список, в якому кожен елемент має порядковий номер у вигляді цифри або літери.`,
          },
          {
            code: false,
            label: '',
            description: `2. Маркований список (<ul>) - список, в якому кожен елемент має маркувальний символ, зазвичай це крапка або інший символ.`,
          },
          {
            code: false,
            label: '',
            description: `3. Список описів (<dl>) - список, в якому кожен елемент містить термін та його визначення. Термін відображається з використанням тега <dt>, а його визначення з тегом <dd>.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, так можна створити нумерований список у HTML:`,
          },
          {
            code: true,
            label: '',
            description: `
            <ol>
              <li>Перший елемент</li>
              <li>Другий елемент</li>
              <li>Третій елемент</li>
            </ol>
            `,
          },
          {
            code: false,
            label: '',
            description: `А от так виглядатиме маркований список:`,
          },
          {
            code: true,
            label: '',
            description: `
            <ul>
              <li>Перший елемент</li>
              <li>Другий елемент</li>
              <li>Третій елемент</li>
            </ul>          
            `,
          },
          {
            code: false,
            label: '',
            description: `А список описів можна створити за допомогою наступного коду:`,
          },
          {
            code: true,
            label: '',
            description: `
            <dl>
              <dt>Термін 1</dt>
              <dd>Визначення терміну 1</dd>
              <dt>Термін 2</dt>
              <dd>Визначення терміну 2</dd>
              <dt>Термін 3</dt>
              <dd>Визначення терміну 3</dd>
            </dl>
           `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Для якого тега використовується атрибут alt і навіщо він потрібен?',
        descriptions: [
          {
            code: false,
            label: 'Для якого тега використовується атрибут alt і навіщо він потрібен?',
            description: `Атрибут alt використовується для тега <img> в HTML. Він описує текстову альтернативу для зображення, якщо з якихось причин воно не може бути відображене на сторінці. Наприклад, якщо користувач має вимкнені зображення у своєму браузері, він побачить текст замість зображення, що дозволить зрозуміти, що малюнок тут мав бути.`,
          },
          {
            code: false,
            label: '',
            description: `Також, атрибут alt є важливим для доступності веб-сайту, оскільки екранні читачі використовують його для озвучення зображення людям з відповідними потребами. Тому варто завжди додавати атрибут alt до зображень на веб-сторінках.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Яка різниця між тегами <strong><em> і <b><i>?',
        descriptions: [
          {
            code: false,
            label: 'Яка різниця між тегами <strong><em> і <b><i>?',
            description: `Теги <strong> і <em> мають семантичне значення і призначені для визначення вагомості і емоційної інтонації тексту відповідно. Тег <strong> позначає текст, який має велику вагу, тобто текст, який є основним і важливим в контексті документа. Тег <em>, з іншого боку, вказує на текст, який має бути виділений з причин емоційної забарвленості, наприклад, для виокремлення акцентів, інтонації або емоційної виразності.`,
          },
          {
            code: false,
            label: '',
            description: `Теги <b> і <i>, з іншого боку, не мають семантичного значення і призначені для визначення стилістичних або графічних характеристик тексту. Тег <b> вказує на текст, який має бути виділений жирним шрифтом, а тег <i> - на текст, який має бути виділений курсивним шрифтом.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, для правильної семантики тексту в HTML рекомендується використовувати теги <strong> і <em>, а для стилістичного оформлення - теги <b> і <i>.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Типи <input> елементів у HTML?',
        descriptions: [
          {
            code: false,
            label: 'Типи <input> елементів у HTML?',
            description: `Тег <input> у HTML має декілька типів елементів, які можуть бути використані для отримання різного типу введення від користувача. Деякі з найпоширеніших типів input включають:`,
          },
          {
            code: false,
            label: '',
            description: `1. text: дозволяє користувачам вводити текст в однорядкове поле.`,
          },
          {
            code: false,
            label: '',
            description: `2. password: аналогічно полю введення тексту, але символи, введені користувачем, замінюються зірочками або крапками для безпеки.`,
          },
          {
            code: false,
            label: '',
            description: `3. checkbox: дозволяє користувачам вибирати один або декілька варіантів з відомим набором значень.`,
          },
          {
            code: false,
            label: '',
            description: `4. radio: дозволяє користувачам вибирати один з декількох варіантів, пропонованих відомим набором значень.`,
          },
          {
            code: false,
            label: '',
            description: `5. submit: використовується для відправки форми на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `6. reset: дозволяє користувачам скинути всі поля форми до їх початкових значень.`,
          },
          {
            code: false,
            label: '',
            description: `7. file: дозволяє користувачам вибирати файл для завантаження на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `8. hidden: створює приховане поле, яке можна використовувати для передачі додаткової інформації на сервер без відображення його на сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `Це далеко не повний список можливих типів елементів <input>, але він охоплює більшість з найбільш поширених випадків використання.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Чому гарною практикою вважається розташовувати <link> для під'єднання CSS стилів усередині тега <head>, а <script> для під'єднання JS ставити перед тегом </body>, що закривається?`,
        descriptions: [
          {
            code: false,
            label: `Чому гарною практикою вважається розташовувати <link> для під'єднання CSS стилів усередині тега <head>, а <script> для під'єднання JS ставити перед тегом </body>, що закривається?`,
            description: `Розташування тегів <link> і <script> в HTML-документі має певне значення для оптимізації завантаження сторінки і для забезпечення правильної роботи скриптів.`,
          },
          {
            code: false,
            label: ``,
            description: `Тег <link> використовується для підключення зовнішніх ресурсів, таких як CSS-файли. Розміщення тегу <link> у тезі <head> дозволяє браузеру завантажувати CSS-файли до того, як він розпочне рендеринг сторінки. Це дозволяє браузеру правильно відображати контент з першого разу, а не затримувати відображення до завершення завантаження CSS-файлу.`,
          },
          {
            code: false,
            label: ``,
            description: `З іншого боку, тег <script> використовується для включення скриптів на сторінці. Якщо скрипти розміщені у тезі <head>, вони будуть завантажуватись перед відображенням контенту сторінки, що може затримати її відображення. Розміщення тегу <script> перед закриваючим тегом </body> дозволяє браузеру завантажувати скрипти після того, як контент сторінки буде повністю завантажено і відображено користувачеві. Це поліпшує швидкість завантаження сторінки та дозволяє уникнути можливих проблем з відображенням сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, розміщення тегів <link> та <script> відповідно в тезі <head> і перед закриваючим тегом </body> дозволяє забезпечити правильне завантаження і рендеринг сторінки, що є важливим для користувачів та для пошукових систем.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке мета-теги?`,
        descriptions: [
          {
            code: false,
            label: `Що таке мета-теги?`,
            description: `Мета-теги (англ. meta tags) - це елементи HTML, що надають додаткову інформацію про сторінку веб-сайту для пошукових систем та браузерів.`,
          },
          {
            code: false,
            label: ``,
            description: `Зазвичай, мета-теги розміщуються в секції <head> HTML документа і не відображаються на сторінці веб-сайту. Їх головна роль - забезпечити додаткову інформацію про сторінку для пошукових систем та інших програм, які обробляють веб-сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, мета-теги можуть містити інформацію про ключові слова сторінки, опис її змісту, автора, дату оновлення, мову та інші дані. Ця інформація використовується для покращення різноманітних процесів, наприклад, для підвищення рейтингу сторінки в пошукових системах, поліпшення відображення у соціальних мережах, та ін.`,
          },
          {
            code: false,
            label: ``,
            description: `Приклад мета-тегу, який містить опис сторінки:`,
          },
          {
            code: true,
            label: ``,
            description: `<meta name="description" content="Опис сторінки">`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що описується в тезі <head>?`,
        descriptions: [
          {
            code: false,
            label: `Що описується в тезі <head>?`,
            description: `Тег <head> у HTML документі використовується для зберігання метаданих, тобто інформації про сам документ, яка не відображається безпосередньо на сторінці, а використовується для її опрацювання браузером та пошуковими системами.`,
          },
          {
            code: false,
            label: ``,
            description: `У тезі <head> можна включати різноманітні метатеги, які задають метадані сторінки, такі як заголовок документа, опис, ключові слова, автор, кодування сторінки та інші. Також у тезі <head> можна включати посилання на зовнішні ресурси, такі як CSS стилі, JavaScript файли, шрифти та інші.`,
          },
          {
            code: false,
            label: ``,
            description: `В заголовку сторінки можуть бути також включені інші теги, наприклад, <title>, <base>, <link>, <script>, <meta>, які виконують різні функції в HTML документі. Також у тезі <head> можуть бути включені різні скрипти, які використовуються для аналізу та відстеження поведінки користувачів на сторінці, а також для підключення різних інструментів аналізу та оптимізації веб-сторінок.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Для чого використовуються теги <tr>, <th>, <td>?`,
        descriptions: [
          {
            code: false,
            label: `Для чого використовуються теги <tr>, <th>, <td>?`,
            description: `Теги <tr>, <th>, та <td> використовуються для створення таблиць у HTML.`,
          },
          {
            code: false,
            label: ``,
            description: `• <tr> (Table Row) - тег, який вказує на рядок таблиці. Рядок може містити один або більше <td> або <th> елементів.`,
          },
          {
            code: false,
            label: ``,
            description: `• <th> (Table Header) - тег, який використовується для створення заголовку стовпця або рядка таблиці. Він зазвичай містить текст з пропозицією або описом змісту стовпця.`,
          },
          {
            code: false,
            label: ``,
            description: `• <td> (Table Data) - тег, який використовується для визначення комірки в таблиці. Він містить фактичний зміст даного рядка та стовпця таблиці.`,
          },
          {
            code: false,
            label: ``,
            description: `Кожен рядок таблиці (<tr>) містить один або більше стовпців (<th> або <td>). Стовпці у свою чергу розташовані в межах рядка. Використання цих тегів дозволяє створити таблиці з різним форматуванням, які можуть відображати дані в чіткому та логічному порядку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Розкажіть про meta-тег з name="viewport"?`,
        descriptions: [
          {
            code: false,
            label: `Розкажіть про meta-тег з name="viewport"?`,
            description: `Мета-тег з атрибутом name="viewport" використовується для налаштування масштабування та відображення вмісту веб-сторінки на мобільних пристроях.`,
          },
          {
            code: false,
            label: ``,
            description: `Атрибут content містить наступні властивості:`,
          },
          {
            code: false,
            label: ``,
            description: `• width=device-width: задає ширину вікна перегляду відповідно до ширини пристрою;`,
          },
          {
            code: false,
            label: ``,
            description: `• initial-scale: визначає початковий розмір масштабування сторінки;`,
          },
          {
            code: false,
            label: ``,
            description: `• minimum-scale та maximum-scale: визначають мінімальний та максимальний розмір масштабування відповідно;`,
          },
          {
            code: false,
            label: ``,
            description: `• user-scalable: дозволяє або забороняє масштабування відвідувачами сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `За допомогою цього мета-тега можна забезпечити коректне відображення вмісту сторінки на різних пристроях з різною шириною екрану. Він є важливим для респонсивного дизайну та підтримки мобільних пристроїв.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке елемент <canvas>? І для чого він використовується?`,
        descriptions: [
          {
            code: false,
            label: `Що таке елемент <canvas>? І для чого він використовується?`,
            description: `Елемент <canvas> є одним з новітніх елементів HTML5 і використовується для створення графіки та анімації на веб-сторінках. Він створює прямокутне поле, на якому можна малювати за допомогою JavaScript.`,
          },
          {
            code: false,
            label: ``,
            description: `Для того щоб на елементі <canvas> була зображена графіка, потрібно використовувати API для малювання Canvas. З допомогою методів і властивостей цього API можна малювати лінії, фігури, текст, застосовувати ефекти та інші графічні елементи.`,
          },
          {
            code: false,
            label: ``,
            description: `Основна перевага використання елементу <canvas> полягає в тому, що він дозволяє створювати складні анімації та візуалізації, які не можна досягти звичайними засобами HTML та CSS. Наприклад, можна створювати графіки, діаграми, ігри, анімаційні візуалізації та інші ефекти.`,
          },
          {
            code: false,
            label: ``,
            description: `Приклад використання елементу <canvas>:`,
          },
          {
            code: true,
            label: ``,
            description: `
              <canvas id="myCanvas" width="300" height="200"></canvas>

              <script>
                // отримуємо контекст малювання
                var canvas = document.getElementById("myCanvas");
                var ctx = canvas.getContext("2d");
              
                // малюємо коло
                ctx.beginPath();
                ctx.arc(150, 100, 50, 0, 2*Math.PI);
                ctx.stroke();
              </script>
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі ми створюємо елемент <canvas> з id="myCanvas" та розмірами 300x200 пікселів. Потім за допомогою JavaScript ми отримуємо контекст малювання за допомогою getContext("2d") і малюємо коло на елементі <canvas> за допомогою методів API.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке <svg> і <canvas>?`,
        descriptions: [
          {
            code: false,
            label: `Що таке <svg> і <canvas>?`,
            description: `<svg> та <canvas> - це дві різні технології для візуального представлення графіки у веб-додатках.`,
          },
          {
            code: false,
            label: ``,
            description: `<svg> (Scalable Vector Graphics) - це формат графіки, який використовує векторні об'єкти для зображення різних елементів, таких як лінії, криві, прямокутники, кола, текстові блоки тощо. SVG є вбудованим в HTML5 і дозволяє створювати векторні зображення, які можна масштабувати без втрати якості і розмірів. Цей формат зображення зазвичай використовується для створення іконок, діаграм, карт і різних візуальних ефектів.`,
          },
          {
            code: false,
            label: ``,
            description: `<canvas> - це елемент HTML5, який дозволяє використовувати JavaScript для малювання растрових зображень та графіки на веб-сторінці. Канвас створює зображення з пікселів, які можна маніпулювати з використанням JavaScript. Цей елемент зазвичай використовується для створення складних візуальних ефектів, анімацій, ігор та інших реактивних елементів на сторінці.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, основна відмінність між <svg> та <canvas> полягає в тому, що <svg> використовує векторні об'єкти, тоді як <canvas> створює зображення з пікселів. Обидва елементи можуть використовуватись для створення візуальних ефектів на сторінці, проте в залежності від потреби і типу зображення, можна вибирати той, який найбільше підходить для вашого проекту.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Різниця між <canvas> і <svg>?`,
        descriptions: [
          {
            code: false,
            label: `Різниця між <canvas> і <svg>?`,
            description: `Якщо говорити про графічну рендерингову технологію, то основна різниця між <canvas> та <svg> полягає в тому, що <canvas> базується на растровій графіці, тоді як <svg> заснований на векторній графіці.`,
          },
          {
            code: false,
            label: ``,
            description: `Коли ми малюємо на <canvas>, ми створюємо растрове зображення шляхом малювання на піксельному "холсті" з заданою широтою та висотою. Ми малюємо прості форми, заливаємо їх кольорами та робимо різні операції зображення, використовуючи API для роботи з контекстом.`,
          },
          {
            code: false,
            label: ``,
            description: `З іншого боку, коли ми малюємо на <svg>, ми створюємо векторну графіку, визначаючи геометричні фігури, лінії та криві, що будують зображення. <svg> можна описати як XML-документ, який містить інформацію про фігури, їх розташування, розмір та інші параметри. Оскільки векторні зображення засновані на математичних формулах, вони можуть бути збільшені чи зменшені без втрати якості зображення.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, коли вам потрібно створити анімацію, графіку чи ілюстрацію з деталізованими ефектами, використовуйте <canvas>. А коли вам потрібно створити інтерактивну графіку з векторними формами та текстом, який можна масштабувати, використовуйте <svg>.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Плюси і мінуси <canvas> і <svg>?`,
        descriptions: [
          {
            code: false,
            label: `Плюси і мінуси <canvas> і <svg>?`,
            description: `Якщо порівнювати <canvas> та <svg>, то їх використовують для досягнення різних метою веб-розробки, і кожен з них має свої переваги та недоліки.`,
          },
          {
            code: false,
            label: `Основні переваги <canvas>:`,
            description: `• Для рендерингу зображень на <canvas> використовується JavaScript, що дозволяє створювати більш динамічні та інтерактивні ефекти.`,
          },
          {
            code: false,
            label: ``,
            description: `• <canvas> є кращим вибором, якщо вам потрібно відтворити велику кількість елементів, особливо якщо ці елементи постійно міняються. Він показує відмінну продуктивність при малюванні графіки та анімації.`,
          },
          {
            code: false,
            label: ``,
            description: `• Якщо у вас є потреба малювати багато простих форм, а також робити графічні ефекти, такі як розмиття, масштабування та обрізання, то <canvas> є кращим варіантом.`,
          },
          {
            code: false,
            label: `Основні переваги <svg>:`,
            description: `• Оскільки <svg> є векторним форматом, він ідеально підходить для малювання різних геометричних фігур та іконок, які повинні відображатися на екранах з різними розмірами та роздільною здатністю. Якщо вам потрібно відображати графіку, яка повинна бути розміром від 100% і більше, то <svg> є кращим варіантом.`,
          },
          {
            code: false,
            label: ``,
            description: `• Якщо вам потрібно відтворювати складну векторну графіку або ілюстрації, то <svg> є кращим вибором.`,
          },
          {
            code: false,
            label: ``,
            description: `• Використання <svg> полегшує створення доступної та SEO-оптимізованої графіки.`,
          },
          {
            code: false,
            label: ``,
            description: `Також є деякі недоліки, які можуть бути пов'язані з використанням <canvas> та <svg>. Наприклад, <canvas> не підтримує доступність, тому він не є найкращим варіантом для ств`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Для чого потрібен атрибут autocomplete?`,
        descriptions: [
          {
            code: false,
            label: `Для чого потрібен атрибут autocomplete?`,
            description: `Атрибут autocomplete використовується для вказівки браузеру на автоматичне заповнення полів вводу форми зі збережених користувачем даних. Це може бути корисно для поліпшення зручності введення даних користувачем.`,
          },
          {
            code: false,
            label: ``,
            description: `Значення атрибуту autocomplete може бути on або off. Якщо вказано on, браузер може заповнити поле автоматично, якщо він має збережені дані для цього поля. Якщо значення off, браузер повинен ігнорувати будь-які збережені дані та не заповнювати поле автоматично.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, якщо користувач раніше вводив своє ім'я в полі для вводу з іменем name, браузер може запропонувати це ім'я, коли користувач повертається до цієї сторінки та починає вводити своє ім'я знову. Це зменшує час та зусилля, потрібні для повторного введення даних. Однак, це також може представляти ризик для безпеки даних, тому розглядайте використання цього атрибуту з обережністю.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке елемент <output> у HTML5?`,
        descriptions: [
          {
            code: false,
            label: `Що таке елемент <output> у HTML5?`,
            description: `Елемент <output> є одним з нових елементів HTML5 і призначений для відображення результатів обчислень або інших даних, що генеруються за допомогою JavaScript. Зазвичай його використовують у формах для показу результатів введення користувача.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, якщо користувач заповнив форму з введенням чисел, відобразивши їх у елементі <input>, за допомогою скрипта можна розрахувати суму цих чисел і вивести результат у елементі <output>. Таким чином, елемент <output> дозволяє зручно відображати результати розрахунків без необхідності використовувати додатковий HTML-код.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <output> підтримує атрибут for, який забезпечує зв'язок з іншим елементом форми. Він також підтримує атрибут name, який дозволяє відправляти значення елемента разом з формою.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке властивість valueAsNumber?`,
        descriptions: [
          {
            code: false,
            label: `Що таке властивість valueAsNumber?`,
            description: `Властивість valueAsNumber є однією з властивостей об'єкта <input>. Вона повертає числове значення, введене в поле <input>, якщо тип поля number. Якщо введене значення не може бути перетворено на число, повертається значення NaN.`,
          },
          {
            code: false,
            label: ``,
            description: `Ця властивість особливо корисна, коли потрібно отримати числове значення з поля <input> без необхідності виконувати додаткове перетворення типів даних.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, якщо є поле введення з ID "myNumberInput", можна отримати числове значення, використовуючи наступний код JavaScript:`,
          },
          {
            code: true,
            label: ``,
            description: `
              const myInput = document.getElementById("myNumberInput");
              const numberValue = myInput.valueAsNumber;
            `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке атрибут target? Які значення він приймає?`,
        descriptions: [
          {
            code: false,
            label: `Що таке атрибут target? Які значення він приймає?`,
            description: `Атрибут target використовується для вказівки контексту, в якому повинна бути відкрита цільова сторінка або документ при кліку на посилання. Його можна використовувати для відкриття сторінки в новому вікні браузера, в тому ж вікні, в якому знаходиться посилання, або в іншому фреймі чи iframe.`,
          },
          {
            code: false,
            label: `Атрибут target може приймати такі значення:`,
            description: `• _blank: відкриття сторінки в новому вікні браузера.`,
          },
          {
            code: false,
            label: ``,
            description: `• _self: відкриття сторінки в тому ж вікні, в якому знаходиться посилання (за замовчуванням).`,
          },
          {
            code: false,
            label: ``,
            description: `• _parent: відкриття сторінки в батьківському фреймі або вікні, якщо фрейми використовуються.`,
          },
          {
            code: false,
            label: ``,
            description: `• _top: відкриття сторінки в повному вікні браузера, замінюючи будь-які фрейми, якщо вони використовуються.`,
          },
          {
            code: false,
            label: ``,
            description: `• ім'я фрейму або iframe: відкриття сторінки в вказаному фреймі або iframe.`,
          },
          {
            code: false,
            label: ``,
            description: `Наприклад, <a href="http://example.com" target="_blank">Посилання</a> відкриє сторінку посилання в новому вікні браузера.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Для чого використовується елемент <picture>?`,
        descriptions: [
          {
            code: false,
            label: `Для чого використовується елемент <picture>?`,
            description: `Елемент <picture> використовується для відображення різних зображень в залежності від характеристик екрана та розмірів відображення. Він дозволяє веб-розробникам пропонувати оптимальні зображення для різних пристроїв та розмірів екранів, зменшуючи таким чином завантаження сторінки та збільшуючи швидкість її завантаження.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <picture> містить кілька дочірніх елементів <source> з атрибутами srcset та media, які вказують браузеру наявність декількох варіантів зображення з різними розмірами або різною якістю для вибору найкращого варіанту. Останнім елементом є елемент <img>, що містить адресу зображення, яка буде відображена, якщо жоден з попередніх елементів не вказує на підходяще зображення.`,
          },
          {
            code: false,
            label: ``,
            description: `Для коректної роботи елемента <picture> необхідно додатково використовувати атрибут sizes, що вказує на ширину контейнера, в якому буде відображатися зображення. Також варто дбати про встановлення альтернативного тексту зображення за допомогою атрибута alt в елементі <img>.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Як семантично правильно зверстати навігаційне меню?`,
        descriptions: [
          {
            code: false,
            label: `Як семантично правильно зверстати навігаційне меню?`,
            description: `Навігаційне меню на веб-сайті повинно бути зверстано з використанням семантичних тегів, які відповідають за різні його елементи. Ось декілька рекомендацій щодо семантичного верстування навігаційного меню:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Використовуйте тег <nav> для контейнера навігаційного меню, який зазвичай розміщується у верхній частині сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Використовуйте тег <ul> для створення списку пунктів меню. Кожен пункт меню має бути вкладений у тег <li>. Для підпунктів можна використовувати вкладені списки <ul> і <li>.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Для кожного пункту меню створіть посилання з використанням тега <a>. В атрибуті href зазначте URL-адресу сторінки, на яку потрібно перейти при кліку на пункт меню.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Якщо на сторінці є більше одного навігаційного меню, використовуйте атрибут aria-label для надання унікальної мітки кожному з них.`,
          },
          {
            code: false,
            label: ``,
            description: `5. Застосовуйте стилі до елементів навігаційного меню, використовуючи CSS. Використання класів або ідентифікаторів для кожного пункту меню допоможе зробити CSS-код більш організованим і легким для редагування.`,
          },
          {
            code: false,
            label: ``,
            description: `6. Якщо навігаційне меню повинно бути адаптивним, використовуйте медіа-запити CSS, щоб змінювати розташування і вигляд меню на різних розмірах екрану.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, семантично правильне навігаційне меню повинно бути зверстане з використанням тегів <nav>, <ul>, <li> і <a>, і містити атрибути та мітки, щоб зробити його доступним для користувачів з обмеженими можливостями.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Що таке <iframe>?`,
        descriptions: [
          {
            code: false,
            label: `Що таке <iframe>?`,
            description: `Елемент <iframe> (inline frame) в HTML є контейнером, що дозволяє вбудовувати інший документ HTML в поточний документ. Це означає, що вміст, що відображається в <iframe>, може бути зовнішнім документом, іншою сторінкою в тому ж домені або іншою сторінкою в іншому домені.`,
          },
          {
            code: false,
            label: ``,
            description: `Іншими словами, <iframe> дозволяє вставляти веб-сторінки або вміст, що походить з інших джерел, в поточний документ. Це може бути корисно в таких випадках, як вбудовування карт або відео з інших джерел, відображення інших веб-сторінок в межах поточного документу або вбудовування інтерактивних додатків, таких як вікна чату або калькулятори.`,
          },
          {
            code: false,
            label: ``,
            description: `Для створення <iframe> потрібно вказати посилання на джерело, з якого взяти вміст, за допомогою атрибута src. Також можна налаштувати розміри та інші параметри за допомогою інших атрибутів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Як можна приховати елемент розмітки не використовуючи CSS і JS?`,
        descriptions: [
          {
            code: false,
            label: `Як можна приховати елемент розмітки не використовуючи CSS і JS?`,
            description: `Можна приховати елемент розмітки, встановивши для нього атрибут hidden. Цей атрибут вказує браузеру, що елемент повинен бути прихованим і не повинен відображатися на сторінці. Наприклад:`,
          },
          {
            code: true,
            label: ``,
            description: `
              <p>Цей абзац буде відображений</p>
              <p hidden>Цей абзац буде прихований</p>
            `,
          },
          {
            code: false,
            label: ``,
            description: `Елемент з атрибутом hidden буде забезпечувати контекст для браузера, що допоможе зрозуміти, який контент має бути прихований. Однак, він все ще буде доступний для програмного забезпечення, такого як скрейпери та індексатори пошукових систем.`,
          },
          {
            code: false,
            label: ``,
            description: `Зазвичай кращим підходом є використання CSS або JS для приховання елементів, оскільки це забезпечує більш гнучкий та ефективний спосіб контролювання відображення контенту на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Різниця між <meter> і <progress>?`,
        descriptions: [
          {
            code: false,
            label: `Різниця між <meter> і <progress>?`,
            description: `Елементи <meter> і <progress> використовуються для відображення показників прогресу, але мають дещо різні функції.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <meter> використовується для відображення вимірювань, які мають значення в межах заданого діапазону. Він містить два обов'язкові атрибути: min (мінімальне значення) та max (максимальне значення), а також необов'язковий атрибут value (поточне значення). Також можна використовувати атрибути low, high та optimum для визначення нижньої, верхньої та оптимальної межі значень.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <progress> використовується для відображення поточного стану завантаження чи виконання задачі, яка не має фіксованого діапазону. Він містить обов'язковий атрибут value (поточне значення), а також необов'язковий атрибут max (максимальне значення), який можна використовувати, якщо заздалегідь відомо максимальне можливе значення.`,
          },
          {
            code: false,
            label: ``,
            description: `Отже, різниця між <meter> та <progress> полягає у тому, що <meter> використовується для відображення вимірювань з фіксованим діапазоном, тоді як <progress> використовується для відображення поточного стану завантаження чи виконання задачі, яка не має фіксованого діапазону.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Розкажіть про особливості стилізації <svg>?`,
        descriptions: [
          {
            code: false,
            label: `Розкажіть про особливості стилізації <svg>?`,
            description: `Елемент <svg> - це векторна графіка, яку можна масштабувати без втрати якості. Стилізація <svg> може здійснюватись як за допомогою CSS, так і вбудованими атрибутами SVG.`,
          },
          {
            code: false,
            label: ``,
            description: `Особливості стилізації <svg> залежать від того, як він вбудовується в HTML документ. Якщо <svg> вбудовується як зовнішній файл, то його можна стилізувати за допомогою CSS, використовуючи селектори, аналогічні селекторам HTML. Якщо ж <svg> вбудовується безпосередньо в HTML документ, то його можна стилізувати за допомогою атрибутів SVG.`,
          },
          {
            code: false,
            label: `Основні атрибути SVG для стилізації елементів:`,
            description: `• fill - встановлює фоновий колір елемента;`,
          },
          {
            code: false,
            label: ``,
            description: `• stroke - встановлює колір обводки елемента;`,
          },
          {
            code: false,
            label: ``,
            description: `• stroke-width - встановлює товщину обводки елемента;`,
          },
          {
            code: false,
            label: ``,
            description: `• opacity - встановлює прозорість елемента.`,
          },
          {
            code: false,
            label: ``,
            description: `Крім того, для стилізації <svg> можна використовувати CSS властивості, які не залежать від розмірів екрану, такі як color, background-color, font-size тощо. Також можна використовувати псевдоелементи (::before, ::after) для створення декоративних ефектів.`,
          },
          {
            code: false,
            label: ``,
            description: `У <svg> є декілька особливостей, пов'язаних зі стилізацією тексту. Наприклад, для задання шрифту використовується атрибут font-family, а для задання розміру шрифту - font-size. Також є спеціальний атрибут text-anchor, який визначає точку, до якої буде прив'язано текстовий елемент.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Різниця між кнопкою та посиланням у HTML?`,
        descriptions: [
          {
            code: false,
            label: `Різниця між кнопкою та посиланням у HTML?`,
            description: `У HTML кнопка та посилання - це два різних елементи, які мають різні призначення та можливості.`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <a> (посилання) використовується для створення гіперпосилань на інші веб-сторінки або на окремі елементи в межах тієї ж сторінки. При кліку на посилання користувач переходить на іншу сторінку або переміщується на інший елемент на поточній сторінці. Щоб зробити посилання на кнопку, можна використовувати CSS для задання вигляду посилання (наприклад, задати колір, фон, рамку тощо).`,
          },
          {
            code: false,
            label: ``,
            description: `Елемент <button> (кнопка) використовується для створення кнопок, які використовуються для виконання дій на веб-сторінці, наприклад, відправки форми, виклику функції JavaScript або переходу на іншу сторінку. Кнопки можуть мати текст або іконку, та можуть бути стилізовані за допомогою CSS.`,
          },
          {
            code: false,
            label: ``,
            description: `Основна різниця між кнопкою та посиланням полягає в їх функціональності та призначенні. Посилання використовується для переходу на іншу сторінку або для переміщення на інший елемент на поточній сторінці, тоді як кнопка використовується для виконання дій на веб-сторінці, таких як відправка форми або виклик функції JavaScript.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Чому варто використовувати семантичні теги у верстці?`,
        descriptions: [
          {
            code: false,
            label: `Чому варто використовувати семантичні теги у верстці?`,
            description: `Використання семантичних тегів у верстці допомагає встановити правильну структуру документу і покращує його доступність для користувачів і пошукових систем. Основні причини використання семантичних тегів наступні:`,
          },
          {
            code: false,
            label: ``,
            description: `1. Семантичність. Семантичні теги описують зміст елементів, тобто надають зрозумілу для пошукових систем і людей інформацію про те, що відображено на сторінці.`,
          },
          {
            code: false,
            label: ``,
            description: `2. Краща доступність. Користувачі з обмеженнями можуть використовувати програми, які читають вміст сторінки. Використання семантичних тегів дозволяє створювати документи, які будуть легко зрозумілі для таких програм.`,
          },
          {
            code: false,
            label: ``,
            description: `3. Покращення SEO. Використання семантичних тегів допомагає пошуковим системам краще зрозуміти структуру сторінки і, як наслідок, покращує її позиції в пошукових результатів.`,
          },
          {
            code: false,
            label: ``,
            description: `4. Спрощення розробки. Використання семантичних тегів дозволяє розробникам швидше розуміти структуру документу і спрощує його розробку та обслуговування.`,
          },
          {
            code: false,
            label: ``,
            description: `До семантичних тегів HTML5 належать, наприклад, <header>, <footer>, <nav>, <article>, <section>, <aside>, <main>, <figure>, <figcaption>, <time>, <mark>, <details>, <summary> і багато інших.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: `Для чого використовується тег <label>?`,
        descriptions: [
          {
            code: false,
            label: `Для чого використовується тег <label>?`,
            description: `Тег <label> використовується для зв'язування текстової мітки з елементом форми, наприклад, з елементом <input>, <textarea> або <select>. Це дозволяє користувачам натискати на текст мітки, щоб активувати пов'язаний елемент форми, а не шукати його за допомогою миші чи клавіатури.`,
          },
          {
            code: false,
            label: ``,
            description: `Також використання тегу <label> допомагає збільшити доступність веб-сторінок для користувачів з обмеженими можливостями, такими як використання скрінрідера. Крім того, використання тегу <label> може покращити SEO-оптимізацію веб-сторінок, оскільки пошукові роботи можуть використовувати текст міток для кращого розуміння змісту сторінки.`,
          },
          {
            code: false,
            label: ``,
            description: `Приклад використання тегу <label> для зв'язування мітки з елементом форми:`,
          },
          {
            code: true,
            label: ``,
            description: `
            <label for="username">Ім'я користувача:</label>
            <input type="text" id="username" name="username">            
            `,
          },
          {
            code: false,
            label: ``,
            description: `У цьому прикладі мітка "Ім'я користувача:" пов'язана з елементом форми <input> за допомогою атрибута for, який вказує на ідентифікатор елемента <input>. При натисканні на мітку користувач переходить до поля введення, щоб заповнити його.`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'CSS',
    questions: [
      {
        id: generateUUID(),
        question: 'Що таке CSS? І навіщо він використовується?',
        descriptions: [
          {
            code: false,
            label: 'CSS',
            description: `CSS (Cascading Style Sheets) - це мова опису стилів, яка використовується для оформлення веб-сторінок.`,
          },
          {
            code: false,
            label: '',
            description: `CSS дозволяє відокремлювати опис зовнішнього вигляду веб-сторінки від її HTML-структури та логіки. За допомогою CSS можна задавати кольори, шрифти, розміри, межі, відступи, вирівнювання та інші властивості елементів на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CSS-правило?',
        descriptions: [
          {
            code: false,
            label: 'CSS-правило',
            description: `
CSS-правило (іноді його називають CSS-декларацією) - це основна одиниця стилю в CSS, яка визначає зовнішній вигляд певного елемента на веб-сторінці.`,
          },
          {
            code: false,
            label: '',
            description: `Кожне CSS-правило складається з двох основних частин: селектора та оголошення стилів. Селектор вказує на те, які елементи HTML на сторінці повинні бути стилізовані, а оголошення стилів містить властивості та їх значення, які задають зовнішній вигляд цих елементів.`,
          },
          {
            code: true,
            label: 'Ось приклад CSS-правила:',
            description: `p {
  color: red;
  font-size: 16px;
  font-weight: bold;
}`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Варіанти додавання CSS стилів на сторінку?',
        descriptions: [
          {
            code: false,
            label:
              'Є кілька способів додавання CSS стилів на сторінку веб-сайту:',
            description: `1.Внутрішній CSS: можна включити CSS-стилі безпосередньо в тег head HTML-документу за допомогою тегу style`,
          },
          {
            code: true,
            label: '',
            description: `
<head>
  <style>
    body {
      background-color: #f2f2f2;
    }
  </style>
</head>`,
          },
          {
            code: false,
            label: '',
            description: `2. Зовнішній CSS: CSS можна зберігати у відокремленому файлі з розширенням .css, який повинен бути підключений до HTML-документу за допомогою тегу link`,
          },
          {
            code: true,
            label: '',
            description: `
<head>
  <link rel="stylesheet" type="text/css" href="">
</head>`,
          },
          {
            code: false,
            label: '',
            description: `3. Inline CSS: можна додавати стилі безпосередньо до HTML-елементів за допомогою атрибуту   `,
          },
          {
            code: true,
            label: '',
            description: `
<h1 style="color: blue;">Це заголовок сторінки</h1>
`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Типи позиціонування у CSS?',
        descriptions: [
          {
            code: false,
            label: 'Static',
            description: `Static: це тип позиціонування за замовчуванням для кожного HTML-елемента. Елементи з позиціонуванням Static розміщуються в документі так, як вони повинні бути відображені без будь-якої додаткової обробки.`,
          },
          {
            code: false,
            label: 'Relative',
            description: `Relative: це тип позиціонування, в якому елемент зсувається відносно своєї початкової позиції в залежності від заданого значення властивості top, bottom, left або right. З іншого боку, навіть якщо елемент зсунутий, його місце залишається зарезервованим у потоці документу, тому сусідні елементи не зміщуються.`,
          },
          {
            code: false,
            label: 'Absolute',
            description: `Absolute: це тип позиціонування, в якому елемент відноситься до свого найближчого "пріоритетного" елемента з непорожнім значенням властивості position (може бути родичем або предком). Елемент з позиціонуванням Absolute встановлюється в конкретну позицію на сторінці відносно своїх пріоритетних елементів або відносно вікна браузера, якщо він не має пріоритетних елементів. Це зазвичай використовується для розміщення елементів у плаваючому вікні.`,
          },
          {
            code: false,
            label: 'Fixed',
            description: `Крім цих трьох типів позиціонування, у CSS є ще четвертий тип - Fixed, який працює подібно до Absolute, але елемент розміщується відносно вікна браузера, а не відносно інших елементів. Це корисно для створення елементів, які завжди залишаються на одному місці на сторінці, незалежно від того, як користувач прокручує сторінку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Блокова модель CSS?',
        descriptions: [
          {
            code: false,
            label: 'Блокова модель CSS',
            description: `Блокова модель CSS - це спосіб визначення та обробки розмірів та просторів HTML-елементів в CSS. Вона описує, як браузер визначає розміри та простори елемента на сторінці, включаючи вміст, відступи, рамки та поля.`,
          },
          {
            code: false,
            label: '',
            description: `Загальний принцип блокової моделі полягає у тому, що кожен HTML-елемент може бути представлений як прямокутник, який складається з чотирьох складових:`,
          },
          {
            code: false,
            label: '',
            description: `Контент (content): це вміст елемента, який міститься в середині рамки.
Відступ (padding): це простір між контентом та рамкою.
Рамка (border): це лінія, яка оточує контент та відступ.
Поле (margin): це простір між рамкою та сусідніми елементами.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке селектор? І які селектори є?',
        descriptions: [
          {
            code: false,
            label: 'CSS селектор',
            description: `У CSS, селектор - це патерн, який вказує, які HTML-елементи мають бути вибрані та стилізовані. Селектори дозволяють вибирати один або більше HTML-елементів на сторінці та застосовувати до них один або більше стилів.`,
          },
          {
            code: false,
            label: 'CSS селектор бувають:',
            description: `Селектор елемента: вибирає всі елементи певного типу, наприклад, всі <p> або всі <div>.

Селектор класу: вибирає всі елементи, які мають певний клас, визначений у HTML-коді за допомогою атрибуту class. Селектор класу починається з крапки (.), а за нею слідує назва класу.

Селектор ID: вибирає елемент з певним ID, визначеним у HTML-коді за допомогою атрибуту id. Селектор ID починається з хеш-символу (#), а за ним слідує назва ID.

Селектор дочірнього елемента: вибирає елемент, який є нащадком певного елемента, наприклад, всі <li> елементи, які знаходяться всередині <ul> елемента.

Селектор взаємодії (hover): використовується для визначення стилю, який має бути застосований до елемента, коли на нього наведено курсор.

Селектор атрибута: вибирає всі елементи з певним значенням атрибуту, наприклад, всі елементи з атрибутом href.

Селектор комбінатора: поєднує два або більше селектори, щоб вибрати елементи, які відповідають обом умовам. Наприклад, селектор div p вибирає всі <p> елементи, які знаходяться всередині <div> елемента.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке специфіка селектора? Як рахувати вагу селектора?',
        descriptions: [
          {
            code: false,
            label: 'Що таке специфіка селектора?',
            description: `Специфіка селектора в CSS - це показник того, як сильно впливає селектор на елементи, які він вибирає. Специфіка селектора визначає, який з однакових стилів застосується до елемента, якщо було вказано декілька селекторів, які відповідають йому. Селектор з більшою специфікою має вищий пріоритет.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між Reset.css та Normalize.css?',
        descriptions: [
          {
            code: false,
            label: 'Reset.css',
            description: `Reset.css - це файл стилів, який зазвичай включається в початок CSS файлу і має на меті повністю скинути всі початкові значення CSS стилів для HTML елементів на сторінці. Це дозволяє вам почати з чистого стану, створюючи зовнішній вигляд з нуля. Однак, такі скидання можуть бути дуже радикальними і виникнуть проблеми з сумісністю між браузерами. Зазвичай, при використанні Reset.css потрібно вручну налаштувати всі елементи.`,
          },
          {
            code: false,
            label: 'Normalize.css',
            description: `Normalize.css - це інший файл стилів, який зазвичай включається в початок CSS файлу. Основна ідея Normalize.css полягає в тому, щоб стандартизувати вигляд HTML елементів в різних браузерах, зберігаючи при цьому їх звичайний вигляд. Normalize.css не скидає початкові значення CSS стилів, а замінює їх на більш стандартні значення, які будуть однаковими у всіх браузерах. Це допомагає зменшити проблеми з сумісністю між браузерами та спрощує налаштування стилів.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, відмінність між Reset.css та Normalize.css полягає у тому, що Reset.css скидає всі початкові значення CSS стилів для HTML елементів на сторінці, тоді як Normalize.css стандартизує їх вигляд.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між margin та padding?',
        descriptions: [
          {
            code: false,
            label: 'Margin',
            description: `Margin - це відстань між зовнішнім краєм елемента та іншими елементами на сторінці. Якщо розмір маргіну позитивний, то він збільшить відстань між елементами, якщо від'ємний - то зменшить. Маргін не включається в розмір елемента, тому коли ми встановлюємо маргін, то це впливає тільки на відстань між елементами, а не на їх розмір.`,
          },
          {
            code: false,
            label: 'Padding',
            description: `Padding - це відстань між внутрішнім краєм елемента та його вмістом. Якщо розмір padding позитивний, то він збільшить відстань між вмістом елемента та його рамкою, якщо від'ємний - то зменшить. Padding включається в розмір елемента, тому коли ми встановлюємо padding, то це впливає на розмір елемента.`,
          },
          {
            code: false,
            label: 'Різниця між margin та padding',
            description: `Отже, різниця між margin та padding полягає у тому, що margin визначає відстань між зовнішнім краєм елемента та іншими елементами, тоді як padding визначає відстань між внутрішнім краєм елемента та його вмістом. Також важливо зазначити, що margin не включається в розмір елемента, тоді як padding включається.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між display: none та visibility: hidden?',
        descriptions: [
          {
            code: false,
            label: 'display: none',
            description: `Коли ми встановлюємо display: none, елемент повністю видаляється з потоку документа і стає недоступним для користувача. Це означає, що елемент не займає місце на сторінці, не має висоти та ширини, і не можна взаємодіяти з його вмістом. Якщо елемент має дочірні елементи, вони також будуть приховані.`,
          },
          {
            code: false,
            label: 'visibility: hidden',
            description: `У випадку з visibility: hidden, елемент залишається в потоці документа, і займає той самий обсяг місця, що й до того. Але елемент і його вміст стає невидимим для користувача. Таким чином, хоча елемент не взаємодіє з користувачем, місце на сторінці, яке він займає, все ще резервується.`,
          },
          {
            code: false,
            label: 'Різниця між display: none та visibility: hidden?',
            description: `Отже, головна різниця між display: none та visibility: hidden полягає у тому, що display: none повністю видаляє елемент з потоку документа, в той час як visibility: hidden зберігає місце на сторінці, яке займе елемент.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між блоковим та малим (інлайновим) елементами?',
        descriptions: [
          {
            code: false,
            label: 'Блокові елементи',
            description: `Блокові елементи - це елементи, які займають всю доступну ширину батьківського контейнера, і завжди починаються з нового рядка. Тобто, якщо ми маємо декілька блокових елементів в одному рядку, кожен з них почне новий рядок. За замовчуванням, блокові елементи мають ширину 100%, і можуть мати встановлену висоту, поля (margin) та відступи (padding).`,
          },
          {
            code: false,
            label: 'Інлайнові елементи',
            description: `Інлайнові елементи (малі) - це елементи, які займають тільки той простір, який потрібний для їх вмісту. Вони не починають новий рядок, і можуть знаходитись поруч з іншими елементами в одному рядку. Інлайнові елементи мають ширину та висоту, що відповідає їх вмісту, і не можуть мати встановлені відступи з усіх сторін.`,
          },
          {
            code: false,
            label: 'Різниця між блоковим та малим (інлайновим) елементами',
            description: `Основна різниця між блоковими та інлайновими елементами полягає в тому, як вони взаємодіють з іншими елементами в рядку. Блокові елементи завжди починаються з нового рядка, тоді як інлайнові можуть знаходитись поруч з іншими елементами. Також вони мають різні значення за замовчуванням для ширини, висоти, полів та відступів. Однак, CSS дозволяє змінювати ці значення, тому блокові та інлайнові елементи можуть мати схожий вигляд, якщо вони правильно стилізовані.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Різниця між класом та ідентифікатором у CSS?',
        descriptions: [
          {
            code: false,
            label: 'Ідентифікатор',
            description: `Ідентифікатор (id) - це унікальний ідентифікатор, який призначається для конкретного елемента на сторінці. Він зазвичай використовується для стилізації одного конкретного елемента. Ідентифікатор визначається з символу хеша (#) перед ним. Наприклад, якщо ви хочете стилізувати елемент з id "header", то ви можете використовувати селектор "#header" в CSS.`,
          },{
            code: false,
            label: 'Клас (class)',
            description: `Клас (class) - це набір елементів зі спільною характеристикою, який можна застосовувати до багатьох елементів на сторінці. Клас визначається з символу крапки (.) перед ним. Наприклад, якщо ви хочете стилізувати всі елементи з класом "menu-item", то ви можете використовувати селектор ".menu-item" в CSS.`,
          },{
            code: false,
            label: 'Різниця між класом та ідентифікатором у CSS',
            description: `Основна різниця між ідентифікатором та класом полягає в тому, що ідентифікатор може бути застосований лише до одного елемента, тоді як клас можна застосовувати до декількох елементів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CSS спрайт? І навіщо він використовується?',
        descriptions: [
          {
            code: false,
            label: 'CSS спрайт',
            description: `CSS спрайт (CSS sprite) - це техніка оптимізації веб-сторінок, яка полягає в об'єднанні кількох маленьких зображень в один великий файл зображень і використанні CSS для відображення тільки необхідної частини файлу зображень на сторінці.`,
          }, {
            code: false,
            label: '',
            description: `Використання CSS спрайтів дозволяє зменшити час завантаження сторінки та зменшити кількість запитів до сервера, що покращує швидкість завантаження веб-сторінки та її продуктивність.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке вендорні префікси? І навіщо вони використовуються?',
        descriptions: [
          {
            code: false,
            label: 'Вендорні префікси (vendor prefixes), також відомі як префікси постачальників, це частини CSS-кода, які додаються до властивостей CSS для підтримки відповідних функцій та властивостей у різних браузерах. Кожен браузер може підтримувати різні CSS-функції та властивості на різні способи. Вендорні префікси дозволяють розробникам веб-сайтів використовувати нові функції та властивості CSS, навіть якщо вони не підтримуються всіма браузерами.',
            description: ``,
          },{
            code: false,
            label: '',
            description: `Кожен постачальник браузера має свій вендорний префікс, який додається до назви властивості CSS. Наприклад, для Safari префікс -webkit-, для Firefox -moz-, для Chrome та Opera -webkit- та -o- відповідно. Наприклад, якщо ви хочете використовувати свійтчер (font-feature-settings) у своєму CSS-коді, ви повинні додати наступний код:`,
          },{
            code: true,
            label: 'Приклад коду',
            description: `.selector {
  -webkit-font-feature-settings: "liga";
  -moz-font-feature-settings: "liga";
  font-feature-settings: "liga";
}`,
          },{
            code: false,
            label: '',
            description: `Вендорні префікси дозволяють розробникам веб-сайтів використовувати нові функції та властивості CSS, що не є стандартними і не підтримуються всіма браузерами. Однак, використання вендорних префіксів може призвести до того, що код CSS стає більш складним та збільшує його розмір, що може призвести до погіршення продуктивності та швидкості завантаження веб-сторінки. Тому важливо правильно використовувати вендорні префікси, щоб забезпечити підтримку функцій CSS на різних браузерах та зберегти продуктивність веб-сторінки.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке псевдоелементи? І навіщо вони використовуються?',
        descriptions: [
          {
            code: false,
            label: 'Псевдоелементи ',
            description: `Псевдоелементи (pseudo-elements) - це ключові слова в CSS, які додаються до селекторів для створення ефектів, які не можуть бути створені звичайними селекторами. Вони дозволяють створювати додаткові елементи на сторінці, які можуть бути використані для оформлення контенту.`,
          }, {
            code: false,
            label: '',
            description: `Псевдоелементи в CSS позначаються знаком двокрапки (:), за яким слідує ключове слово, яке описує тип псевдоелементу. Наприклад, псевдоелемент ::before використовується для створення додаткового елемента перед вмістом вибраного елемента, а псевдоелемент ::after - для створення додаткового елемента після вмісту вибраного елемента.`,
          },{
            code: false,
            label: '',
            description: `Основна мета використання псевдоелементів - це створення додаткових елементів на сторінці, щоб оформити контент. `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке схлопування меж (margin collapsing)?',
        descriptions: [
          {
            code: false,
            label: 'margin collapsing',
            description: `Схлопування меж (margin collapsing) - це особливість веб-рендерингу, при якій зовнішні верхні та нижні межі (margin) двох блоків можуть зливатись в одну межу. Таке зливання відбувається, якщо один блок знаходиться внутрішньо в іншому блоку і не має власної межі відступу.`,
          },{
            code: false,
            label: 'margin collapsing',
            description: `Для уникнення проблем зі схлопуванням меж, можна використовувати різні техніки, наприклад, встановлювати внутрішні відступи (padding) замість зовнішніх меж, використовувати спеціальні CSS властивості для контролювання схлопування меж, або використовувати фіксовані розміри для блоків, щоб уникнути зливання меж.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке CSS препроцесор?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `CSS-препроцесор - це інструмент, який дозволяє розробникам писати CSS-код більш ефективно та з більшою організацією. Це різновид мови програмування, який дозволяє додавати до CSS нові функціональність та зручні синтаксис.`,
          },{
            code: false,
            label: '',
            description: `Популярні CSS-препроцесори включають Sass, Less, Stylus та інші.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке z-index? Як формується контекст накладання?',
        descriptions: [
          {
            code: false,
            label: 'z-index',
            description: `z-index - це CSS-властивість, що визначає порядок накладання елементів один на одного в 2D просторі веб-сторінки. Значення z-index може бути додатнім, від'ємним або нульовим.`,
          },{
            code: false,
            label: 'Як формується контекст накладання?',
            description: `Кожен елемент може мати свій власний контекст накладання, який визначається за наступними критеріями:`,
          },{
            code: false,
            label: '',
            description: `• Значення z-index. Елемент з більшим значенням z-index з'являється на вершині.`,
          },{
            code: false,
            label: '',
            description: `• Порядок HTML-розмітки. Останній елемент, що додається до HTML-розмітки, з'являється на вершині.`,
          },{
            code: false,
            label: '',
            description: `• Позиціонування. Елементи, що позиціонуються (наприклад, за допомогою властивості position: absolute), з'являються на вершині над не позиціонованими елементами.`,
          },{
            code: false,
            label: '',
            description: `• Прозорість. Прозорі елементи з'являються під непрозорими елементами.`,
          },{
            code: false,
            label: '',
            description: `• Наслідування. Батьківський контекст накладання наслідується дочірніми елементами.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Порядок накладання елементів у CSS (Stacking Order)?',
        descriptions: [
          {
            code: false,
            label: 'Основні фактори, що визначають порядок накладання елементів, такі:',
            description: ``,
          }, {
            code: false,
            label: '',
            description: `• HTML порядок: елементи, які з'являються в HTML коді пізніше, відображаються поверх тих, які з'являються раніше.`,
          },{
            code: false,
            label: '',
            description: `• Позиціонування: елементи, які позиціонуються з використанням властивостей position: relative, position: absolute або position: fixed, відображаються поверх тих, які не позиціонуються. `,
          },{
            code: false,
            label: '',
            description: `• z-index: це властивість, що визначає, на якому рівні накладання буде розташований елемент. Значення z-index може бути цілим числом або словом, таким як auto, inherit або initial.`,
          },{
            code: false,
            label: '',
            description: `• Контекст накладання: кожен елемент на сторінці має свій власний контекст накладання. Елементи, що мають більш високий контекст накладання, з'являються поверх тих, що мають менший контекст накладання.`,
          },{
            code: false,
            label: '',
            description: `• Прозорість: прозорі елементи з'являються під непрозорими елементами.`,
          },{
            code: false,
            label: '',
            description: `• mix-blend-mode: властивість, яка визначає спосіб змішування кольорів двох елементів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як за допомогою CSS визначити, чи підтримується властивість у браузері?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Використання префіксів браузера. Префікси браузера - це додаткові префікси, які додаються до властивостей, які ще не стали стандартними. Наприклад, якщо ви хочете використовувати властивість "flexbox", яка не підтримується в старіших версіях браузерів, ви можете використовувати наступний код: `,
          },{
            code: true,
            label: '',
            description: `display: -webkit-flex; /* Safari */
             display: flex; /* стандарт */`,
          },{
            code: false,
            label: '',
            description: `Використання @supports. @supports - це CSS-правило, яке дозволяє вам перевірити, чи підтримує браузер певну властивість. Наприклад, якщо ви хочете перевірити, чи підтримує браузер властивість "display: flex", ви можете використовувати наступний код:`,
          },
          {
            code: true,
            label: '',
            description: `@supports (display: flex) {
  /* CSS-правила, які виконуються, якщо браузер підтримує властивість flex */}`,
          },{
            code: false,
            label: '',
            description: `Використання Modernizr. Modernizr - це JavaScript-бібліотека, яка дозволяє перевірити, чи підтримує браузер певні CSS-властивості. Щоб використовувати Modernizr, ви повинні включити бібліотеку на своїй сторінці і додати класи до елементів залежно від того, чи підтримує браузер певну властивість. Наприклад:`,
          },{
            code: true,
            label: '',
            description: `if (Modernizr.flexbox) {
  // Якщо браузер підтримує властивість flexbox
} else {
  // Якщо браузер не підтримує властивість flexbox}`,
          }
        ],
      },
      {
        id: generateUUID(),
        question: 'Як підтримувати сторінки в браузерах з обмеженими функціями?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Прогресивне поліпшення (Progressive Enhancement): цей підхід передбачає розробку веб-сторінки, що спочатку працює без JavaScript та інших розширень, а потім поступово додаються додаткові функції, які поліпшують досвід користувача в тих браузерах, які їх підтримують. Наприклад, для форм входу на сайт можна використовувати HTML5, а для додаткових ефектів інші технології, які не обов'язкові для коректної роботи сторінки.`,
          },{
            code: false,
            label: '',
            description: `Перевірка браузера та перенаправлення користувача: якщо веб-сторінка використовується в обмеженому браузері, то можна перенаправити користувача на іншу сторінку, яка буде спеціально підготовлена для того, щоб працювати на цьому браузері. Наприклад, якщо користувач використовує Internet Explorer версії 8 або старшої, то можна перенаправити його на сторінку з інформацією про те, як оновити браузер, або на спеціальну версію сайту, яка працює на цьому браузері.`,
          },{
            code: false,
            label: '',
            description: `Використання альтернативних технологій: для тих браузерів, які не підтримують певні технології, можна використовувати альтернативні технології. Наприклад, для відео, які не підтримуються старішими версіями браузерів, можна використовувати GIF-анімації або Flash.`,
          },{
            code: false,
            label: '',
            description: `Розумна оптимізація: для того, щоб сайт працював на обмежених браузерах, можна провести розумну оптимізацію, яка зменшить кількість`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Як виправляти специфічні проблеми із стилями для різних браузерів?',
        descriptions: [
          {
            code: false,
            label: 'Існує декілька способів вирішення специфічних проблем із стилями для різних браузерів:',
            description: `Використання префіксів вендора: деякі CSS властивості можуть мати різне синтаксис чи ім'я в різних браузерах. Наприклад, для CSS3-властивостей, таких як border-radius, можна використовувати префікси вендорів (-webkit-, -moz-, -ms-, -o-) для підтримки цих властивостей в різних браузерах.`,
          },{
            code: false,
            label: '',
            description: `Використання поліфілів: поліфіли - це JavaScript скрипти, які додають функціональність, яка не підтримується старішими браузерами. Наприклад, для HTML5-властивостей, таких як <canvas> чи <video>, можна використовувати поліфіли, які надають аналогічну функціональність для старіших браузерів.`,
          },{
            code: false,
            label: '',
            description: `Використання reset-стилів: різні браузери можуть мати різні стилі за замовчуванням, що може призвести до різних відображень на різних браузерах. Використання reset-стилів, таких як Normalize.css, може забезпечити єдиний базовий стиль для всіх елементів і допомогти уникнути проблем із відображенням.`,
          },{
            code: false,
            label: '',
            description: `Тестування на різних браузерах: перед запуском веб-сторінки варто провести тестування на різних браузерах та вирішити проблеми з відображенням та функціоналом на кожному браузері окремо`,
          },{
            code: false,
            label: '',
            description: `Використання альтернативних технологій: у деяких випадках можливо використовувати альтернативні технології, які підтримуються у більшості браузерів. Наприклад, замість використання Flash для відтворення відео можна використовувати HTML5 <video> елементи.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Глобальні ключові слова у CSS?',
        descriptions: [
          {
            code: false,
            label: 'У CSS є декілька глобальних ключових слів, які застосовуються для зміни стилю на рівні сторінки чи на рівні елементів. Ось декілька прикладів:',
            description: `body: стиль, застосований до тіла документа.`,
          },{
            code: false,
            label: '',
            description: `html: стиль, застосований до кореневого елемента сторінки.`,
          },{
            code: false,
            label: '',
            description: `:root: стиль, застосований до кореневого елемента сторінки, який може бути використаний для зміни значень змінних CSS на рівні сторінки.`,
          },{
            code: false,
            label: '',
            description: `*: стиль, застосований до всіх елементів на сторінці.`,
          },{
            code: false,
            label: '',
            description: `:link: стиль, застосований до незвіданих посилань на сторінці.`,
          },{
            code: false,
            label: '',
            description: `:visited: стиль, застосований до відвіданих посилань на сторінці.`,
          },{
            code: false,
            label: '',
            description: `:hover: стиль, застосований до елементів, коли курсор миші наведений на них.`,
          },{
            code: false,
            label: '',
            description: `:active: стиль, застосований до елементів, коли вони активовані, наприклад, коли кнопку натиснено.`,
          },{
            code: false,
            label: '',
            description: `:focus: стиль, застосований до елементів, коли вони отримують фокус від користувача.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке атрибут CSS (attr)?',
        descriptions: [
          {
            code: false,
            label: 'Що таке атрибут CSS (attr)?',
            description: `attr() - це функція CSS, яка дозволяє отримувати значення HTML-атрибутів і використовувати їх для стилізації елементів на сторінці.`,
          },{
            code: false,
            label: '',
            description: `Зазвичай, використовують attr() для динамічного встановлення значень стилів на основі атрибутів елемента, наприклад, коліру фону, ширини, висоти, URL-адреси зображення тощо.`,
          },{
            code: false,
            label: '',
            description: `Отже, замість того, щоб жорстко встановлювати значення властивості в CSS, можна використовувати значення HTML-атрибута.`,
          },{
            code: false,
            label: '',
            description: `Наприклад, якщо ми маємо HTML-елемент <a> з атрибутом data-color:`,
          },{
            code: true,
            label: '',
            description: `<a href="#" data-color="#ff0000">Link</a>`,
          },{
            code: false,
            label: '',
            description: `Тоді ми можемо використовувати attr() в CSS для встановлення кольору фону цього елемента на основі значення атрибута data-color:`,
          },{
            code: true,
            label: '',
            description: `a {
  background-color: attr(data-color);
}
`,
          },{
            code: false,
            label: '',
            description: `Після цього елемент <a> буде мати фоновий колір #ff0000, який був взятий з атрибута data-color.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке перерахування селекторів?',
        descriptions: [
          {
            code: false,
            label: 'Перерахування селекторів',
            description: `Перерахування селекторів - це механізм в CSS, який дозволяє вибирати елементи на основі комбінації декількох селекторів. Це означає, що можна використовувати кілька селекторів разом, щоб змінювати стиль для конкретних елементів на сторінці.`,
          },{
            code: false,
            label: '',
            description: `Перерахування селекторів використовуються для визначення елементів, які мають одну чи більше спільних властивостей, і дозволяють уникнути повторення коду в CSS. Наприклад, ви можете використовувати перерахування селекторів, щоб вибрати всі елементи <p> з червоним текстом і жирним шрифтом, за допомогою такого CSS-коду:`,
          },{
            code: true,
            label: '',
            description: `p.red {
  color: red;
  font-weight: bold;
}
`,
          },{
            code: false,
            label: '',
            description: `У цьому прикладі, p - це селектор елементів, який вибирає всі елементи <p>, а .red - це клас, який вибирає елементи з класом "red". Разом ці селектори визначають всі елементи <p> з класом "red" і змінюють їх стиль.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Для чого використовується ключове слово currentColor у CSS?',
        descriptions: [
          {
            code: false,
            label: 'currentColor',
            description: `Ключове слово currentColor у CSS використовується для визначення колірної властивості елемента як поточного кольору тексту.`,
          },{
            code: false,
            label: '',
            description: `Наприклад, якщо ви маєте текст з червоним кольором і хочете встановити колір рамки для елементу div таким же, як у тексті, то можна використовувати currentColor. Для цього потрібно встановити кольорову властивість рамки як border-color: currentColor;.`,
          },{
            code: false,
            label: 'Нижче показано приклад використання currentColor:',
            description: ``,
          },{
            code: true,
            label: '',
            description: `p {
  color: red;
  border: 1px solid currentColor;
}
`,
          },{
            code: true,
            label: '',
            description: `У цьому прикладі, колір тексту для елементу <p> встановлений на червоний, і колір рамки для цього елементу буде також червоний.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які псевдокласи були додані до CSS3?',
        descriptions: [
          {
            code: false,
            label: 'CSS3 додав багато нових псевдокласів, які розширюють можливості стилізації HTML-документів. Нижче перераховані деякі з них:',
            description: ``,
          },{
            code: false,
            label: '',
            description: `:nth-child(n) - вибирає елементи, які є n-тими дочірніми елементами свого батьківського елемента.`,
          },{
            code: false,
            label: '',
            description: `:nth-of-type(n) - вибирає елементи, які є n-тим елементом свого типу (тобто, якщо в HTML документі є кілька елементів <p>, то :nth-of-type(2) вибере другий елемент <p>).`,
          },{
            code: false,
            label: '',
            description: `:not(selector) - вибирає елементи, які не відповідають заданому селектору.`,
          },{
            code: false,
            label: '',
            description: `:checked - вибирає відмічені елементи (наприклад, радіо-кнопки або прапорці).`,
            },{
              code: false,
              label: '',
              description: `:hover - вибирає елементи, коли на них наведений курсор миші.`,
            },{
              code: false,
              label: '',
              description: `:focus - вибирає елементи, які знаходяться в фокусі.`,
            },{
              code: false,
              label: '',
              description: `:first-child - вибирає перший дочірній елемент батьківського елемента.`,
            },{
              code: false,
              label: '',
              description: `:last-child - вибирає останній дочірній елемент батьківського елемента.`,
            },{
              code: false,
              label: '',
              description: `:nth-last-child(n) - вибирає елементи, які є n-тими дочірніми елементами свого батьківського елемента, рахуючи від кінця.`,
            },{
              code: false,
              label: '',
              description: `:empty - вибирає елементи, які не містять жодного дочірнього елемента або тексту.`,
            },
        ],
      },
      {
        id: generateUUID(),
        question: 'Які фільтри є у CSS?',
        descriptions: [
          {
            code: false,
            label: 'CSS фільтри',
            description: ``,
          },{
            code: false,
            label: '',
            description: `
CSS має низку фільтрів, які можуть бути застосовані до елементів, щоб змінити їх зовнішній вигляд. Ось декілька прикладів фільтрів, які є доступними в CSS:`,
          },{
            code: false,
            label: '',
            description: `brightness() - змінює яскравість зображення.`,
          },{
            code: false,
            label: '',
            description: `contrast() - змінює контрастність зображення.`,
          },{
            code: false,
            label: '',
            description: `grayscale() - перетворює зображення в чорно-біле.`,
          },{
            code: false,
            label: '',
            description: `hue-rotate() - змінює колір зображення, обертаючи його по колу кольорів.`,
          },{
            code: false,
            label: '',
            description: `invert() - інвертує кольори зображення.`,
          },{
            code: false,
            label: '',
            description: `opacity() - змінює прозорість зображення.`,
          },{
            code: false,
            label: '',
            description: `saturate() - змінює насиченість кольорів зображення.`,
          },{
            code: false,
            label: '',
            description: `sepia() - перетворює зображення в сепію.`,
          },{
            code: false,
            label: '',
            description: `Ці фільтри дозволяють змінювати зовнішній вигляд елементів з CSS. Фільтри можна комбінувати, щоб отримати більш складні ефекти. Використання фільтрів може бути корисним для створення більш привабливих та динамічних веб-дизайнів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Навіщо використовується псевдоклас :invalid?',
        descriptions: [
          {
            code: false,
            label: 'Псевдоклас :invalid',
            description: `Псевдоклас :invalid в CSS використовується для стилізації елементів форм, які не пройшли перевірку на коректність введених даних. Наприклад, якщо користувач ввів неправильний формат електронної адреси в полі введення, елемент буде позначено як :invalid.`,
          },{
            code: false,
            label: '',
            description: `За допомогою псевдокласу :invalid можна встановити стилі для таких елементів, які не пройшли валідацію. Наприклад, можна встановити кольорову підсвітку для цих елементів, щоб користувач міг з легкістю знайти та виправити помилки.`,
          },{
            code: false,
            label: '',
            description: `Основне використання :invalid полягає в тому, щоб зробити форми більш дружелюбними та доступними для користувачів, допомагаючи їм зрозуміти, які поля містять помилки, та вказуючи, як їх можна виправити.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про якість display в CSS?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Властивість display в CSS визначає, як елемент повинен бути відображений на сторінці. Вона впливає на візуальне представлення елементів і на їх розташування на сторінці.`,
          },{
            code: false,
            label: 'Основні значення display:',
            description: `block - елемент відображається як блок і займає всю доступну ширину сторінки, починається з нового рядка.`,
          },{
            code: false,
            label: '',
            description: `inline - елемент відображається в тексті і не змінює поточного рядка.`,
          },{
            code: false,
            label: '',
            description: `inline-block - елемент відображається як блок, але залишається в поточному рядку, якщо це можливо.`,
          },{
            code: false,
            label: '',
            description: `flex - елемент відображається як гнучкий контейнер, що дозволяє легко міняти розташування елементів всередині нього.`,
          },{
            code: false,
            label: '',
            description: `grid - елемент відображається як контейнер для роботи з CSS-сіткою, яка дозволяє розміщувати елементи у зручний спосіб.`,
          },{
            code: false,
            label: '',
            description: `table - елемент відображається як HTML-таблиця.`,
          },{
            code: false,
            label: '',
            description: `list-item - елемент відображається як елемент списку.`,
          },{
            code: false,
            label: '',
            description: `inline-table - елемент відображається як HTML-таблиця, але залишається в поточному рядку.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'У якому разі краще використовувати translate() замість абсолютного позиціонування?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `
Використання функції translate() у CSS дозволяє зміщувати елемент на задану відстань від його поточної позиції без зміни потоку документа. Одним із важливих переваг використання translate() є те, що воно не впливає на місцезнаходження і розміри інших елементів на сторінці, тобто воно не зміщує їх.`,
          },{
            code: false,
            label: '',
            description: `З іншого боку, абсолютне позиціонування зміщує елемент відносно його батьківського елемента або відносно вікна браузера. Це може вплинути на позицію і розміри інших елементів на сторінці, оскільки відносини між елементами змінюються.`,
          },{
            code: false,
            label: '',
            description: `Отже, використання translate() краще за абсолютне позиціонування у випадках, коли потрібно змістити елемент на задану відстань без зміни розміщення інших елементів на сторінці. Крім того, translate() може бути корисним для анімації, оскільки воно дозволяє зміщувати елементи в заданому напрямку з різною швидкістю. Однак, у випадках, коли потрібно точно розташувати елемент на сторінці і враховувати його відношення до інших елементів, може бути краще використовувати абсолютне позиціонування.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Що таке плаваючі елементи (floats)? Як вони працюють?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Плаваючі елементи (floats) в CSS - це механізм розміщення блоків на веб-сторінці, який дозволяє розмістити блоки один поруч з іншим, при цьому зміщуючи їх відносно стандартного потоку документа.`,
          },{
            code: false,
            label: '',
            description: `Проте використання плаваючих елементів може мати певні проблеми, особливо з розмірами і місцем розміщення інших елементів. Наприклад, плаваючі елементи можуть зміщуватися, якщо розмір контенту в них змінюється. Також, якщо всі елементи на сторінці будуть плаваючими, це може призвести до непередбачуваних результатів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про властивість text-rendering?',
        descriptions: [
          {
            code: false,
            label: 'text-rendering',
            description: `Властивість text-rendering в CSS визначає, як браузер рендерить текст на екрані. Зазвичай ця властивість використовується для поліпшення зображення тексту на екрані і для досягнення кращої зручності читання.`,
          },{
            code: false,
            label: '',
            description: `Отже, використання властивості text-rendering може бути корисним для покращення якості відображення тексту на екрані і для забезпечення більшої зручності читання.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про властивість text-decoration-skip-ink?',
        descriptions: [
          {
            code: false,
            label: 'text-decoration-skip-ink',
            description: `Задає, як виводити лінію під або над текстом, коли лінія перетинає виносні елементи букв, на кшталт «у», «р», «ц» та ін. Лінія може бути суцільною або перериватися, щоб пропустити «хвостики `,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про властивість pointer-events?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Властивість pointer-events в CSS використовується для визначення, як браузер повинен реагувати на події миші та тачпаду для елементів на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про якість outline?',
        descriptions: [
          {
            code: false,
            label: 'outline',
            description: `У CSS властивість outline використовується для встановлення стилю лінії-контурів (англ. outline) для елементів, які визначаються за допомогою CSS. Це може бути корисно для позначення активного елементу, а також для додавання візуального розділення між елементами на сторінці.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Розкажіть про властивість scrollbar-gutter?',
        descriptions: [
          {
            code: false,
            label: 'scrollbar-gutter',
            description: `Властивість scrollbar-gutter визначає, чи має відображатись прогалина між блоком вмісту та підлоговою панеллю прокрутки (scrollbar). Вона приймає одне з трьох значень:`,
          },{
            code: false,
            label: '',
            description: `auto: це значення за замовчуванням. Прогалина буде відображатись, якщо підлогова панель прокрутки з'являється. Якщо панель прокрутки не з'являється, то прогалина не буде відображатись.`,
          },{
            code: false,
            label: '',
            description: `none: прогалина не буде відображатись ніколи, навіть якщо панель прокрутки з'являється.`,
          },{
            code: false,
            label: '',
            description: `stable: прогалина завжди буде відображатись, незалежно від того, чи з'являється панель прокрутки.`,
          },{
            code: false,
            label: '',
            description: `Ця властивість застосовується до контейнера, який містить підлогову панель прокрутки.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Чому не варто використовувати короткий запис властивостей CSS?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Короткий запис властивостей CSS дозволяє встановлювати значення для кількох властивостей одночасно, що може зменшити кількість коду. Однак, існує кілька причин, чому не варто зловживати цим підходом:`,
          },{
            code: false,
            label: '',
            description: `Збільшення розміру коду: хоча короткий запис зменшує кількість коду для окремих властивостей, він може збільшити загальний розмір CSS-файлу, оскільки він містить всі властивості в одному місці.`,
          },{
            code: false,
            label: '',
            description: `Складність налагодження: коли використовується короткий запис, важче відстежувати властивості і знайти помилки. Також, коли потрібно змінити лише одну властивість, необхідно знайти та відредагувати весь запис.`,
          },{
            code: false,
            label: '',
            description: `Зрозумілість коду: коли короткий запис використовується надмірно, код може стати складним для розуміння, особливо для новачків. Велика кількість скорочень може зробити код менш зрозумілим та менш придатним для підтримки.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Назвіть псевдоелементи для підсвічування тексту?',
        descriptions: [
          {
            code: false,
            label: 'Псевдоелементи для підсвічування тексту',
            description: `::selection - застосовує стилі до тексту, який було виділено користувачем на сторінці.`,
          },{
            code: false,
            label: '',
            description: `::placeholder - застосовує стилі до текстового вмісту плейсхолдера в полях вводу, наприклад, в <input> або <textarea>.`,
          },{
            code: false,
            label: '',
            description: `Обидва псевдоелементи дозволяють змінювати кольори, фон, шрифт тощо для виділеного тексту або тексту в плейсхолдері, що може допомогти зробити сторінку більш естетично привабливою та зручною для користувачів.`,
          },
        ],
      },
      {
        id: generateUUID(),
        question: 'Способи завдання кольору CSS?',
        descriptions: [
          {
            code: false,
            label: 'У CSS існує кілька способів завдання кольору:',
            description: `Назви кольорів: CSS містить список іменованих кольорів, таких як red, blue, green тощо.`,
          },{
            code: false,
            label: '',
            description: `HEX код: HEX-код - це шістнадцяткове число, яке представляє колір. Кожен HEX-код складається з # та 6 цифр, які представляють червоний, зелений та синій кольори (наприклад, #000000 означає чорний колір).`,
          },{
            code: false,
            label: '',
            description: `RGB: RGB - це скорочення від "Red Green Blue". Кожен колір можна описати червоною, зеленою та синьою складовими, де значення можуть бути від 0 до 255 (наприклад, rgb(255, 0, 0) означає червоний колір).`,
          },{
            code: false,
            label: '',
            description: `RGBA: RGBA - це версія RGB, яка дозволяє додавати прозорість до колірів. RGBA має 4 складові, де альфа (opacity) задається числом від 0 до 1 (наприклад, rgba(255, 0, 0, 0.5) означає напівпрозорий червоний колір).`,
          },{
            code: false,
            label: '',
            description: `RGBA: RGBA - це версія RGB, яка дозволяє додавати прозорість до колірів. RGBA має 4 складові, де альфа (opacity) задається числом від 0 до 1 (наприклад, rgba(255, 0, 0, 0.5) означає напівпрозорий червоний колір).`,
          },{
            code: false,
            label: '',
            description: `HSLA: HSLA - це версія HSL, яка дозволяє додавати прозорість до колірів. HSLA має 4 складові, де альфа (opacity) задається числом від 0 до 1 (наприклад, hsla(0, 100%, 50%, 0.5) означає напівпрозорий чистий червоний колір).`,
          },
        ],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Princeples',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'ES5+, JavaScript',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Webpack, Babel',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Configuration project',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'React JS',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Testing',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Metodologies',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: generateUUID(),
    name: 'Practical  part',
    questions: [
      {
        id: generateUUID(),
        question: 'question 1',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 2',
        descriptions: [],
      },
      {
        id: generateUUID(),
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
];
