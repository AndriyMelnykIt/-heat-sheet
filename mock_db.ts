export const modules = [
  {
    id: 1,
    name: 'Internet',
    questions: [
      {
        id: '1_1',
        question: 'What is DNS?',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
      {
        id: '1_2',
        question: 'Прогресивний рендеринг',
        descriptions: [
          {
            code: false,
            label: 'Що таке прогресивний рендеринг?',
            description: 'Прогресивний рендеринг – це назва технологій, що використовуються для прискорення відтворення сторінок (зокрема, для зменшення часу завантаження), щоб показати користувачеві контент якнайшвидше. До того, як широкосмуговий інтернет поширився повсюдно, прогресивний рендеринг зустрічався досить часто.',
          },
        ],
      },
      {
        id: '1_3',
        question: 'Що таке прогресивний SSR?',
        descriptions: [
          {
            code: false,
            label: 'Прогресивний SSR?',
            description: `SSR (Server-Side Rendering) генерує повний HTML для сторінки на сервері у відповідь на запит (перехід по посиланню). Це дозволяє уникнути додаткових запитів даних, наповнення шаблонів на стороні клієнта, оскільки вони обробляються до того, як браузер отримує відповідь.`,
          },
        ],
      },
      {
        id: '1_4',
        question: 'Що таке потік документа?',
        descriptions: [
          {
            code: false,
            label: 'Що таке потік документа?',
            description: `Документний потік - це сукупність розподілених у часі і просторі документів, які рухаються по комунікаційним каналам від створювачів та виробників до користувачів.`,
          },
        ],
      },
      {
        id: '1_5',
        question: 'Різниця між адаптивним (adaptive) та чуйним (responsive) дизайнами?',
        descriptions: [
          {
            code: false,
            label: 'Responsive design',
            description: `За найпростішим визначенням, гнучкий дизайн використовує лише один макет веб-сторінки і «гнучко» змінюється так, щоб краще відповідати екрану користувача, будь то настільний комп’ютер, ноутбук, планшет чи мобільний телефон.
Якщо дивитися з більш технічного боку, то гнучкі веб-сторінки використовують CSS медіазапити та маркери розмірів (breakpoints; далі брейкпоінт) для коригування масштабу зображень, переносу (а також масштабування) тексту та інших елементів.`,
          },
          {
            code: false,
            label: 'Adaptive design',
            description: `Загалом вважається, що адаптивний дизайн — це фіксовані макети, які адаптуються до певних розмірів екрану. Коротко кажучи, у вас є кілька версій веб-сторінки, які відповідають якомусь пристрою, на відміну від однієї, статичної сторінки, яка виглядає однаково і змінює порядок (чи змінює розмір вмісту) на всіх пристроях.В адаптивному дизайні прийнято розробляти UI-макети для 6 найпоширеніших ширин екрану: 320, 480, 760, 960, 1200 і 1600 пікселів`,
          },
        ],
      },
      {
        id: '1_6',
        question: 'Різниця між Progressive Enhancement та Graceful Degradation?',
        descriptions: [
          {
            code: false,
            label: 'Graceful Degradation || Поступова Деградація',
            description: `Поступова деградація—це стратегія розробки, при якій ваш веб-інтерфейс першочергово призначений для перегляду в сучасних браузерах, тоді як в старих браузерах він відображатиметься з обмеженим набором можливостей, але, як мінімум, з базовим функціоналом. Якщо ми говорим про JavaScript, то це означає, що не весь функціонал може бути доступним, в силу відсутності підтримки окремих JS можливостей. Або ж, сайт функціонуватиме і за умови виключеного JS, але лише у базовому режимі. Щодо CSS, за відсутності підтримки тієї чи іншої CSS властивості, сайт функціонуватиме і матиме зрозумілий вигляд, але не такий красивий як у сучасному броузері, що підтримує останні можливості CSS`,
          },
          {
            code: false,
            label: 'Progressive enhancement || Прогресивне покращення',
            description: `Прогресивне покращення дивиться на проблему підтримки старих браузерів з протилежної сторони — розробка веб-інтерфейсу відбувається поетапно, від простого до складного. На кожному з етапів ми отримуємо завершений веб-інтерфейс, що з кожним етапом стає ще кращим, ще зручнішим. В результаті виходить ресурс, що працює у всіх браузерах.`,
          },
          {
            code: false,
            label: 'Основна відміннсть',
            description: `Основна відмінність між цими двома принципами це те, звідки починається розробка. Якщо починати розробку, орієнтуючись на найстаріший браузер зі списку тих, що повинен підтрумувати ваш продукт, а опісля додавати специфічний функціонал для новіших версій, то це — прогресивне покращення. Якщо ж починати створення веб-інтерфейсу під найновіші браузери, а потім просто ховати чи спрощувати деякі функціональності для старіших — це поступова деградація.`,
          },
        ],
      },
      {
        id: '1_7',
        question: 'Що таке кросбраузерність?',
        descriptions: [
          {
            code: false,
            label: 'Кросбраузерність',
            description: `Кросбраузерність сайту — це властивість сайту однаково відображатися та функціонувати у відповідності до поставленого завдання в усіх браузерах. Простіше кажучи, таку характеристику дають сайтам, дизайн яких однаковий як в Internet Explorer, так і в Google Chrome.`,
          },
        ],
      },
      {
        id: '1_8',
        question: 'Babel',
        descriptions: [
          {
            code: false,
            label: 'Що таке Babel? Навіщо він використовується?',
            description: `Babel — можливість писати код «нового стандарту» (з новим функціоналом) не хвилюючись, що цей новий функціонал може не підтримуватись браузерами.`,
          },
          {
            code: false,
            label: 'Що він робить?',
            description: `Babel бере написаний нами код з новим функціоналом та перетворює (транскомпілює) його в аналогічний код, але «старого зразка». Це робиться тому, що саме цей код, код «старого зразка», браузер розуміє без проблем.`,
          },
          {
            code: true,
            label: 'Put in next-gen JavaScript',
            description: `[1,2,3].map(n => n ** 2)`,
          },
          {
            code: true,
            label: 'Get Browser-compatible JavaScript out',
            description: `[1,2,3].map(function (n) {
  return Math.pow(n, 2);
}`,
          },
        ],
      },
      {
        id: '1_9',
        question: 'Різниця між feature detection, feature inference та аналізом рядка user-agent?',
        descriptions: [
          {
            code: false,
            label: 'Feature detection',
            description: `Feature detection - це визначення можливостей браузера чи пристрою, які можуть бути використані у веб-додатках за допомогою коду. Наприклад, перевірка на підтримку HTML5 або CSS3.`,
          },
          {
            code: false,
            label: 'Feature inference',
            description: `Feature inference - це визначення можливостей браузера чи пристрою, які не можуть бути прямо перевірені за допомогою коду. Наприклад, визначення підтримки WebGL на основі підтримки OpenGL.`,
          },
          {
            code: false,
            label: 'User-agent ',
            description: `User-agent string analysis - це аналіз інформації про браузер та операційну систему, яка передається в HTTP-запиті від браузера до веб-сайту. Це може допомогти веб-сайту визначити, як він повинен поводитися для даного користувача. Наприклад, відображення вмісту у форматі мобільного пристрою для мобільного браузера.`,
          },
        ],
      },
      {
        id: '1_10',
        question: 'Що таке Веб-компоненти та які технології в них використовуються?',
        descriptions: [
          {
            code: false,
            label: 'Feature detection',
            description: `Веб-компоненти (Web Components) - це стандартизований набір технологій веб-розробки, що дозволяють створювати перевикористовувані елементи інтерфейсу користувача (UI) зі своїм функціоналом, які можуть використовуватись в різних веб-додатках без необхідності копіювання та вставки коду.
            Веб-компоненти складаються з трьох технологій:
            Custom Elements - дозволяє розробникам створювати свої власні HTML-елементи зі своїми властивостями та методами. За допомогою цієї технології можна створити зручні, перевикористовувані компоненти зі своїм функціоналом.

Shadow DOM - дозволяє розробникам ізолювати стилі та логіку свого компонента від зовнішнього середовища. За допомогою Shadow DOM можна побудувати структуру компонента, яка буде недоступна для змін з зовнішнього коду, тим самим підвищивши безпеку та знизивши імовірність конфліктів між стилями та скриптами.

HTML Templates - дозволяє створювати шаблони HTML-коду, які можуть бути використані для створення нових елементів. Ця технологія дозволяє розробникам використовувати та маніпулювати зі складовими частинами елемента, що збільшує його перевикористовуваність.

Всі ці технології включаються в HTML-сторінку та забезпечують можливість створення веб-компонентів з уніфікованою структурою та поведінкою, що значно полегшує розробку та підтримку веб-додатків.`,
          },
        ],
      },
      {
        id: '1_11',
        question: 'Способи зменшення часу завантаження веб-сторінки?',
        descriptions: [
          {
            code: false,
            label: 'Способи зменшення часу завантаження веб-сторінки',
            description: `Компресія зображень: Зображення часто становлять більше половини завантаженого контенту на сторінці. Використовуючи інструменти для компресії зображень, наприклад, Adobe Photoshop, ImageOptim або TinyPNG, можна зменшити розмір файлу зображення без втрати якості.
Мінімізація коду: Використання засобів, таких як CSS минифікатори та JS компресори, дозволяє зменшити розмір коду сторінки, що зменшує час завантаження.
Кешування: Використання кешування для зберігання тимчасової копії веб-сторінки на стороні клієнта може зменшити кількість запитів на сервер та зменшити час завантаження сторінки для повторних відвідувань.
Комбінування та мінімізація запитів: За допомогою об'єднання декількох файлів CSS та JavaScript в один файл та їх минифікації можна зменшити кількість запитів на сервер та зменшити час завантаження.
Використання CDN: Використання CDN (Content Delivery Network) дозволяє розподілити завантаження ресурсів на кілька серверів, що знаходяться ближче до користувача, що допомагає зменшити час завантаження сторінки.
Видалення зайвого контенту: Видалення зайвого контенту, такого як сторонні скрипти та не використовуваний код, може допомогти зменшити розмір сторінки`,
          },
        ],
      },
      {
        id: '1_12',
        question: 'Особливості розробки мультимовних сайтів?',
        descriptions: [
          {
            code: false,
            label: 'Мультимовний сайт',
            description: `Мультимовний сайт – це вебресурс, адаптований для користувачів, що володіють різними мовами.
            Як реалізувати мультимовність на сайті?
            Різні домени
            Найочевидніший спосіб зробити мультимовність сайту – використовувати різні доменні імена. Наприклад, для України – .ua, для Польщі – .pl, для Чехії – .cz. І так далі.
            За допомогою категорій та папок
            В даному випадку на сайт встановлюється модуль мультимовності, створюються категорії та папки, куди копіюється контент. Подібним чином структура сайту реалізується в рамках одного піддомену, а отже, і вага теж зберігається.
            Параметри
Такий метод вважається спірним, і навіть Google його не рекомендує. Принцип у тому, що дані про мовну та регіональну приналежність вебресурсу передаються через параметр URL. Реалізація мультимовності здійснюється в рамках єдиного домену, але просувати сторінки з параметрами насправді безглуздо.
            `,
          },
        ],
      },
      {
        id: '1_13',
        question: 'Що таке Flash Of Unstyled Content (FOUC)? Як його уникнути?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Flash Of Unstyled Content (FOUC)?',
            description: `Flash Of Unstyled Content (FOUC) - це проблема, коли сторінка завантажується без зовнішніх CSS стилів або з частково завантаженими стилями, що призводить до тимчасового зображення сторінки без стилів, а потім до зображення з правильним виглядом. Це може зіпсувати візуальний досвід користувачів та порушити дизайн сторінки.`,
          },
          {
            code: false,
            label: 'Як його уникнути?',
            description: `Щоб уникнути FOUC, можна використовувати такі підходи, як inline CSS, deferred loading of CSS, або використання preloading CSS. Inline CSS дозволяє браузеру відображати сторінку зі стилями, навіть якщо зовнішні стилі ще не завантажилися. Deferred loading дозволяє браузеру завантажувати стилі пізніше, коли основний зміст сторінки вже завантажено. Preloading CSS дозволяє браузеру завантажувати стилі раніше, ніж вони потрібні для відображення сторінки.`,
          },
        ],
      },
      {
        id: '1_14',
        question: 'Різниця між layout, painting та compositing?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між layout, painting та compositing?',
            description: `
Layout, painting та compositing - це три різні етапи процесу відображення веб-сторінки в браузері. Кожен з цих етапів відповідає за певні аспекти відображення сторінки, і вони відбуваються послідовно один за одним. Ось короткий опис кожного з цих етапів:`,
          },
          {
            code: false,
            label: 'Layout (розміщення)',
            description: `Layout (розміщення): це перший етап відображення сторінки, коли браузер обчислює розміри та позиції кожного елемента на сторінці, враховуючи стиль та структуру HTML. Наприклад, браузер визначає, де повинен бути розміщений блок тексту та якого розміру повинен бути зображення.`,
          },
          {
            code: false,
            label: 'Painting (фарбування)',
            description: `Painting (фарбування): це другий етап відображення, коли браузер використовує розраховану розмітку та стилі для заповнення кольорами та тексту елементів сторінки. Цей етап включає фарбування фонів, текстів, зображень та інших елементів сторінки.`,
          },
          {
            code: false,
            label: 'Compositing (композиція)',
            description: `Compositing (композиція): це останній етап відображення, коли браузер об'єднує зображення та елементи сторінки в один зображення, яке потім відображається на екрані. Цей етап включає об'єднання шарів зображень, що містяться в окремих блоках`,
          },
          {
            code: false,
            label: 'Узагальнення',
            description: `Загалом, layout відповідає за розміщення елементів на сторінці, painting - за їхнє фарбування, а compositing - за об'єднання різних елементів та зображень в одне зображення. Кожен з цих етапів має важливу роль у відображенні веб-сторінок, і збій в будь-якому з них може призвести до проблем з відображенням сторінки в браузері`,
          },
        ],
      },
      {
        id: '1_15',
        question: 'Що таке Progressive Web Application?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Progressive Web Application?',
            description: `Progressive Web Application (PWA) – це додаток, створений за допомогою веб-технологій і є гібридом звичайного веб-сайту, доступ до якого здійснюється через браузер (в тому числі і браузер мобільного додатка). Такі гібридні веб-додатки імітують досвід використання нативних додатків і мають максимально наближений до них зовнішній вигляд і юзабіліті.`,
          },
        ],
      },
      {
        id: '1_16',
        question: 'Що таке міжсайтовий скриптинг (XSS)?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Міжсайтовий скриптинг (Cross-Site Scripting або XSS) - це тип атаки на веб-додатки, який полягає в виконанні зловмисного скрипту в браузері користувача з метою отримання доступу до конфіденційної інформації або контролю над обліковим записом користувача. 

Атака XSS може бути виконана шляхом вставки зловмисного коду у веб-сторінку, яка відображається в браузері користувача. Наприклад, зловмисник може вставити скрипт у поле вводу на веб-сайті, який потім буде відображений іншим користувачам, які зайшли на цей сайт. Якщо користувачі введуть дані в це поле, то зловмисний скрипт може виконатися у їхньому браузері, що може призвести до витоку конфіденційної інформації або виконання дій від імені користувача без його дозволу. 

Для уникнення атак XSS веб-розробники можуть використовувати заходи безпеки, такі як валідація та екранування введених користувачем даних, використання безпечних HTTP кукі, використання Content Security Policy (CSP) та інших технологій. Крім того, користувачі повинні бути обережні при введенні своїх даних на невідомих веб-сайтах та уникати виконання незнайомих скриптів у своєму браузері.`,
          },
        ],
      },
      {
        id: '1_17',
        question: 'Що таке API?',
        descriptions: [
          {
            code: false,
            label: 'Що таке API?',
            description: `API — це посередник між програмами, який задає правила «спілкування». API (Application Programming Interface) — це набір готових класів, процедур, функцій, структур і констант, що надаються додатком (бібліотекою, сервісом) для використання в зовнішніх програмних продуктах (Вікіпедія). Своїми словами, API надає нам можливість використовувати чужі напрацювання в своїх цілях.`,
          },
        ],
      },
      {
        id: '1_18',
        question: 'Що таке CDN?',
        descriptions: [
          {
            code: false,
            label: ' CDN - це ...',
            description: `Мережа доставки вмісту (Content Delivery Network, або CDN) — це сукупність серверів, які доставляють вміст користувачеві.`,
          },
        ],
      },
      {
        id: '1_19',
        question: 'Що таке REST?',
        descriptions: [
          {
            code: false,
            label: 'Що таке REST?',
            description: `REST (скор. англ. Representational State Transfer, «передача репрезентативного стану») — підхід до архітектури мережевих протоколів, які надають доступ до інформаційних ресурсів. Був описаний і популяризований 2000 року Роєм Філдінгом, одним із творців протоколу HTTP.`,
          },
        ],
      },
      {
        id: '1_20',
        question: 'Що таке ip-адреса?',
        descriptions: [
          {
            code: false,
            label: 'Що таке ip-адреса?',
            description: `IP-адреса, адреса Ай-Пі — це ідентифікатор мережевого рівня, який використовується для адресації комп'ютерів чи пристроїв у мережах, які побудовані з використанням стеку протоколів TCP/IP. `,
          },
          {
            code: false,
            label: 'Як виглядає IP-адреса?',
            description: `У версії протоколу IPv4 IP-адреса має довжину 4 байти. В 4-й версії IP-адреса являє собою 32-бітове число. Зручною формою запису IP-адреси (IPv4) є запис у вигляді чотирьох десяткових чисел значенням від 0 до 255, розділених крапками, наприклад: 192.168.0.1. `,
          },
        ],
      },
      {
        id: '1_21',
        question: 'Різниця між host і domain?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між host і domain?',
            description: `Хостинг — це місце, де зберігається сайт , Його файли і база даних. Домен — це ім'я сайту в інтернеті. Для повноцінної роботи сайту потрібен і хостинг, і домен.`,
          },
        ],
      },
      {
        id: '1_22',
        question: 'Що таке URL?',
        descriptions: [
          {
            code: false,
            label: 'Що таке URL?',
            description: `URL означає Уніфікований покажчик інформаційного ресурсу. Це рядок символів, що визначає адресу. Це найпоширеніший спосіб ідентифікації місця розташування ресурсу в World Wide Web (WWW).`,
          },
          {
            code: false,
            label: 'Що таке URI',
            description: `Визначає URI Уніфікований ідентифікатор ресурсу. Це рядок символів, що використовується для ідентифікації ресурсу в Інтернеті або за місцем розташування, або за ім'ям, або за обома.`,
          },
          {
            code: false,
            label: 'Основна відмінність',
            description: `Основна відмінність між URL і URI є те, що URL-адреса дозволяє ідентифікувати веб-ресурс тільки за його розташуванням, а URI дозволяє ідентифікувати веб-ресурс, використовуючи ім'я або місце розташування, або обидва.`,
          },
        ],
      },
      {
        id: '1_23',
        question: 'Чому очищувати кеш важливо? Як це можна зробити?',
        descriptions: [
          {
            code: false,
            label: 'Чому очищувати кеш важливо?',
            description: `Кеш - це тимчасове сховище, де зберігаються дані, які використовуються повторно для швидшого доступу до них. Кеш може містити збережені сторінки веб-сайту, зображення, стилі, скрипти та інші ресурси.`,
          },
          {
            code: false,
            label: 'Як це можна зробити?',
            description: `Використання клавіш Ctrl + Shift + Delete, щоб відкрити вікно очищення кешу у браузері.
У веб-браузері можна вибрати опцію «Очистити кеш» або «Очистити історію» в меню налаштувань.
У деяких браузерах можна використовувати розширення для очищення кешу та інших тимчасових файлів.
У некоторых ОС можна вибрати опцію "Очистити кеш" в меню налаштувань.
Застосування програм для очищення кешу, таких як CCleaner.`,
          },
        ],
      },
      {
        id: '1_24',
        question: 'Назвіть критичні етапи рендерингу?',
        descriptions: [
          {
            code: false,
            label: 'Назвіть критичні етапи рендерингу?',
            description: `Критичний рендеринговий шлях (Critical Rendering Path) - це процес відправки запиту до сервера за HTML, обчислення CSS стилів, обчислення та відображення DOM, обчислення та відображення CSSOM і злиття їх в один документ.
Layout - це процес обчислення положення та розмірів елементів на сторінці.
Painting - це процес перетворення обчисленого вигляду елементів на сторінці в пікселі.
Compositing - це процес складання відображення сторінки з оброблених шарів пікселів.
Усі ці етапи взаємодіють між собою, і якщо хоча б один з них займає дуже багато часу, це може призвести до затримок у відображенні сторінки, зниження продуктивності та погіршення користувацького досвіду. Тому оптимізація критичного рендерингового шляху та всіх цих етапів є важливою задачею для покращення продуктивності веб-сторінок.`,
          },
        ],
      },
      {
        id: '1_25',
        question: 'Що таке Core Web Vitals? Які основні метрики входять туди?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Core Web Vitals? Які основні метрики входять туди?',
            description: `Core Web Vitals - це група основних метрик продуктивності веб-сторінок, які були визначені Google з метою покращення користувацького досвіду в Інтернеті. Ці метрики визначаються на основі того, як швидко сторінка завантажується, реагує на дії користувача та як зручно користуватися нею.

Основні метрики Core Web Vitals включають:

1. Largest Contentful Paint (LCP) - ця метрика вимірює час, який потрібно браузеру для відображення найбільшого контентного елементу на сторінці. Ідеальний час LCP - менше 2,5 секунд.

2. First Input Delay (FID) - ця метрика вимірює затримку між першим взаємодією користувача зі сторінкою (наприклад, кліком на кнопку) та відповіддю сторінки. Ідеальний час FID - менше 100 мс.

3. Cumulative Layout Shift (CLS) - ця метрика вимірює, наскільки динамічно змінюється макет сторінки під час її завантаження. Ідеальний показник CLS - менше 0,1.

Ці метрики вважаються основними, оскільки вони дозволяють оцінити швидкість завантаження сторінки, забезпечити реагування на дії користувача та уникнути змін макету сторінки під час завантаження. Оцінка Core Web Vitals є важливою для SEO, тому що Google використовує їх для розміщення веб-сторінок у пошукових результатах.`,
          },
        ],
      },
      {
        id: '1_26',
        question: 'Розкажіть про метрики Core Web Vitals?',
        descriptions: [
          {
            code: false,
            label: 'Розкажіть про метрики Core Web Vitals?',
            description: `Core Web Vitals - це набір метрик, які вимірюють кількісні показники взаємодії користувача з веб-сторінками, зокрема швидкість, стабільність та якість візуального відображення. Ці метрики були розроблені Google з метою покращення користувацького досвіду та сприяння оптимізації веб-сторінок.`,
          },
        ],
      },
      {
        id: '1_27',
        question: 'Різниця між preload, prefetch, preconnect та prerender?',
        descriptions: [
          {
            code: false,
            label: 'preload',
            description: `Цей метод використовується для попереднього завантаження важливих ресурсів сторінки, таких як шрифти, стилі, скрипти, зображення тощо. Використання цього методу дозволяє покращити швидкість завантаження сторінки, тому що браузер починає завантаження ресурсів ще до того, як вони будуть потрібні для відображення.`,
          },{
            code: false,
            label: 'prefetch',
            description: `Цей метод використовується для попереднього завантаження ресурсів, які будуть потрібні в майбутньому. Наприклад, якщо на сторінці є посилання на іншу сторінку, то можна використовувати prefetch, щоб попередньо завантажити цю сторінку та покращити її швидкість завантаження.`,
          },{
            code: false,
            label: 'preconnect',
            description: `Цей метод використовується для попередньої настройки з'єднання з сервером, який має надавати ресурси, щоб зменшити затримки. Наприклад, якщо на сторінці використовується сторонній шрифт або скрипт, можна використовувати preconnect, щоб підготувати з'єднання з сервером, який надаватиме ці ресурси, ще до того, як вони будуть потрібні.`,
          },{
            code: false,
            label: 'prerender',
            description: `Цей метод використовується для попереднього рендерингу сторінки, що дозволяє покращити її швидкість завантаження.`,
          },
        ],
      },
      {
        id: '1_28',
        question: 'Навіщо потрібен патерн PRPL?',
        descriptions: [
          {
            code: false,
            label: 'Навіщо потрібен патерн PRPL?',
            description: `PRPL (Push, Render, Pre-cache, Lazy-load) - це паттерн проектування, який допомагає забезпечити швидке завантаження веб-сторінок на мобільних пристроях. Він може бути особливо корисним для веб-додатків з великою кількістю коду та ресурсів, які потрібно завантажувати.

Основна ідея PRPL полягає в тому, щоб завантажувати сторінки якомога швидше та ефективніше. Завдяки PRPL можна використовувати попереднє завантаження, передварительне кешування та ліниве завантаження, щоб зменшити час завантаження сторінки та зменшити кількість запитів до сервера.

Патерн PRPL може бути особливо корисним для веб-додатків на мобільних пристроях, оскільки швидкість та ефективність завантаження сторінок на цих пристроях може бути обмеженою. Принцип PRPL допомагає забезпечити оптимальне використання ресурсів та мінімізувати час завантаження сторінок, що поліпшує користувацький досвід та забезпечує більш високу конверсію.`,
          },
        ],
      },
    ],
  },
  {
    id: 2,
    name: 'Web API',
    questions: [
      {
        id: '2_1',
        question: 'Що таке HTTP?',
        descriptions: [
          {
            code: false,
            label: 'Що таке HTTP?',
            description: `HTTP означає "Протокол передачі гіпертексту" (англ. "Hypertext Transfer Protocol"). Це стандартний протокол, який використовується для передачі даних в Інтернеті. В основному він використовується для передачі веб-сторінок з веб-сервера на веб-браузер. HTTP використовується для запитів на отримання ресурсів (таких як HTML-сторінки, зображення, відео) з сервера та для передачі даних від користувача до сервера (наприклад, при заповненні форми на веб-сторінці).`,
          },
          {
            code: false,
            label: '',
            description: `HTTP є протоколом передачі даних в Інтернеті, що базується на клієнт-серверній архітектурі. Клієнт (наприклад, веб-браузер) надсилає запит на сервер, який потім відповідає на запит, передаючи необхідну інформацію клієнту.
              HTTP використовується для передачі різних типів даних, таких як HTML-сторінки, зображення, відео, аудіо, CSS-стилі, JavaScript-скрипти, тощо. Для передачі даних використовуються різні методи, зокрема GET, POST, PUT, DELETE, PATCH, які визначають тип запиту та дії, які необхідно виконати на сервері.
              HTTP має певну структуру запиту та відповіді, яка включає заголовки (headers) та тіло (body) повідомлення. У заголовках вказуються метадані про запит або відповідь, такі як тип даних, розмір, кодування тощо. Тіло повідомлення містить основну інформацію, яка передається в запиті або відповіді.
              У заголовках запиту також можуть бути вказані різні параметри, наприклад, заголовок "User-Agent" містить інформацію про веб-браузер або інший клієнтський програмний продукт, який здійснює запит. Це дозволяє серверу адаптувати відповідь до конкретного клієнта.
              Заголовки також можуть включати інформацію про авторизацію, кешування, кодування, мову тощо. Для забезпечення безпеки передачі даних можуть використовуватися різні методи шифрування, такі як TLS/SSL.`,
          },
        ],
      },
      {
        id: '2_2',
        question: 'З чого будується HTTP-запит?',
        descriptions: [
          {
            code: false,
            label: '',
            description: `HTTP-запит будується з трьох основних частин: рядка запиту (request line), заголовків запиту (request headers) та тіла запиту (request body).`,
          },
          {
            code: false,
            label: '',
            description: `1. Рядок запиту містить метод запиту, шлях до ресурсу та версію протоколу, наприклад:`,
          },
          {
            code: true,
            label: '',
            description: `GET /index.html HTTP/1.1`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод запиту - GET, шлях до ресурсу - /index.html, а версія протоколу - HTTP/1.1.`,
          },
          {
            code: false,
            label: '',
            description: `2. Заголовки запиту містять додаткову інформацію про запит, таку як тип даних, кодування, мову, кешування, авторизацію тощо. Заголовки вказуються після рядка запиту та розділяються переносом рядка. Приклад заголовків запиту:`,
          },
          {
            code: true,
            label: '',
            description: `
            Host: www.example.com
            User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36
            Accept-Language: en-US,en;q=0.9
            `,
          },
          {
            code: false,
            label: '',
            description: `3. Тіло запиту містить додаткові дані, які надсилаються разом з запитом. Наприклад, у випадку відправлення форми на веб-сторінці, тіло запиту міститиме дані, які були введені користувачем. У деяких випадках запит може не містити тіла, тоді ця частина буде відсутня. Якщо тіло запиту присутнє, то воно повинно розділюватись від заголовків порожнім рядком.`,
          },
          {
            code: true,
            label: '',
            description: `
              POST /submit-form.php HTTP/1.1
              Host: www.example.com
              Content-Type: application/x-www-form-urlencoded
              Content-Length: 23
              
              username=johndoe&password=12345
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод запиту - POST, шлях до ресурсу - /submit-form.php, версія протоколу - HTTP/1.1. Заголовки запиту вказують тип даних (application/x-www-form-urlencoded) та розмір тіла запиту (23 байти). Тіло запиту містить дані, введені користувачем на формі (username=johndoe&password=12345).`,
          },
        ],
      },
      {
        id: '2_3',
        question: 'Які методи може мати HTTP-запит?',
        descriptions: [
          {
            code: false,
            label: 'Які методи може мати HTTP-запит?',
            description: `HTTP-протокол має кілька методів запиту, які використовуються для взаємодії з сервером. Основні методи HTTP-запитів:`,
          },
          {
            code: false,
            label: '1. GET - запит на отримання ресурсу за вказаною адресою.',
            description: `Метод GET використовується для запиту ресурсу з сервера. Він не змінює стану сервера і повертає лише дані, які були запитані. Оскільки метод GET не змінює стану сервера, він може бути безпечно кешований.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використовувати метод GET, передавши його як параметр у другому об'єкті параметрів запиту. Як правило, метод GET не має тіла запиту, оскільки дані не надсилаються на сервер. Ось приклад використання методу GET:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource?id=12345', {
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json'
                }
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));            
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод GET для запиту ресурсу з сервера з ідентифікатором "12345". За допомогою параметрів запиту, ми передаємо ідентифікатор у URL-адресі. Заголовок "Content-Type" встановлений на "application/json", але це не є обов'язковим для методу GET, оскільки ми не надсилаємо дані на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `Після виконання запиту сервер повинен повернути відповідь з даними запитаного ресурсу. Інформацію про ресурс можна отримати з об'єкту Response, який повертається з fetch().`,
          },
          {
            code: false,
            label: '2. POST - відправлення даних на сервер для обробки.',
            description: `Метод POST використовується для створення нового ресурсу на сервері або відправки даних на сервер для обробки. У відміну від методу PUT, який оновлює існуючий ресурс, метод POST завжди створює новий ресурс на сервері.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використовувати метод POST, передавши його як параметр у другому об'єкті параметрів запиту. Дані, які необхідно відправити на сервер, повинні бути передані у тілі запиту. Ось приклад використання методу POST:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  name: 'New Resource Name',
                  description: 'New Resource Description'
                })
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод POST для створення нового ресурсу на сервері. Також ми встановлюємо заголовок "Content-Type" на "application/json", щоб вказати, що дані, які ми надсилаємо, є об'єктом JSON. Тіло запиту містить об'єкт з даними нового ресурсу.`,
          },
          {
            code: false,
            label: '',
            description: `Після того, як сервер успішно створить новий ресурс, він повинен повернути відповідь з інформацією про створений ресурс, наприклад, з його ідентифікатором або посиланням на ресурс. Відповідь може бути отримана з об'єкту Response, який повертається з fetch().`,
          },
          {
            code: false,
            label: '3. PUT - оновлення ресурсу на сервері за вказаною адресою.',
            description: `Метод PUT використовується для заміни або оновлення ресурсу на сервері. Він відрізняється від методу POST тим, що він не тільки додає новий ресурс, але також оновлює існуючий ресурс на сервері. Цей метод може бути корисним, коли потрібно змінити деякі дані, які вже є на сервері, але які було надіслано раніше.`,
          },
          {
            code: false,
            label: '',
            description: `У fetch(), ви можете використати метод PUT, передавши його як параметр у другому об'єкті параметрів запиту. Також потрібно передати дані, які потрібно замінити на сервері, у тілі запиту. Ось приклад використання методу PUT:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/api/resource/1', {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  name: 'New Resource Name',
                  description: 'New Resource Description'
                })
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод PUT для заміни даних ресурсу з ідентифікатором "1". Також ми встановлюємо заголовок "Content-Type" на "application/json", щоб вказати, що дані, які ми надсилаємо, є об'єктом JSON. Тіло запиту містить об'єкт з оновленими даними для ресурсу.`,
          },
          {
            code: false,
            label: '',
            description: `Як і в інших методах, сервер повинен повернути відповідь на запит методу PUT, щоб підтвердити, що дані були збережені на сервері.`,
          },
          {
            code: false,
            label: '4. DELETE - видалення ресурсу на сервері за вказаною адресою.',
            description: `Mетод DELETE використовується для видалення ресурсу на сервері. Використовуйте метод fetch() з параметром method: 'DELETE', щоб виконати DELETE-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts/1', {
                method: 'DELETE',
              })
              .then(response => {
                console.log('Resource deleted successfully');
              })
              .catch(error => console.error(error));                    
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо метод DELETE для видалення ресурсу на сервері, за адресою https://example.com/posts/1. У відповідь на запит сервер може повернути статусний код 204 No Content, що означає успішне видалення ресурсу. В нашому випадку ми виводимо повідомлення про успішне видалення ресурсу в консоль. Якщо виникне помилка, ми виводимо повідомлення про помилку в консоль, використовуючи метод console.error().`,
          },
          {
            code: false,
            label: '5. HEAD - запит на отримання заголовків відповіді, але без тіла відповіді.',
            description: `Метод HEAD використовується для отримання заголовків відповіді на запит без тіла відповіді. Він корисний, коли ви хочете отримати лише інформацію про ресурс, таку як тип MIME, без отримання всього вмісту ресурсу. Використовуйте метод fetch() з параметром method: 'HEAD', щоб виконати HEAD-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts/1', {
                method: 'HEAD',
              })
              .then(response => {
                console.log(response.headers.get('Content-Type'));
              })
              .catch(error => console.error(error));
                               
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми відправляємо HEAD-запит на URL https://example.com/posts/1. У відповідь на запит сервер поверне лише заголовки відповіді, але не тіло відповіді. Ми використовуємо метод headers.get('Content-Type') для отримання типу MIME відповіді і виводимо його у консолі. У випадку помилки ми виводимо повідомлення про помилку в консолі, використовуючи метод console.error().`,
          },
          {
            code: false,
            label: '6. OPTIONS - запит на отримання інформації про можливості сервера для обробки запитів.',
            description: `Метод OPTIONS використовується для отримання інформації про можливі методи HTTP, які підтримуються для конкретного ресурсу на сервері. Використовуйте метод fetch() з параметром method: 'OPTIONS', щоб виконати OPTIONS-запит:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com/posts', {
                method: 'OPTIONS',
              })
              .then(response => {
                console.log(response.headers.get('Allow'));
              })
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми відправляємо OPTIONS-запит на URL https://example.com/posts. У відповідь на запит сервер поверне заголовок Allow, який містить перелік методів HTTP, що підтримуються для даного ресурсу на сервері. Ми використовуємо метод headers.get('Allow') для отримання переліку методів і виводимо їх у консолі. У випадку помилки ми виводимо повідомлення про помилку в консолі, використовуючи метод console.error().`,
          },
          {
            code: false,
            label: `7. CONNECT - встановлення мережевого з'єднання з сервером.`,
            description: `Метод CONNECT використовується для встановлення мережевого з'єднання між клієнтом і сервером за допомогою протоколу TLS/SSL. Використовується в основному для забезпечення безпеки і шифрування даних, переданих між клієнтом і сервером. Зазвичай він використовується для з'єднання з проксі-серверами.`,
          },
          {
            code: false,
            label: '',
            description: `Оскільки цей метод використовується переважно для внутрішньої мережевої комунікації, він рідко використовується у клієнтських додатках. Використання методу CONNECT зазвичай приховане від користувача, а з'єднання установлюється автоматично через проксі-сервери.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, в більшості випадків ви не повинні використовувати метод CONNECT у своїх програмах, якщо ви не створюєте програми, пов'язані з безпекою мережі.
              Якщо ви все ж хочете спробувати виконати запит з методом CONNECT у fetch(), ви можете використати код, подібний до наступного:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com', {
                method: 'CONNECT',
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));            
            `,
          },
          {
            code: false,
            label: '',
            description: `Однак, ймовірно, у вас виникнуть проблеми з автентифікацією на сервері, тому я раджу використовувати цей метод тільки в тому випадку, якщо ви знаєте, що він дійсно необхідний у вашому конкретному випадку.`,
          },
          {
            code: false,
            label: '8. TRACE - запит на отримання поверхневої інформації про те, як сервер обробляє запит.',
            description: `Метод TRACE використовується для діагностики мережевих проблем. Він дозволяє клієнту отримати зворотню інформацію від сервера про кожен крок, що відбувається з запитом, відправленим до сервера.`,
          },
          {
            code: false,
            label: '',
            description: `Під час використання методу TRACE, клієнтський запит повторюється на сервері, а сервер відповідає з повідомленням, яке містить всю інформацію про запит. Це може бути корисним для діагностики проблем з мережевим з'єднанням, розуміння того, як сервер обробляє запити та відповідає на них, а також для перевірки того, чи змінювалися дані запиту під час пересилання по мережі.`,
          },
          {
            code: false,
            label: '',
            description: `Якщо ви хочете використати метод TRACE у fetch(), ви можете використати наступний код:`,
          },
          {
            code: true,
            label: '',
            description: `
              fetch('https://example.com', {
                method: 'TRACE',
              })
              .then(response => console.log(response))
              .catch(error => console.error(error));
            `,
          },
          {
            code: false,
            label: '',
            description: `Але, як і в разі методу CONNECT, я раджу використовувати цей метод тільки в діагностичних цілях та якщо ви знаєте, що він дійсно необхідний у вашому конкретному випадку.`,
          },
        ],
      },
      {
        id: '2_4',
        question: 'Що таке HTTP cookie? Для чого їх використовують?',
        descriptions: [
          {
            code: false,
            label: 'Що таке HTTP cookie?',
            description: `HTTP cookie - це невеликий фрагмент даних, який веб-сайт зберігає на комп'ютері користувача. Вони зазвичай використовуються для зберігання інформації про користувача та його перевірці при наступних відвідуваннях веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Коли користувач відвідує веб-сайт, сервер може відправити HTTP-відповідь з заголовком Set-Cookie. Цей заголовок містить інформацію про кукі, який повинен зберігатися на комп'ютері користувача. Коли користувач повертається на веб-сайт, його браузер надсилає HTTP-запит зі всіма кукі, які зберігаються на його комп'ютері. Сервер може використовувати ці кукі для ідентифікації користувача та надання персоналізованого досвіду використання.`,
          },
          {
            code: false,
            label: 'Для чого їх використовують?',
            description: `Кукі використовуються для різних цілей, таких як зберігання налаштувань користувача, ідентифікації користувача, зберігання товарів у кошику покупок та відстеження діяльності користувача на веб-сайті. Наприклад, коли користувач здійснює покупку в інтернет-магазині, його кукі можуть зберігати інформацію про товари в кошику покупок, щоб зберегти вибір користувача після перезавантаження сторінки. Кукі також можуть використовуватися для зберігання інформації про вхід в систему користувача, щоб він не потребував вводити дані вхідної форми при кожному відвідуванні веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Хоча кукі зазвичай не є шкідливими, вони можуть становити ризик для приватності користувача, оскільки вони можуть містити особисту інформацію про користувача.`,
          },
        ],
      },
      {
        id: '2_5',
        question: 'Що таке WebSocket? У чому принцип його роботи?',
        descriptions: [
          {
            code: false,
            label: 'Що таке WebSocket?',
            description: `WebSocket - це технологія, що дозволяє встановлювати двостороннє з'єднання між клієнтом та сервером через один TCP-з'єднання. WebSocket було розроблено з метою зменшення затримок при обміні даними між клієнтом та сервером та для зменшення навантаження на сервер.`,
          },
          {
            code: false,
            label: 'У чому принцип його роботи?',
            description: `Принцип роботи WebSocket полягає в тому, що спочатку клієнт та сервер встановлюють зв'язок через стандартний HTTP-запит. Після цього сервер відповідає з заголовком "Upgrade: WebSocket", який означає, що зв'язок був успішно оновлений до WebSocket.`,
          },
          {
            code: false,
            label: '',
            description: `Після встановлення з'єднання WebSocket клієнт та сервер можуть відправляти додаткові повідомлення один одному без необхідності повторного встановлення з'єднання. Кожне повідомлення має заголовок, що дозволяє ідентифікувати його тип.`,
          },
          {
            code: false,
            label: '',
            description: `WebSocket може бути використаний для багатьох різних завдань, наприклад, для розробки онлайн-ігор, чатів, відео-стрімінгу тощо. В порівнянні з іншими технологіями, WebSocket забезпечує більш ефективний обмін даними між клієнтом та сервером, зменшує навантаження на сервер та забезпечує більш швидку реакцію на події.`,
          },
          {
            code: false,
            label: 'Як встановлюється звязок через HTTP-запит?',
            description: `Зв'язок між клієнтом та сервером зазвичай встановлюється за допомогою стандартного HTTP-запиту типу GET або POST. Клієнт ініціює зв'язок, надсилаючи запит на сервер за певним URL-адресом. Запит містить заголовки, які містять інформацію про запит та можуть включати додаткові параметри.`,
          },
          {
            code: false,
            label: '',
            description: `Сервер, отримавши запит, оброблює його та надсилає відповідь клієнту. Відповідь також містить заголовки, які містять інформацію про відповідь та можуть включати додаткові параметри, такі як кешування або інформація про тип даних, що повертаються.`,
          },
          {
            code: false,
            label: '',
            description: `Якщо під час обробки запиту клієнт та сервер погоджуються використовувати протокол WebSocket, то після відправлення сервером заголовку "Upgrade: WebSocket" з'єднання між клієнтом та сервером переходить у режим WebSocket. З цього моменту клієнт та сервер можуть відправляти повідомлення один одному без необхідності повторного встановлення з'єднання через HTTP-запит.`,
          },
        ],
      },
      {
        id: '2_6',
        question: 'Різниця між HTTP та HTTPS?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між HTTP та HTTPS?',
            description: `Основна різниця між HTTP та HTTPS полягає в тому, що HTTP є протоколом передачі даних через Інтернет у відкритому вигляді, тоді як HTTPS - це захищений протокол передачі даних, який використовує шифрування для забезпечення безпеки даних.`,
          },
          {
            code: false,
            label: '',
            description: `HTTP передає дані відкрито, тому будь-яка інформація, надіслана через HTTP-запит, може бути перехоплена та переглянута ким завгодно. З цієї причини передача конфіденційних даних, таких як логіни та паролі, через HTTP є небезпечною.`,
          },
          {
            code: false,
            label: '',
            description: `HTTPS використовує протокол TLS (Transport Layer Security) або SSL (Secure Sockets Layer), щоб зашифрувати дані, надіслані через Інтернет, що забезпечує більш високий рівень безпеки. Коли веб-браузер отримує відповідь від сервера по HTTPS, то спочатку відбувається процес обміну сертифікатами для підтвердження автентичності сервера, після чого весь трафік між браузером та сервером шифрується.`,
          },
        ],
      },
      {
        id: '2_7',
        question: 'Long-Polling, Websockets та Server-Sent Events',
        descriptions: [
          {
            code: false,
            label: '',
            description: `Long-Polling, Websockets та Server-Sent Events (SSE) є різними підходами до реалізації двостороннього зв'язку між клієнтом та сервером у веб-додатках.`,
          },
          {
            code: false,
            label: 'Long-Polling',
            description: `Long-Polling використовує запити HTTP, але затримує відповідь сервера на певний час. Коли сервер готовий надіслати відповідь, він повертає її клієнту, після чого клієнт відправляє новий запит. Цей процес повторюється багато разів, щоб створити враження миттєвої взаємодії між клієнтом та сервером.`,
          },
          {
            code: false,
            label: 'Websockets',
            description: `Websockets, з іншого боку, створюють постійне двостороннє з'єднання між клієнтом та сервером через протокол WebSocket. Це дозволяє серверу відправляти повідомлення клієнту, коли вони готові, без очікування запитів від клієнта. Це забезпечує швидку і миттєву взаємодію між клієнтом та сервером, а також значно зменшує кількість запитів, необхідних для обміну даними.`,
          },
          {
            code: false,
            label: 'Server-Sent Events (SSE)',
            description: `Server-Sent Events (SSE) також дозволяють серверу відправляти повідомлення клієнту, але вони використовуються лише для відправки даних від сервера до клієнта. Клієнт може підписатися на потік повідомлень від сервера і приймати їх безпосередньо у своєму браузері. SSE часто використовуються для відображення живих оновлень даних, таких як новини, ігрові події, цінові зміни тощо.`,
          },
          {
            code: false,
            label: '',
            description: `Узагальнюючи, Long-Polling є більш простим, але менш ефективним підходом до забезпечення двостороннього зв'язку між клієнтом та сервером, тоді як Websockets та SSE надають більш ефективні та потужні засоби для цього`,
          },
        ],
      },
      {
        id: '2_8',
        question: 'Різниця між PUT- і POST-запитами?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між PUT- і POST-запитами?',
            description: `PUT і POST є двома типами HTTP-запитів, які використовуються для відправки даних на сервер. Основною різницею між ними є те, як вони взаємодіють з ресурсами на сервері.`,
          },
          {
            code: false,
            label: '',
            description: `PUT-запит використовується для зміни існуючих даних на сервері. Цей запит вимагає, щоб вказаний ресурс на сервері був замінений вказаними даними. Якщо ресурс відсутній, то він буде створений.`,
          },
          {
            code: false,
            label: '',
            description: `POST-запит, з іншого боку, використовується для відправки нових даних на сервер. Він використовується, коли потрібно створити новий ресурс на сервері або відправити дані на сервер для подальшої обробки. Крім того, POST-запит може використовуватись для оновлення даних на сервері, якщо це потрібно.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, основна різниця між PUT- і POST-запитами полягає в тому, що PUT-запит використовується для зміни існуючих даних, тоді як POST-запит використовується для відправки нових даних на сервер.`,
          },
        ],
      },
      {
        id: '2_9',
        question: 'Що таке безпечні (Secure) та HttpOnly cookies?',
        descriptions: [
          {
            code: false,
            label: 'Що таке безпечні (Secure) та HttpOnly cookies?',
            description: `Безпечні (Secure) та HttpOnly cookies - це два різні атрибути, які можна встановлювати для HTTP cookies для забезпечення додаткової безпеки.`,
          },
          {
            code: false,
            label: '',
            description: `Атрибут "Secure" вказує на те, що cookie можна використовувати тільки в тому випадку, якщо використовується безпечний протокол зв'язку HTTPS. Якщо веб-сайт використовує HTTPS, то при встановленні cookie встановлюється атрибут "Secure", що дозволяє браузеру передавати cookie тільки через зашифрований канал, а не через незахищені HTTP-запити.`,
          },
          {
            code: false,
            label: '',
            description: `Атрибут "HttpOnly" вказує на те, що cookie не може бути доступний з JavaScript. Це дозволяє захистити cookie від Cross-Site Scripting (XSS) атак, де зловмисник може використовувати JavaScript для отримання доступу до cookie та отримання конфіденційної інформації. Якщо встановлений атрибут "HttpOnly", то веб-програмісти не можуть отримувати доступ до cookie через JavaScript, що дозволяє зменшити ризик XSS-атак.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, використання атрибутів "Secure" та "HttpOnly" є додатковими заходами безпеки для HTTP cookies, які допомагають захистити конфіденційну інформацію користувачів від атак зловмисників.`,
          },
        ],
      },
      {
        id: '2_10',
        question: 'Що таке Content Security Policy (CSP)?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Content Security Policy (CSP)?',
            description: `Content Security Policy (CSP) - це механізм безпеки, що дозволяє зменшити ризик атак на веб-додатки, зокрема на XSS (Cross-Site Scripting) атаки. CSP дає можливість вказати браузеру, які джерела контенту дозволені для завантаження на сторінці, що зменшує можливість виконання зловмисного коду на сторінці в разі, якщо він завантажується з небезпечного джерела.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою CSP можна вказати джерела контенту для різних видів ресурсів, таких як скрипти, стилі, медіа-файли, шрифти, фрейми, AJAX-запити та інші. Також можна налаштувати відправку звіту про спробу завантаження контенту з небезпечних джерел, що дозволяє виявляти та усувати можливі проблеми безпеки.`,
          },
          {
            code: false,
            label: '',
            description: `Приклад вказання CSP на веб-сторінці може виглядати так:`,
          },
          {
            code: true,
            label: '',
            description: `Content-Security-Policy: default-src 'self' https://trusted.com; script-src 'self' 'unsafe-inline' https://trusted.com https://ajax.googleapis.com; style-src 'self' 'unsafe-inline' https://trusted.com; img-src 'self' data: https://trusted.com; font-src 'self' https://fonts.gstatic.com; object-src 'none'; frame-ancestors 'none'; base-uri 'self'; report-uri /csp-report`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми вказуємо, що контент може завантажуватись з поточного джерела ('self'), з довірених джерел (https://trusted.com) для всіх типів контенту, окрім object-src, де ми вказуємо none, щоб заборонити завантаження об'єктів. Крім того, ми вказуємо джерела для кожного типу контенту окремо: для скриптів (script-src) - 'self', 'unsafe-inline', https://trusted.com, https://ajax.googleapis.com; для стилів (style-src) - 'self', 'unsafe-inline', https://trusted.com; для зображень (img-src) - 'self', data:, https://trusted.com. `,
          },
        ],
      },
      {
        id: '2_11',
        question: 'XML',
        descriptions: [
          {
            code: false,
            label: 'XML',
            description: `XML (Extensible Markup Language) - це розширюваний мовний формат, який використовується для зберігання та обміну даними між різними системами. XML є текстовим форматом, що описує дані за допомогою тегів та атрибутів, подібно до HTML. Однак, на відміну від HTML, XML не визначає передбачуваний набір тегів, що дає можливість використовувати його для будь-яких типів даних.`,
          },
          {
            code: false,
            label: '',
            description: `в XML немає заздалегідь визначеного списку тегів, як у HTML. В HTML ви знаєте, що теги, такі як <div>, <p>, <img> і т.д., мають визначене призначення та семантику, і їх застосовують у відповідних випадках. Однак, в XML ви можете створювати власні теги з будь-яким ім'ям і використовувати їх для опису будь-якого типу даних, що дає більшу гнучкість та можливість створення власних мов опису даних. Таким чином, XML набагато більш гнучкий та універсальний, ніж HTML.`,
          },
          {
            code: false,
            label: '',
            description: `XML є стандартом, який можна використовувати у багатьох галузях, включаючи веб-розробку, обробку даних, наукові дослідження, фінанси та багато іншого. XML дозволяє описувати будь-який тип структурованих даних, що робить його потужним інструментом для обміну даними між різними системами та застосунками.`,
          },
        ],
      },
      {
        id: '2_12',
        question: 'AJAX',
        descriptions: [
          {
            code: false,
            label: 'AJAX',
            description: `AJAX (Asynchronous JavaScript and XML) - це технологія, яка дозволяє веб-сторінкам взаємодіяти з сервером без перезавантаження сторінки. Завдяки AJAX можна отримувати та відправляти дані на сервер без необхідності в повній перезагрузці сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `AJAX забезпечує асинхронну взаємодію між веб-сторінкою та сервером за допомогою JavaScript-запитів, що виконуються під час роботи сторінки. Це дозволяє завантажувати частини веб-сторінки без повної перезагрузки, що підвищує її продуктивність та зручність використання.`,
          },
          {
            code: false,
            label: '',
            description: `У сучасних веб-додатках AJAX зазвичай використовується для побудови динамічного інтерфейсу, отримання та відображення даних у режимі реального часу, валідації форм, перевірки доступності служб та багатьох інших сценаріїв.`,
          },
        ],
      },
      {
        id: '2_13',
        question: 'Що таке CORS?',
        descriptions: [
          {
            code: false,
            label: 'CORS',
            description: `CORS (Cross-Origin Resource Sharing) - це механізм безпеки браузера, який дозволяє веб-сторінкам запитувати ресурси з інших доменів і серверів. При цьому, браузер перевіряє, чи дозволяє сервер, з якого запитується ресурс, отримувати запити з домену, з якого робиться запит.`,
          },
          {
            code: false,
            label: '',
            description: `Це зроблено для запобігання зловживанням з боку зловмисників, які можуть використовувати код на стороні клієнта для здійснення атак на інші сайти. За допомогою CORS можна дозволити або заборонити запити з конкретних доменів до веб-сайту.`,
          },
          {
            code: false,
            label: '',
            description: `Для налаштування CORS на сервері зазвичай використовують заголовки HTTP, наприклад, Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers тощо.`,
          },
          {
            code: true,
            label: 'Ось приклад коду, який додає заголовки CORS до відповіді сервера:',
            description: `
              const express = require('express');
              const app = express();
              
              // Додавання заголовків CORS до відповіді сервера
              app.use(function(req, res, next) {
                res.header('Access-Control-Allow-Origin', '*');
                res.header('Access-Control-Allow-Methods', 'GET, PUT, POST, DELETE');
                res.header('Access-Control-Allow-Headers', 'Content-Type');
                next();
              });
              
              // Маршрутизація запитів
              app.get('/', function(req, res) {
                res.send('Привіт з сервера!');
              });
              
              // Запуск сервера
              app.listen(3000, function() {
                console.log('Сервер запущено на порту 3000!');
              });
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому коді ми використовуємо Express.js для створення сервера і додаємо функцію middleware для додавання заголовків CORS до відповіді сервера. Конкретно, ми додаємо заголовок Access-Control-Allow-Origin зі значенням * (дозволяє запити з будь-якого джерела), заголовок Access-Control-Allow-Methods зі значенням дозволених методів (GET, PUT, POST, DELETE) та заголовок Access-Control-Allow-Headers зі значенням дозволених заголовків запиту. Це дозволяє браузеру клієнта виконувати запити до нашого сервера з будь-якого джерела.`,
          },
        ],
      },
      {
        id: '2_14',
        question: 'Різниця між протоколами TCP і UDP?',
        descriptions: [
          {
            code: false,
            label: 'Різниця між протоколами TCP і UDP?',
            description: `TCP (Transmission Control Protocol) і UDP (User Datagram Protocol) - це два основних протоколи мережевого рівня, які використовуються для передачі даних між пристроями в мережі.`,
          },
          {
            code: false,
            label: '',
            description: `Основна різниця між цими протоколами полягає в тому, як вони гарантують доставку даних.`,
          },
          {
            code: false,
            label: '',
            description: `TCP забезпечує забезпечує точну передачу даних, які надходять у вигляді послідовних пакетів. Він використовує механізми підтвердження прийому даних та повторної передачі в разі втрати даних. TCP також контролює потік даних, щоб уникнути перевантаження мережі.`,
          },
          {
            code: false,
            label: '',
            description: `UDP надає меншу гарантію щодо доставки даних, він не передбачає підтвердження прийому даних та повторної передачі в разі втрати даних. Він просто відправляє пакети даних і не контролює їх потік.`,
          },
          {
            code: false,
            label: '',
            description: `Це робить UDP більш швидким за TCP, але менш надійним у тих випадках, коли надійність передачі даних є критично важливою, наприклад, при передачі відео або голосових даних.`,
          },
          {
            code: false,
            label: '',
            description: `Узагалі, TCP використовується для передачі великих обсягів даних, коли точність та надійність передачі даних є важливими, тоді як UDP використовується для швидкої передачі невеликих обсягів даних.`,
          },
        ],
      },
      {
        id: '2_15',
        question: 'Що таке Service Workers?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Service Workers?',
            description: `Service Workers - це скрипти JavaScript, які запускаються в окремому фоновому процесі в браузері і дають можливість розробникам керувати кешуванням, мережевим запитом і поведінкою вашої веб-сторінки під час офлайн взаємодії з користувачем.`,
          },
          {
            code: false,
            label: '',
            description: `Service Workers можуть працювати на задньому плані, незалежно від вашого веб-застосунку, і мають доступ до певного API браузера, який дозволяє їм керувати кешуванням, мережевим запитом і поведінкою вашої веб-сторінки. Вони також можуть використовуватись для реалізації пуш-повідомлень і для покращення швидкості роботи веб-застосунку.`,
          },
          {
            code: false,
            label: '',
            description: `Service Workers працюють в контексті домену, з якого вони були зареєстровані, і вони можуть працювати тільки з HTTPS-з'єднаннями, щоб забезпечити безпеку користувачів. Це означає, що Service Workers можуть бути використані лише на живих веб-сайтах, а не на локальному комп'ютері.`,
          },
          {
            code: false,
            label: '',
            description: `Нижче наведено приклад налаштування Service Worker у ReactJS.`,
          },
          {
            code: true,
            label: '1. Створіть файл serviceWorker.js в корені вашого проекту. У цьому файлі ви можете зареєструвати Service Worker, визначити, які ресурси повинні бути кешовані, і які події повинні бути перехоплені.',
            description: `
            // serviceWorker.js

            const CACHE_NAME = 'my-cache';
            
            self.addEventListener('install', (event) => {
              console.log('Service Worker: Installing....');
              event.waitUntil(
                caches.open(CACHE_NAME)
                  .then((cache) => {
                    console.log('Service Worker: Caching app shell');
                    return cache.addAll([
                      '/',
                      '/index.html',
                      '/static/js/bundle.js',
                      '/static/css/main.css'
                    ]);
                  })
              );
            });
            
            self.addEventListener('fetch', (event) => {
              console.log('Service Worker: Fetching....');
              event.respondWith(
                caches.match(event.request)
                  .then((response) => {
                    if (response) {
                      console.log('Service Worker: Serving from cache');
                      return response;
                    }
                    console.log('Service Worker: Fetching from server');
                    return fetch(event.request);
                  })
              );
            });
            `,
          },
          {
            code: true,
            label: '2. Імпортуйте Service Worker у вашому компоненті index.js.',
            description: `
            // index.js

            import React from 'react';
            import ReactDOM from 'react-dom';
            import App from './App';
            import * as serviceWorker from './serviceWorker';
            
            ReactDOM.render(<App />, document.getElementById('root'));
            
            serviceWorker.register();
            
            `,
          },
          {
            code: true,
            label: '3. Додайте файл manifest.json у корінь вашого проекту. У цьому файлі ви можете визначити метадані про ваше додаток, такі як іконка, назва та короткий опис.',
            description: `
            // manifest.json

            {
              "name": "My App",
              "short_name": "My App",
              "icons": [
                {
                  "src": "icon.png",
                  "sizes": "192x192",
                  "type": "image/png"
                },
                {
                  "src": "icon-512.png",
                  "sizes": "512x512",
                  "type": "image/png"
                }
              ],
              "start_url": ".",
              "display": "standalone",
              "theme_color": "#000000",
              "background_color": "#ffffff"
            }

            `,
          },
          {
            code: true,
            label: '4. Додайте посилання на ваш файл маніфесту у вашому HTML-файлі.',
            description: `
            <!-- index.html -->

            <head>
              <meta charset="utf-8" />
              <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
              <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
              <title>My App</title>
            </head>

            <body>
              <div id="root"></div>
            </body>

            `,
          },
          {
            code: false,
            label: '',
            description: `Тепер ваш React додаток буде мати можливість працювати офлайн завдяки Service Workers.`,
          },
        ],
      },
      {
        id: '2_16',
        question: 'Що таке Web Worklet?',
        descriptions: [
          {
            code: false,
            label: 'Що таке Web Worklet?',
            description: `Web Worklet - це механізм браузера, що дозволяє виконувати скрипти на ізольованому потоці виконання. Це дозволяє відокремити код від основного потоку виконання і запобігти блокуванню інтерфейсу користувача під час виконання важких обчислень.`,
          },
          {
            code: false,
            label: '',
            description: `Web Worklet був запропонований як альтернатива Web Workers, що відкриває шлях для більш широкого спектру використання. Web Worklet може виконувати код, який взаємодіє зі сторонніми сервісами, відображає візуальні компоненти та інші задачі, які не можна виконувати в Web Workers.`,
          },
          {
            code: false,
            label: '',
            description: `Web Worklet використовує технологію WebAssembly, яка дозволяє виконувати код на мовах програмування, які не підтримуються браузером напряму. Це робить Web Worklet більш гнучким і можливою альтернативою Web Workers для виконання важких завдань в браузері.`,
          },
        ],
      },
      {
        id: '2_17',
        question: 'Що таке History API в браузері?',
        descriptions: [
          {
            code: false,
            label: 'Що таке History API в браузері?',
            description: `History API - це частина JavaScript-інтерфейсу браузера, яка дозволяє змінювати URL в адресній стрічці без перезавантаження сторінки та зберігати записи про історію переходів на сторінках в браузері. За допомогою History API можна змінювати URL без перезавантаження сторінки, отримувати інформацію про поточний URL та історію переходів на сторінках.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, для того, щоб додати запис в історію переходів на сторінках, можна використати метод pushState і передати йому об'єкт з потрібними даними, як показано у прикладі:`,
          },
          {
            code: true,
            label: '',
            description: `history.pushState({page: 2}, "Назва сторінки", "/сторінка-2");`,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі метод pushState додає запис про новий URL "/сторінка-2" з назвою "Назва сторінки" та об'єктом даних {page: 2} до історії переходів на сторінках в браузері. При цьому сторінка не перезавантажується, а URL змінюється на новий. Для зчитування поточного URL можна використати властивість location.href, а для отримання даних про запис в історії переходів на сторінках - методи history.back() та history.forward().`,
          },
        ],
      },
      {
        id: '2_18',
        question: 'що таке веб-сховище (web storage)?',
        descriptions: [
          {
            code: false,
            label: 'що таке веб-сховище (web storage)?',
            description: `Веб-сховище (web storage) - це механізм зберігання даних на стороні клієнта веб-додатків. Цей механізм дозволяє зберігати дані в локальному сховищі браузера без потреби взаємодії з сервером. Збережені дані доступні для веб-додатків, які вони створені для, і можуть бути використані для різних цілей, таких як збереження налаштувань користувачів, запам'ятовування даних форми, аутентифікації користувача та інших задач.`,
          },
          {
            code: false,
            label: '',
            description: `У веб-сховищі два типи об'єктів для зберігання даних: localStorage та sessionStorage. localStorage зберігає дані, які будуть доступні після закриття браузера, а sessionStorage зберігає дані, які будуть доступні лише в рамках одного сеансу браузера (тобто, поки користувач не закриє вкладку з веб-сайтом). Доступ до даних можна отримати за допомогою JavaScript API. Наприклад, для збереження даних у localStorage використовується такий синтаксис:`,
          },
          {
            code: true,
            label: '',
            description: `localStorage.setItem('ключ', 'значення');`,
          },
          {
            code: false,
            label: '',
            description: `А для отримання значення з localStorage:`,
          },
          {
            code: true,
            label: '',
            description: `const value = localStorage.getItem('ключ');`,
          },
          {
            code: false,
            label: '',
            description: `Дані можна видалити з localStorage за допомогою методу removeItem():`,
          },
          {
            code: true,
            label: '',
            description: `localStorage.removeItem('ключ');`,
          },
        ],
      },
      {
        id: '2_19',
        question: 'Що таке sessionStorage?',
        descriptions: [
          {
            code: false,
            label: 'Що таке sessionStorage?',
            description: `sessionStorage - це інтерфейс Web Storage, який зберігає дані в браузері на протязі однієї сесії, яка зберігається між сторінками. Коли користувач закриває вкладку браузера або перезавантажує сторінку, дані знищуються.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою sessionStorage можна зберігати прості рядкові значення, що використовуються в додатку для зберігання даних в проміжку між сторінками. Значення можна отримати за ключем або встановити нове значення за ключем, який буде збережено в поточній сесії.`,
          },
          {
            code: false,
            label: '',
            description: `Наприклад, можна зберігати обраний елемент у формі, щоб він залишався вибраним при оновленні сторінки. Нижче наведено приклад встановлення і отримання значення за допомогою sessionStorage в JavaScript:`,
          },
          {
            code: true,
            label: '',
            description: `
              // встановлюємо значення для ключа "username"
              sessionStorage.setItem("username", "John");

              // отримуємо значення для ключа "username"
              const username = sessionStorage.getItem("username");
              console.log(username); // виведе "John"
            `,
          },
          {
            code: false,
            label: '',
            description: `Значення, збережені у sessionStorage, будуть доступні на всіх сторінках в поточній сесії, але не будуть доступні на інших вкладках або після закриття браузера.`,
          },
        ],
      },
      {
        id: '2_20',
        question: 'Що таке BOM?',
        descriptions: [
          {
            code: false,
            label: 'Що таке BOM?',
            description: `BOM означає «Browser Object Model» (Об'єктна модель браузера) і є частиною API браузера. Це колекція об'єктів, що відображають властивості та функції браузера, які можуть використовуватися для маніпулювання вмістом веб-сторінки.`,
          },
          {
            code: false,
            label: '',
            description: `До BOM належать такі об'єкти, як window, navigator, location, history, screen та інші. Ці об'єкти надають розробникам можливість отримувати доступ до різних функціональних можливостей браузера, таких як взаємодія з користувачем, навігація, робота з документами та інше. Наприклад, властивість window.location надає доступ до поточної адреси URL сторінки, а window.alert() викликає діалогове вікно з повідомленням для користувача.`,
          },
          {
            code: false,
            label: '',
            description: `За допомогою BOM можна маніпулювати не тільки веб-сторінками, а й самим браузером, таким чином, щоб змінювати розміри та положення вікна браузера, відкривати та закривати нові вкладки тощо. Однак, слід пам'ятати, що використання BOM може стати причиною проблем з кросбраузерною сумісністю, тому розробники повинні звертати на це увагу.`,
          },
        ],
      },
      {
        id: '2_21',
        question: 'Різниця між cookie, sessionStorage та localStorage?',
        descriptions: [
          {
            code: false,
            label: 'cookie, sessionStorage та localStorage',
            description: `У веб-розробці є декілька способів зберігання даних в браузері, серед яких cookie, sessionStorage та localStorage. Ось їхні основні відмінності:`,
          },
          {
            code: false,
            label: '',
            description: `1. Cookie - це невеликі текстові файли, які зберігаються в браузері користувача. Вони зазвичай використовуються для зберігання інформації про користувача або його налаштування, які можуть бути використані на інших сторінках сайту. Куки можуть бути встановлені з сервера або з JavaScript на стороні клієнта.`,
          },
          {
            code: false,
            label: '',
            description: `2. sessionStorage - це механізм зберігання даних в браузері, який дозволяє зберігати дані протягом одного сеансу роботи з сайтом. Дані, збережені у sessionStorage, зникають після закриття вкладки або браузера.`,
          },
          {
            code: false,
            label: '',
            description: `3. localStorage - це механізм зберігання даних в браузері, який дозволяє зберігати дані назавжди або до тих пір, поки користувач не видалить їх вручну або не очистить кеш браузера.`,
          },
          {
            code: false,
            label: '',
            description: `Отже, основна відмінність між цими трьома механізмами зберігання даних полягає в тривалості збереження. Cookie - це найменш потужний з них, оскільки він зберігається тільки на короткий проміжок часу. sessionStorage дозволяє зберігати дані протягом одного сеансу роботи з сайтом, тоді як localStorage дозволяє зберігати дані на невизначений термін.`,
          },
        ],
      },
      {
        id: '2_22',
        question: 'Що таке REST та RESTful api?',
        descriptions: [
          {
            code: false,
            label: 'REST та RESTful api',
            description: `REST (Representational State Transfer) - це архітектурний стиль для створення мережевих протоколів. RESTful API - це API, яке дотримується принципів REST.`,
          },
          {
            code: false,
            label: '',
            description: `REST побудований на основі HTTP і складається з наступних принципів:`,
          },
          {
            code: false,
            label: '',
            description: `• Кожен ресурс (наприклад, користувач, коментар, замовлення) ідентифікується унікальним URI (Uniform Resource Identifier).`,
          },
          {
            code: false,
            label: '',
            description: `• Клієнт взаємодіє з сервером за допомогою стандартних HTTP-запитів, таких як GET, POST, PUT і DELETE, що відповідають CRUD-операціям (створення, читання, оновлення та видалення).`,
          },
          {
            code: false,
            label: '',
            description: `• Кожен запит містить всю необхідну інформацію для обробки запиту (stateless). Сервер не зберігає стан клієнта між запитами.`,
          },
          {
            code: false,
            label: '',
            description: `• Відповідь сервера повинна бути чіткою і включати в себе достатню інформацію про ресурс, який запитується.`,
          },
          {
            code: false,
            label: '',
            description: `RESTful API повинен дотримуватися цих принципів, а також надати легку для розуміння документацію та демонстраційні приклади взаємодії з API. Взаємодія з RESTful API повинна бути безпечною, ефективною і масштабованою.`,
          },
          {
            code: false,
            label: '',
            description: `Основним способом використання RESTful API в React є використання функцій fetch() або бібліотеки, як от Axios чи jQuery AJAX. Ось приклад використання fetch():`,
          },
          {
            code: true,
            label: '',
            description: `
            import React, { useState, useEffect } from 'react';

            function Example() {
              const [data, setData] = useState(null);
            
              useEffect(() => {
                async function fetchData() {
                  const response = await fetch('/api/data');
                  const jsonData = await response.json();
                  setData(jsonData);
                }
            
                fetchData();
              }, []);
            
              if (!data) {
                return <div>Loading...</div>;
              }
            
              return (
                <div>
                  <h1>{data.title}</h1>
                  <p>{data.description}</p>
                </div>
              );
            }            
            `,
          },
          {
            code: false,
            label: '',
            description: `У цьому прикладі ми використовуємо функцію fetch() для отримання даних з нашого RESTful API, яке відповідає на запит на /api/data. Після того, як ми отримаємо відповідь, ми перетворюємо її на об'єкт JSON і встановлюємо його як стан компонента за допомогою setData(). Якщо дані ще не завантажилися, ми виводимо повідомлення "Loading...". Якщо ж дані вже отримано, ми відображаємо їх у відповідних елементах.`,
          },
          {
            code: false,
            label: '',
            description: `Це дуже простий приклад, але можна використовувати різні методи HTTP-запитів (GET, POST, PUT, DELETE) для виконання операцій з базою даних. Також можна використовувати параметри запиту, щоб фільтрувати або сортувати дані перед їхнім отриманням.`,
          },
        ],
      },
      {
        id: '2_23',
        question: 'Що таке Triple handshake?',
        descriptions: [
          {
            code: false,
            label: 'REST та RESTful api',
            description: `Triple handshake - це процес установки з'єднання в протоколі TCP, який передбачає взаємодію клієнта і сервера у трьох етапах.`,
          },
          {
            code: false,
            label: '',
            description: `При встановленні з'єднання клієнт надсилає запит на підключення до сервера, відправляючи пакет з установлюючим флагом (SYN). Сервер отримує запит і відповідає на нього пакетом з флагами SYN та ACK. Клієнт в свою чергу надсилає підтвердження ACK.`,
          },
          {
            code: false,
            label: '',
            description: `Triple handshake відрізняється від двостороннього handshake, де після відправлення запиту на підключення клієнт чекає відповіді від сервера і надсилає підтвердження ACK разом з першими даними, що надсилає на сервер.`,
          },
          {
            code: false,
            label: '',
            description: `riple handshake використовується для забезпечення стабільності з'єднання, оскільки перед відправкою даних клієнт та сервер перевіряють, чи є з'єднання доступним для передачі даних.`,
          },
        ],
      },
    ],
  },
  // {
  //   id: 2,
  //   name: 'Git',
  //   questions: [
  //     {
  //       id: '2_1',
  //       question: 'question 1',
  //       descriptions: [
  //         {
  //           code: false,
  //           label: 'What is DNS?',
  //           description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
  //           Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
  //         },
  //         {
  //           code: false,
  //           label: 'How does DNS work?',
  //           description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
  //           In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
  //         },
  //         {
  //           code: true,
  //           label: 'Code',
  //           description: `
  //             import { useEffect, useState } from 'react';
  //             import { Module, Question } from '../interfaces';
              
  //             const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
  //               const [result, setResult] = useState<Module | Question | null>(null);
              
  //               const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
  //                   for (let i = 0; i < array.length; i++) {
  //                     const obj = array[i];
  //                     if ("questions" in obj) {
  //                       const moduleObj = obj as Module;
  //                       getObjectById(moduleObj.questions, idForSearch);
  //                     }
  //                     if (obj.id === idForSearch) {
  //                       setResult(obj as Module | Question);
  //                       break;
  //                     }
  //                   }
  //                 }
              
  //               useEffect(() => {
  //                 getObjectById(array, id);
  //               }, [array, id]);
              
  //               return result;
  //             };
              
  //             export default useGetObjectById;
  //           `,
  //         },
  //       ],
  //     },
  //     {
  //       id: '2_2',
  //       question: 'question 2',
  //       descriptions: [
  //         {
  //           code: false,
  //           label: 'What is DNS?',
  //           description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
  //           Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
  //         },
  //         {
  //           code: false,
  //           label: 'How does DNS work?',
  //           description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
  //           In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
  //         },
  //         {
  //           code: true,
  //           label: 'Code',
  //           description: `
  //             import { useEffect, useState } from 'react';
  //             import { Module, Question } from '../interfaces';
              
  //             const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
  //               const [result, setResult] = useState<Module | Question | null>(null);
              
  //               const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
  //                   for (let i = 0; i < array.length; i++) {
  //                     const obj = array[i];
  //                     if ("questions" in obj) {
  //                       const moduleObj = obj as Module;
  //                       getObjectById(moduleObj.questions, idForSearch);
  //                     }
  //                     if (obj.id === idForSearch) {
  //                       setResult(obj as Module | Question);
  //                       break;
  //                     }
  //                   }
  //                 }
              
  //               useEffect(() => {
  //                 getObjectById(array, id);
  //               }, [array, id]);
              
  //               return result;
  //             };
              
  //             export default useGetObjectById;
  //           `,
  //         },
  //       ],
  //     },
  //     {
  //       id: '2_3',
  //       question: 'question 3',
  //       descriptions: [
  //         {
  //           code: false,
  //           label: 'What is DNS?',
  //           description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
  //           Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
  //         },
  //         {
  //           code: false,
  //           label: 'How does DNS work?',
  //           description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
  //           In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
  //         },
  //         {
  //           code: true,
  //           label: 'Code',
  //           description: `
  //             import { useEffect, useState } from 'react';
  //             import { Module, Question } from '../interfaces';
              
  //             const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
  //               const [result, setResult] = useState<Module | Question | null>(null);
              
  //               const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
  //                   for (let i = 0; i < array.length; i++) {
  //                     const obj = array[i];
  //                     if ("questions" in obj) {
  //                       const moduleObj = obj as Module;
  //                       getObjectById(moduleObj.questions, idForSearch);
  //                     }
  //                     if (obj.id === idForSearch) {
  //                       setResult(obj as Module | Question);
  //                       break;
  //                     }
  //                   }
  //                 }
              
  //               useEffect(() => {
  //                 getObjectById(array, id);
  //               }, [array, id]);
              
  //               return result;
  //             };
              
  //             export default useGetObjectById;
  //           `,
  //         },
  //       ],
  //     },
  //   ],
  // },
  {
    id: 3,
    name: 'HTML',
    questions: [
      {
        id: '3_1',
        question: 'question 1',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
      {
        id: '3_2',
        question: 'question 2',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
      {
        id: '3_3',
        question: 'question 3',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
    ],
  },
  {
    id: 4,
    name: 'CSS',
    questions: [
      {
        id: '4_1',
        question: 'question 1',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
      {
        id: '4_2',
        question: 'question 2',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
      {
        id: '4_3',
        question: 'question 3',
        descriptions: [
          {
            code: false,
            label: 'What is DNS?',
            description: `The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.
            Each device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).`,
          },
          {
            code: false,
            label: 'How does DNS work?',
            description: `The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.
            In order to understand the process behind the DNS resolution, it’s important to learn about the different hardware components a DNS query must pass between. For the web browser, the DNS lookup occurs "behind the scenes" and requires no interaction from the user’s computer apart from the initial request.`,
          },
          {
            code: true,
            label: 'Code',
            description: `
              import { useEffect, useState } from 'react';
              import { Module, Question } from '../interfaces';
              
              const useGetObjectById = ( array: (Question | Module)[], id : string): Module | Question | null => {
                const [result, setResult] = useState<Module | Question | null>(null);
              
                const getObjectById = (array: (Question | Module)[], idForSearch: string): void => {
                    for (let i = 0; i < array.length; i++) {
                      const obj = array[i];
                      if ("questions" in obj) {
                        const moduleObj = obj as Module;
                        getObjectById(moduleObj.questions, idForSearch);
                      }
                      if (obj.id === idForSearch) {
                        setResult(obj as Module | Question);
                        break;
                      }
                    }
                  }
              
                useEffect(() => {
                  getObjectById(array, id);
                }, [array, id]);
              
                return result;
              };
              
              export default useGetObjectById;
            `,
          },
        ],
      },
    ],
  },
  {
    id: 5,
    name: 'Princeples',
    questions: [
      {
        id: '5_1',
        question: 'question 1',
        descriptions: [],
      },
      {
        id: '5_2',
        question: 'question 2',
        descriptions: [],
      },
      {
        id: '5_3',
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: 6,
    name: 'ES5+, JavaScript',
    questions: [
      {
        id: '6_1',
        question: 'question 1',
        descriptions: [],
      },
      {
        id: '6_2',
        question: 'question 2',
        descriptions: [],
      },
      {
        id: '6_3',
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: 7,
    name: 'Webpack, Babel',
    questions: [
      {
        id: '7_1',
        question: 'question 1',
        descriptions: [],
      },
      {
        id: '7_2',
        question: 'question 2',
        descriptions: [],
      },
      {
        id: '7_3',
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: 8,
    name: 'Configuration project',
    questions: [
      {
        id: '8_1',
        question: 'question 1',
        descriptions: [],
      },
      {
        id: '8_2',
        question: 'question 2',
        descriptions: [],
      },
      {
        id: '8_3',
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: 9,
    name: 'React JS',
    questions: [
      {
        id: '9_1',
        question: 'question 1',
        descriptions: [],
      },
      {
        id: '9_2',
        question: 'question 2',
        descriptions: [],
      },
      {
        id: '9_3',
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: 10,
    name: 'Testing',
    questions: [
      {
        id: '10_1',
        question: 'question 1',
        descriptions: [],
      },
      {
        id: '10_2',
        question: 'question 2',
        descriptions: [],
      },
      {
        id: '10_3',
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: 11,
    name: 'Metodologies',
    questions: [
      {
        id: '11_1',
        question: 'question 1',
        descriptions: [],
      },
      {
        id: '11_2',
        question: 'question 2',
        descriptions: [],
      },
      {
        id: '11_3',
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
  {
    id: 12,
    name: 'Practical  part',
    questions: [
      {
        id: '12_1',
        question: 'question 1',
        descriptions: [],
      },
      {
        id: '12_2',
        question: 'question 2',
        descriptions: [],
      },
      {
        id: '12_3',
        question: 'question 3',
        descriptions: [],
      },
    ],
  },
];
